# Роль збірок .NET

.NET-додатки створюються шляхом об'єднання будь-якої кількості збірок. Простіше кажучи, збірка — це версіонований, самоописуваний двійковий файл, розміщений у середовищі виконання .NET. Незважаючи на те, що збірки .NET мають ті ж розширення файлів (*.exe або *.dll), що й попередні бінарні файли Windows, вони мають мало спільного з цими файлами. Перш ніж розібратися з останньою твердженням, давайте розглянемо деякі переваги, що надаються форматом збірки.

## Збірки сприяють повторному використанню коду

Оскільки ви створювали проекти консольних застосунків у попередніх розділах, могло здатися, що вся функціональність застосунків міститься у виконуваній збірці, яку ви створювали. Ваші програми використовували численні типи, що містяться в завжди доступних бібліотеках базових класів .NET.
Як ви, можливо, знаєте, бібліотека коду (також звана бібліотекою класів) – це *.dll, що містить типи, призначені для використання зовнішніми програмами. Під час створення виконуваних збірок ви, безсумнівно, використовуватимете численні системні та користувацькі бібліотеки коду під час створення своєї програми. Однак майте на увазі, що бібліотека коду не обов'язково повинна мати розширення файлу *.dll. Цілком можливо (хоча, звичайно, не є поширеним явищем), щоб виконувана збірка використовувала типи, визначені в зовнішньому виконуваному файлі. У цьому світлі, посилання на *.exe також можна вважати бібліотекою коду.
Незалежно від того, як упакована бібліотека коду, платформа .NET дозволяє повторно використовувати типи незалежно від мови. Наприклад, ви можете створити бібліотеку коду на C# та повторно використовувати цю бібліотеку в будь-якій іншій мові програмування .NET. Можливо не лише розподіляти типи між мовами програмування, але й створювати від них похідні елементи. Базовий клас, визначений у C#, може бути розширений класом, створеним у Visual Basic. Інтерфейси, визначені в F#, можуть бути реалізовані за допомогою структур, визначених в C# тощо. Річ у тім, що коли ви починаєте розбивати один монолітний виконуваний файл на численні збірки .NET, ви досягаєте мовно-нейтральної форми повторного використання коду.

## Збірки встановлюють межі типу

Нагадаємо, що повне ім'я типу складається шляхом додавання префікса простору імен типу (наприклад, System) до його імені (наприклад, Console). Однак, строго кажучи, збірка, в якій знаходиться тип, додатково встановлює ідентичність типу. Наприклад, якщо у вас є дві збірки з унікальними іменами (скажімо, MyCars.dll та YourCars.dll), які обидві визначають простір імен (CarLibrary), що містить клас з назвою SportsCar, вони вважаються унікальними типами у всесвіті .NET.

## Збірки – це одиниці, що підлягають версіонуванню

Збіркам .NET присвоюється чотиричастинний числовий номер версії у форматі \<major\>.\<minor\>.\<build\>.\<revision\> (<основний>.<допоміжний>.<збірка>.<редакція>). (Якщо номер версії не вказано явно, збірці автоматично присвоюється версія 1.0.0.0, враховуючи налаштування проекту .NET за замовчуванням.) Цей номер дозволяє кільком версіям однієї збірки співіснувати гармонійно на одному комп'ютері.

## Збірки є самоописними

Збірки вважаються самоописними, частково тому, що вони записують у маніфесті збірки кожну зовнішню збірку, до якої вони повинні мати доступ для правильного функціонування. Нагадаємо, що маніфест — це блоб метаданих, який описує саму збірку (назва, версія, необхідні зовнішні збірки тощо).
Окрім даних маніфесту, збірка містить метадані, які описують склад (імена членів, реалізовані інтерфейси, базові класи, конструктори тощо) кожного типу, що міститься в ній. Оскільки збірка документована настільки детально, середовище виконання .NET не звертається до системного реєстру Windows для визначення її розташування (досить радикальна відмова від застарілої моделі програмування COM від Microsoft). Таке відокремлення від реєстру є одним із факторів, що дозволяє .NET-застосункам працювати на інших операційних системах, окрім Windows, а також підтримувати кілька версій .NET на одному комп'ютері.
Як ви дізнаєтесь у цьому розділі, середовище виконання .NET використовує абсолютно нову схему для визначення розташування зовнішніх бібліотек коду.

# Розуміння формату збірки .NET

Тепер, коли ви дізналися про кілька переваг, які надає збірка .NET, давайте перейдемо до іншого напрямку та краще розглянемо, як влаштована збірка. Структурно збірка .NET складається з таких елементів:

1. Заголовок файлу операційної системи (наприклад, Windows)
2. Заголовок CLR-файлу
3. CIL-код
4. Метадані типу
5. Маніфест збірки
6. Додаткові вбудовані ресурси

Хоча перші два елементи (заголовки операційної системи та CLR) – це блоки даних, які зазвичай можна ігнорувати, вони заслуговують на короткий розгляд. Ось огляд кожного елемента.

### Встановлення інструментів профілювання C++

У наступних кількох розділах використовується утиліта dumpbin.exe, яка постачається разом із інструментами профілювання C++. Треба запустити Visual Studio Installer > Modifay > Individual components > В пошуку C++ profiling. В Visual Studio Code введіть C++ profiling tools у рядку швидкого пошуку та натисніть запит на встановлення інструментів.

## Заголовок файлу операційної системи (Windows)

Заголовок файлу операційної системи підтверджує той факт, що збірка може бути завантажена та оброблена цільовою операційною системою (у наступному прикладі, Windows). Ці дані заголовка також визначають тип програми (консольна, графічна або бібліотека коду *.dll), яка розміщуватиметься операційною системою. 
Відкрийте файл CarLibrary.dll (взято з репозиторію) за допомогою утиліти dumpbin.exe (через командний рядок розробника) з прапорцем /headers наступним чином:

```console
dumpbin /headers CarLibrary.dll
```
Тут відображається інформація про заголовок операційної системи збірки (показана нижче, якщо збірка зібрана для Windows). Ось (часткова) інформація про заголовок Windows для CarLibrary.dll:

```
Dump of file CarLibrary.dll

PE signature found

File Type: DLL

FILE HEADER VALUES
             14C machine (x86)
               3 number of sections
        BE7C76DA time date stamp
               0 file pointer to symbol table
               0 number of symbols
              E0 size of optional header
            2022 characteristics
                   Executable
                   Application can handle large (>2GB) addresses
                   DLL
```
Тепер пам'ятайте, що більшості програмістів .NET ніколи не потрібно буде турбуватися про формат заголовкових даних, вбудованих у збірку .NET. Якщо ви не створюєте новий компілятор мови .NET (де вам потрібна така інформація), ви можете залишатися в блаженному невіданні щодо похмурих деталей заголовкових даних. Однак майте на увазі, що ця інформація використовується приховано, коли операційна система завантажує бінарний образ у пам'ять.

## Заголовок файлу CLR

Заголовок CLR – це блок даних, який повинні підтримувати всі збірки .NET (і підтримують, завдяки компілятору C#), щоб його можна було розмістити в середовищі виконання .NET. Коротко кажучи, цей заголовок визначає численні прапорці, які дозволяють середовищу виконання розуміти макет керованого файлу. Наприклад, існують прапорці, які визначають розташування метаданих та ресурсів у файлі, версію середовища виконання, на основі якого було зібрано збірку, значення (необов'язкового) відкритого ключа тощо. Знову запустіть dumpbin.exe з прапорцем /clrheader.

```console
dumpbin /clrheader CarLibrary.dll
```

Вам буде представлено інформацію внутрішнього заголовка CLR для заданої збірки .NET, як показано тут:

```
Dump of file CarLibrary.dll

File Type: DLL

  clr Header:

              48 cb
            2.05 runtime version
            217C [     BE4] RVA [size] of MetaData Directory
               1 flags
                   IL Only
               0 entry point token
               0 [       0] RVA [size] of Resources Directory
               0 [       0] RVA [size] of StrongNameSignature Directory
               0 [       0] RVA [size] of CodeManagerTable Directory
               0 [       0] RVA [size] of VTableFixups Directory
               0 [       0] RVA [size] of ExportAddressTableJumps Directory
               0 [       0] RVA [size] of ManagedNativeHeader Directory


  Summary

        2000 .reloc
        2000 .rsrc
        2000 .text
```
Знову ж таки, як розробник .NET, вам не потрібно буде турбуватися про подробиці інформації заголовка CLR збірки. Просто зрозумійте, що кожна збірка .NET містить ці дані, які використовуються за лаштунками середовищем виконання .NET, коли дані завантажуються в пам'ять. Тепер зверніть свою увагу на деяку інформацію, яка набагато корисніша у ваших щоденних завданнях програмування.

## Код CIL, метадані типів та маніфест збірки

По суті, збірка містить код CIL, який, як ви пам'ятаєте, є проміжною мовою, незалежною від платформи та процесора. Під час виконання внутрішній CIL компілюється на льоту за допомогою компілятора just-in-time (JIT) відповідно до інструкцій, специфічних для платформи та процесора. З огляду на таку конструкцію, збірки .NET справді можуть виконуватися на різних архітектурах, пристроях та операційних системах.
Збірка також містить метадані, які повністю описують формат типів, що містяться в ній, а також формат зовнішніх типів, на які посилається ця збірка. Середовище виконання .NET використовує ці метадані для визначення розташування типів (та їхніх членів) у двійковому файлі, розміщення типів у пам'яті та полегшення викликів віддалених методів.
Ви ознайомитеся з деталями формату метаданих .NET у главі під час розгляду служб рефлексії.
Збірка також повинна містити пов'язаний маніфест (також званий метаданими збірки). Маніфест документує кожен модуль у збірці, встановлює версію збірки та документує будь-які зовнішні збірки, на які посилається поточна збірка. Як ви побачите протягом цього розділу, CLR широко використовує маніфест збірки під час процесу пошуку зовнішніх посилань на збірки.

## Додаткові ресурси збірок

Нарешті, збірка .NET може містити будь-яку кількість вбудованих ресурсів, таких як значки програм, файли зображень, звукові кліпи або таблиці рядків. Фактично, платформа .NET підтримує супутні збірки, які містять лише локалізовані ресурси. Це може бути корисним, якщо ви хочете розділити свої ресурси на основі певної культури (англійська, німецька тощо) з метою створення міжнародного програмного забезпечення. Якщо вас це цікавить, зверніться до документації .NET для отримання інформації про супутні збірки та локалізацію.

## Бібліотеки класів проти консольних програм

Досі в цій книзі приклади були майже виключно консольними програмами .NET. Консольні програми мають єдину точку входу (або вказаний метод Main(), або оператори верхнього рівня), можуть взаємодіяти з консоллю та запускатися безпосередньо з операційної системи. 
Бібліотеки класів, з іншого боку, не мають точки входу і тому не можуть бути запущені безпосередньо. Вони використовуються для інкапсуляції логіки, користувацьких типів тощо, і на них посилаються інші бібліотеки класів та/або консольні програми. Іншими словами, бібліотеки класів використовуються для зберігання елементів, про які йшлося в розділі «Роль збірок .NET».

# Бібліотеки класів .NET Standard проти .NET (Core)

Бібліотеки класів .NET (включно з .NET Core/.NET 5/...) працюють на .NET, а бібліотеки класів .NET Framework працюють на .NET Framework. Хоча це досить просто, тут є проблема. Припустімо, у вашій організації є велика база коду .NET Framework, з (можливо) роками розробки за плечима у вас та вашої команди. Ймовірно, існує значна кількість спільного коду, який використовується в додатках, які ви та ваша команда створювали протягом багатьох років. Можливо, це централізоване ведення журналу, звітування або функціональність, специфічна для домену.
Тепер ви (і ваша організація) хочете перейти на новий .NET для всієї нової розробки. А як щодо всього цього спільного коду? Переписування всього вашого застарілого коду в збірки .NET 6 може бути значним, і доки всі ваші програми не будуть перенесені на .NET 6, вам доведеться підтримувати дві версії (одну в .NET Framework і одну в .NET 6). Це призвело б до різкого зниження продуктивності. 
На щастя, розробники .NET продумали цей сценарій. .NET Standard — це новий тип проекту бібліотеки класів, який був представлений разом із .NET Core 1.0 і на який можуть посилатися як .NET Framework, так і .NET (Core) програми. Однак, перш ніж ви покладете на це великі надії, є один нюанс із .NET 5 та .NET 6. Докладніше про це трохи пізніше.
Кожна версія .NET Standard визначає спільний набір API, які повинні підтримуватися всіма версіями .NET (.NET, .NET Core, Xamarin тощо) для відповідності стандарту. Наприклад, якщо ви створюєте бібліотеку класів як проект .NET Standard 2.0, на неї можуть посилатися .NET 4.61+ та .NET Core 2.0+ (а також різні версії Xamarin, Mono, Universal Windows Platform та Unity).
Це означає, що ви можете перенести код з бібліотек класів .NET Framework до бібліотек класів .NET Standard 2.0, і вони можуть бути спільними для програм .NET (Core) та .NET Framework. Це набагато краще, ніж підтримка дублікатів одного й того ж коду, по одному для кожного фреймворку.
А тепер про підступ. Кожна версія .NET Standard являє собою найменший спільний знаменник для фреймворків, які вона підтримує. Це означає, що чим нижча версія, тим менше ви можете робити у своїй бібліотеці класів. Хоча проекти .NET Framework та .NET 6 можуть посилатися на бібліотеку .NET Standard 2.0, ви не можете використовувати значну кількість функцій C# 8.0 у бібліотеці .NET Standard 2.0, а також не можете використовувати жодні нові функції з C# 9.0 або пізнішої версії. Для повної підтримки C# 8.0+ необхідно використовувати .NET Standard 2.1. А .NET 4.8 (остання/найновіша версія оригінального .NET Framework) працює лише до .NET Standard 2.0.
Це все ще хороший механізм для використання існуючого коду в новіших програмах аж до .NET Core 3.1 включно, але не панацея. З об'єднанням фреймворків (.NET, Xamarin, Mon тощо) з .NET 6, корисність .NET Standard поступово відходить у минуле.

# Налаштування програм за допомогою файлів конфігурації

Хоча всю інформацію, необхідну для вашої .NET-програми, можна зберігати у вихідному коді, можливість змінювати певні значення під час виконання є життєво важливою у більшості важливих програм. Один з найпоширеніших варіантів — використовувати один або кілька файлів конфігурації, що постачаються (або розгортаються) разом із виконуваним файлом вашої програми.
.NET Framework здебільшого використовував XML-файли з назвою app.config (або web.config для ASP.NET-застосунків) для конфігурації. Хоча файли конфігурації на основі XML все ще можна використовувати, найпоширенішим методом налаштування .NET-застосунків є використання файлів JavaScript Object Notation (JSON).

    Примітка. Якщо ви не знайомі з JSON, це формат пари «ім'я-значення», де кожен об'єкт укладено у фігурні дужки. Значення також можуть бути об'єктами, що використовують той самий формат пари «ім'я-значення».

Щоб проілюструвати процес, створіть нову консольну програму .NET з назвою WorkWithConfiguration. В Developer Comand Prompt виконайте:
```
dotnet add package Microsoft.Extensions.Configuration
dotnet add package Microsoft.Extensions.Configuration.Binder
dotnet add package Microsoft.Extensions.Configuration.Json
```
Це додає посилання на підсистему конфігурації, підсистему конфігурації .NET на основі JSON-файлів та розширення прив’язки для конфігурації до вашого проєкту. Почніть з додавання нового JSON-файлу до вашого проєкту з назвою appsettings.json. Оновіть файл проєкту, щоб переконатися, що він завжди копіюється до вихідного каталогу під час збірки проєкту. 

```xml
    <ItemGroup>
        <None Update="appsettings.json">
            <CopyToOutputDirectory>Always</CopyToOutputDirectory>
        </None>
    </ItemGroup>
```

Оновіть файл appsettings.json, щоб він відповідав наступному:

```json
{
  "CarName": "Suzy"
}
```
Останнім кроком додавання конфігурації до вашої програми є зчитування файлу конфігурації та отримання значення CarName. Оновіть файл Program.cs до наступного:

```cs
using Microsoft.Extensions.Configuration;

IConfiguration config = new ConfigurationBuilder()
    .SetBasePath(Directory.GetCurrentDirectory())
    .AddJsonFile("appsettings.json", true, true)
    .Build();
```

Нова система конфігурації починається з ConfigurationBuilder. Шлях, за яким почнеться пошук доданих файлів під час збірки конфігурації, встановлюється за допомогою методу SetBasePath(). Потім файл конфігурації додається за допомогою методу AddJsonFile(), який приймає три параметри. Потім файл конфігурації додається за допомогою методу AddJsonFile(), який приймає три параметри. Оскільки цей файл знаходиться в тому ж місці, що й базовий шлях, у рядку немає жодної інформації про шлях, лише ім'я файлу. Другий параметр встановлює, чи є файл необов'язковим (true) чи обов'язковим (false), а останній параметр визначає, чи повинна конфігурація використовувати спостерігач файлів для пошуку будь-яких змін у файлі (true), чи ігнорувати будь-які зміни під час виконання (false). Останній крок — зібрати конфігурацію в екземпляр IConfiguration за допомогою методу Build().
Після створення екземпляра IConfiguration ви можете отримати значення з файлів конфігурації.

```cs
void ReadingFromConfiguration_1()
{
    Console.WriteLine($"My car's name is {config["CarName"]}");
}
ReadingFromConfiguration_1();
```
```
My car's name is Suzy

```
Якщо ім'я запиту не існує в конфігурації, результат буде null. Наступний код все одно виконується без винятку; він просто не відображає ім'я в першому рядку та відображає True в другому рядку:
```cs
void ReadingFromConfiguration_2()
{
    Console.WriteLine($"My car's name is {config["CarName2"]}");
    Console.WriteLine($"CarName2 is null? {config["CarName2"] == null}");
}
ReadingFromConfiguration_2();
```
```
My car's name is
CarName2 is null? True
```
Також існує метод GetValue() (та його узагальнена версія GetValue<T>()), який може отримувати примітивні значення з конфігурації. У наступному прикладі показано обидва ці методи отримання CarName:

```cs
void ReadingFromConfiguration_3()
{
    Console.WriteLine($"My car's name is {config.GetValue(typeof(string), "CarName")}");
    Console.WriteLine($"My car's name is {config.GetValue<string>("CarName")}");
}
ReadingFromConfiguration_3();
```
```
My car's name is Suzy
My car's name is Suzy
```
Ці методи повертають значення за замовчуванням (наприклад, null для посилальних типів, 0 для числових типів), якщо запитувана назва не існує. Наведений нижче код повертає 0 для властивості CarName2.

```cs
void ReadingFromConfiguration_4()
{
    Console.WriteLine($"My car's name is {config.GetValue<int>("CarName2")}");
}
ReadingFromConfiguration_4();
```
```
My car's name is 0
```
Ці методи викинуть виняток, якщо знайдене значення для імені не може бути внутрішньо приведене до запитуваного типу даних. Наприклад, спроба привести властивість CarName до цілого числа призведе до виникнення InvalidOperationException, як показано в наступному коді:

```cs
void ReadingFromConfiguration_5()
{
    try
    {
        Console.WriteLine($"My car's name is {config.GetValue<int>("CarName")}");
    }
    catch (InvalidOperationException ex)
    {
        Console.WriteLine($"An exception occurred: {ex.Message}");
    }
}
ReadingFromConfiguration_5();
```
```
An exception occurred: Failed to convert configuration value 'Suzy' at 'CarName' to type 'System.Int32'.
```

    Метод GetValue() призначений для роботи з примітивними типами. Для складних типів використовуйте методи Bind() або Get()/Get<T>(), описані в розділі «Робота з об’єктами».

## Кілька файлів конфігурації

До системи конфігурації можна додати більше одного файлу конфігурації. Коли використовується більше одного файлу, властивості конфігурації є адитивними, якщо тільки жодні імена пар «ім'я-значення» не конфліктують. У разі конфлікту імен перемагає той, що вказано останнім. Щоб побачити це в дії, додайте ще один файл з назвою appsettings.development.json та налаштуйте проект так, щоб він завжди копіювався до вихідного каталогу.

```xml
  <ItemGroup>
    <None Update="appsettings.development.json">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
    <None Update="appsettings.json">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
  </ItemGroup>
```
Оновіть appsettings.development.json до наступного:

```json
{
  "CarName": "Julia"
}
```
Тепер оновіть код, який створює екземпляр інтерфейсу IConfiguration, до наступного:

```cs
IConfiguration config = new ConfigurationBuilder()
    .SetBasePath(Directory.GetCurrentDirectory())
    .AddJsonFile("appsettings.json", true, true)
    .AddJsonFile("appsettings.development.json", true, true)
    .Build();
```
Коли ви запустите метод шо считує конфігурацію(наприклад перший), ви побачите, що назва автомобіля справді Julia, а не Suzy.

```
My car's name is Julia
```
## Робота з об'єктами

Наш приклад JSON-файлу на даний момент надзвичайно простий з однією парою ім'я-значення. У реальних проектах конфігурація застосунку зазвичай складніша, ніж одна властивість. Оновіть файл appsettings.development.json до наступного, що додасть новий об'єкт Car до JSON:
```json
{
  "CarName": "Julia",
  "Car": {
    "Make": "Honda",
    "Color": "Blue",
    "PetName": "Dad's Taxi"
  }
}
```
Для доступу до багаторівневих значень JSON ключем, що використовується для пошуку, є ієрархія JSON, де кожен рівень розділяється двокрапками (:). Наприклад, ключем для властивості Make об'єкта Car є Car:Marke. Оновіть оператори верхнього рівня до наступного, щоб отримати всі властивості Car та відобразити їх:

```cs
void ReadingFromConfiguration_6()
{
    Console.Write($"My car object is a {config["Car:Color"]} ");
    Console.WriteLine($"{config["Car:Make"]} named {config["Car:PetName"]}");
}
ReadingFromConfiguration_6();
```
```
My car object is a Blue Honda named Dad's Taxi
```
Замість перегляду ієрархії імен, цілі розділи можна отримати за допомогою методу GetSection(). Після того, як у вас є розділ, ви можете отримати значення з нього, використовуючи простий формат імені, як показано в наступному прикладі:

```cs
void ReadingFromConfiguration_7()
{
    IConfigurationSection section = config.GetSection("Car");
    Console.Write($"My car object is a {section["Color"]} ");
    Console.WriteLine($"{section["Make"]} named {section["PetName"]}");
}
ReadingFromConfiguration_7();
```
```
My car object is a Blue Honda named Dad's Taxi
```
Як останнє зауваження щодо роботи з об'єктами, ви можете використовувати метод Bind() для прив'язки значень конфігурації до існуючого екземпляра об'єкта або метод Get() для створення нового екземпляра об'єкта. Вони схожі на метод GetValue(), але працюють з непримітивними типами. Щоб розпочати, створіть простий клас Car:

```cs
namespace WorkWithConfiguration;

public class Car
{
    public string Make { get; set; }
    public string Color { get; set; }
    public string PetName { get; set; }
}
```
Далі створіть новий екземпляр класу Car, а потім викличте Bind() для секції, що передається в екземплярі Car:

```cs
void ReadingFromConfiguration_8()
{
    IConfigurationSection section = config.GetSection("Car");

    var c = new Car();
    section.Bind(c);

    Console.Write($"My car object is a {c.Color} ");
    Console.WriteLine($"{c.Make} named {c.PetName}");
}
ReadingFromConfiguration_8();
```
```
My car object is a Blue Honda named Dad's Taxi
```
Якщо секція не налаштовано, метод Bind() не оновить екземпляр, а залишить усі властивості такими, якими вони існували до виклику Bind(). Наступний код залишить значення Колір (Color) на Червоний (Red), а решта властивостей – нульовими (null):
```cs
void ReadingFromConfiguration_9()
{
    var notFoundCar = new Car
    {
        Color = "Red"
    };

    config.GetSection("Car2").Bind(notFoundCar);
    Console.Write($"My car object is a {notFoundCar.Color} ");
    Console.WriteLine($"{notFoundCar.Make} named {notFoundCar.PetName}");
}
ReadingFromConfiguration_9();
```
```
My car object is a Red  named
```
Метод Get() створює новий екземпляр заданого типу з розділу конфігурації. Неузагальнена версія методу повертає об'єктний тип, тому повернене значення має бути приведене до певного типу перед використанням. Ось приклад використання методу Get() для створення екземпляра класу Car з розділу Car конфігурації:

```cs
void ReadingFromConfiguration_10()
{
    var carFromGet = config.GetSection(nameof(Car)).Get(typeof(Car)) as Car;
    Console.Write($"My car object (using Get()) is a {carFromGet.Color} ");
    Console.WriteLine($"{carFromGet.Make} named {carFromGet.PetName}");

}
ReadingFromConfiguration_10();
```
```
My car object (using Get()) is a Blue Honda named Dad's Taxi
```

Якщо іменований розділ не знайдено, метод Get() повертає значення null:

```cs
void ReadingFromConfiguration_11()
{
    var notFoundCarFromGet = config.GetSection("Car2").Get(typeof(Car));
    Console.WriteLine($"The not found car is null? {notFoundCarFromGet == null}");
}
ReadingFromConfiguration_11();
```
```
The not found car is null? True
```
Узагальнена версія повертає екземпляр зазначеного типу без необхідності виконання приведення типів. Якщо секція не знайдена, метод повертає null.

```cs
void ReadingFromConfiguration_12()
{
    var carFromGet = config.GetSection(nameof(Car)).Get<Car>();
    Console.Write($"My car object (using Get()) is a {carFromGet.Color} ");
    Console.WriteLine($"{carFromGet.Make} named {carFromGet.PetName}");

    var notFoundCarFromGet = config.GetSection("Car2").Get<Car>();
    Console.WriteLine($"The not found car is null? {notFoundCarFromGet == null}"); ;
}
ReadingFromConfiguration_12();
```
```
My car object (using Get()) is a Blue Honda named Dad's Taxi
The not found car is null? True
```
Методи Bind() та Get()/Get<T>() використовують рефлексію (розглянуту в наступному розділі) для зіставлення імен публічних властивостей класу з іменами в розділі конфігурації без урахування регістру. Наприклад, якщо ви оновите appsettings.development.json до наступного (зверніть увагу на зміну регістру літер у властивості petName), попередній код все ще працюватиме:

```json
{
  "CarName": "Suzy",
  "Car": {
    "Make": "Honda",
    "Color": "Blue",
    "petName": "Dad's Taxi"
  }
}
```
Якщо властивість у конфігурації не існує в класі (або її назва пишеться інакше), то це конкретне значення конфігурації (за замовчуванням) ігнорується. Якщо ви оновите JSON до наступного значення, властивості Mark та Color будуть заповнені, але властивість PetName об'єкта Car не буде заповнена:

```json
{
  "CarName": "Suzy",
  "Car": {
    "Make": "Honda",
    "Color": "Blue",
    "PetNameForCar": "Dad's Taxi"
  }
}
```
Методи Bind(), Get() та Get<T>() можуть додатково приймати Action\<BinderOptions\> для подальшого уточнення процесу оновлення (Bind()) або створення екземплярів класу (Get()/Get<T>()). Клас BinderOptions наведено тут:

```cs
public class BinderOptions
{
  public bool BindNonPublicProperties { get; set; } //Defaults to false
  public bool ErrorOnUnknownConfiguration { get; set; } //Defaults to false
}
```
Якщо для параметра ErrorOnUnknownConfiguration встановлено значення true, тоді буде викинуто виняток InvalidOperationException, якщо конфігурація містить ім'я, якого не існує в моделі. З перейменованим значенням конфігурації (PetNameForCar) наступний виклик викидає виняток, зазначений у прикладі коду:

```cs
void ReadingFromConfiguration_13()
{
    try
    {
        _ = config
            .GetSection(nameof(Car))
            .Get<Car>(bo => bo.ErrorOnUnknownConfiguration = true);
    }
    catch (InvalidOperationException ex)
    {
        Console.WriteLine($"An exception occurred: {ex.Message}");
    }
}
ReadingFromConfiguration_13();
```
```
An exception occurred: 'ErrorOnUnknownConfiguration' was set on the provided BinderOptions, but the following properties were not found on the instance of WorkWithConfiguration.Car: 'PetNameForCar'
```
Інший варіант дозволяє прив’язувати непублічні властивості. За замовчуванням обидві властивості мають значення false. Якщо непублічні властивості мають бути пов'язані з конфігурацією, встановіть BindNonPublicProperties ось так:

```cs
var carFromGet = config
    .GetSection(nameof(Car))
    .Get<Car>(bo=>bo.BindNonPublicProperties=true);
```
Метод GetRequiredSection() викличе виняток, якщо секція не налаштована. Наприклад, наступний код викличе виняток, оскільки в конфігурації немає розділу Car2:

```cs
void ReadingFromConfiguration_14()
{
    var notFoundCar = new Car();

    try
    {
        config.GetRequiredSection("Car2").Bind(notFoundCar);
    }
    catch (InvalidOperationException ex)
    {
        Console.WriteLine($"An exception occurred: {ex.Message}");
    }
}
ReadingFromConfiguration_14();
```
```
An exception occurred: Section 'Car2' not found in configuration.
```
## Додаткові параметри конфігурації

Окрім використання конфігурації на основі файлів, існують опції використання змінних середовища, Azure Key Vault, аргументів командного рядка та багатьох інших. Багато з них використовуються безпосередньо в ASP.NET Core, як ви побачите далі. Ви також можете звернутися до документації .NET для отримання додаткової інформації про використання інших методів налаштування програм.
