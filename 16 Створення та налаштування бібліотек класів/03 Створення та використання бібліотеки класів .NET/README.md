# Створення та використання бібліотеки класів .NET

Щоб розпочати дослідження світу бібліотек класів .NET, спочатку створите збірку *.dll (з назвою CarLibrary), яка містить невеликий набір публічних типів. Якщо ви працюєте у Visual Studio, назвіть файл рішення BuildingAndUsingLibrary. Далі в цьому розділі ви додасте кліентський проект до рішення. 

Нагадуємо, що ви можете створювати та керувати рішеннями та проектами через інтерфейс командного рядка (CLI) .NET. Використовуйте таку команду для створення рішення та бібліотеки класів:

```
md BuildingAndUsingLibrary
cd BuildingAndUsingLibrary
dotnet new sln
dotnet new classlib -n CarLibrary
dotnet sln add .\CarLibrary
```
Третя команда створює порожній файл рішення з назвою у поточному каталозі. Наступна команда створює нову бібліотеку класів .NET з назвою CarLibrary (-n) у підкаталозі з назвою CarLibrary. Остання команда додає новий проєкт до рішення.

    Інтерфейс командного рядка .NET має зручну систему довідки. Наприклад, щоб переглянути всі шаблони, введіть dotnet new list. Щоб отримати додаткові відомості про створення бібліотеки класів, введіть dotnet new classlib -h .

Тепер, коли ви створили проект бібліотеки і рішення, ви можете відкрити його у Visual Studio (або Visual Studio Code), щоб розпочати створення класів. Після відкриття рішення видаліть автоматично згенерований файл Class1.cs.

Проектування вашої автомобільної бібліотеки починається з перерахувань EngineStateEnum та MusicMediaEnum. Додайте до свого проєкту два файли з назвами MusicMediaEnum.cs та EngineStateEnum.cs і додайте наступний код до кожного файлу відповідно:

EngineStateEnum.cs

```cs
namespace CarLibrary;

// Represents the state of the engine.
public enum EngineStateEnum
{
    EngineAlive,
    EngineDead
}
```
MusicMediaEnum.cs
```cs
namespace CarLibrary;

// Which type of music player does this car have?
public enum MusicMediaEnum
{
    MusicCd,
    MusicTape,
    MusicRadio,
    MusicMp3
}
```
Далі, вставте у свій проект новий файл класу C# з назвою Car.cs, який міститиме абстрактний базовий клас з назвою Car. Цей клас визначає різні дані про стан за допомогою автоматичного синтаксису властивостей. Цей клас також має один абстрактний метод під назвою TurboBoost(), який використовує перерахування EngineStateEnum для представлення поточного стану двигуна автомобіля.

```cs
namespace CarLibrary;

public abstract class Car
{
    public string PetName { get; set; } = string.Empty; 
    public int MaxSpeed { get; set; }
    public int CurrentSpeed { get; set; }

    protected EngineStateEnum State = EngineStateEnum.EngineAlive;
    public EngineStateEnum EngineState => State;
    public abstract void TurboBoost();

    protected Car() { }
    protected Car(string name, int maxSpeed, int currentSpeed)
    {
        PetName = name;
        MaxSpeed = maxSpeed;
        CurrentSpeed = currentSpeed;
    }
}
```
Тепер припустимо, що у вас є два прямих нащадки типу Car з назвами MiniVan та SportsCar.
Кожен з них перевизначає абстрактний метод TurboBoost(), відображаючи відповідне повідомлення через консольне повідомлення. Вставте два нових файли класів C# у ваш проєкт, з назвами MiniVan.cs та SportsCar.cs відповідно. Оновіть код у кожному файлі відповідним кодом.

SportsCar.cs
```cs
namespace CarLibrary;

public class SportsCar : Car
{
    public SportsCar()
    {
    }

    public SportsCar(string name, int maxSpeed, int currentSpeed) : base(name, maxSpeed, currentSpeed)
    {
    }

    public override void TurboBoost()
    {
        Console.WriteLine("Ramming speed! Faster is better...");
    }
}
```
MiniVan.cs
```cs
namespace CarLibrary;

public class MiniVan : Car
{
    public MiniVan()
    {
    }
    public MiniVan(string name, int maxSpeed, int currentSpeed) : base(name, maxSpeed, currentSpeed)
    {
    }

    public override void TurboBoost()
    {
        // Minivans have poor turbo capabilities!
        State = EngineStateEnum.EngineDead;
        Console.WriteLine("Eek! Your engine block exploded!");
    }
}
```
Скомпілюйте проект.

## Огляд маніфесту

Перш ніж використовувати CarLibrary.dll з клієнтської програми, давайте перевіримо, як побудована бібліотеку коду. Припускаючи, що ви скомпілювали цей проект, запустіть ildasm.exe для скомпільованої збірки. Запустіть з командного рядка 

```
ildasm /METADATA /out=CarLibrary.il .\CarLibrary\bin\Debug\netX.0\CarLibrary.dll
```
Розділ маніфесту дизасембльованих результатів починається з // Metadata version: v4.0.30319. Відразу після цього наведено список усіх зовнішніх збірок, необхідних для бібліотеки класів, як показано тут:

```
// Metadata version: v4.0.30319
.assembly extern System.Runtime
{
  .publickeytoken = (B0 3F 5F 7F 11 D5 0A 3A )                         // .?_....:
  .ver 9:0:0:0
}
.assembly extern System.Console
{
  .publickeytoken = (B0 3F 5F 7F 11 D5 0A 3A )                         // .?_....:
  .ver 9:0:0:0
}
```
Кожен блок .assembly extern кваліфікується директивами .publickeytoken та .ver. Інструкція .publickeytoken присутня лише тоді, коли збірка налаштована зі строгим ім'ям. Маркер .ver визначає числовий ідентифікатор версії збірки, на яку посилаються. 

Після зовнішніх посилань ви знайдете низку токенів .custom, які ідентифікують атрибути рівня збірки (деякі згенеровані системою, а також інформацію про авторські права, назву компанії, версію збірки тощо).

```
.assembly CarLibrary
{
...
  .custom instance void ... TargetFrameworkAttribute ...
  .custom instance void ... AssemblyCompanyAttribute ...
  .custom instance void ... AssemblyConfigurationAttribute ...
  .custom instance void ... AssemblyFileVersionAttribute ...
  .custom instance void ... AssemblyProductAttribute ...
  .custom instance void ... AssemblyTitleAttribute ...
}
```
Ці параметри можна встановити або за допомогою сторінок властивостей Visual Studio, або редагуючи файл проекту та додаючи відповідні елементи. Щоб редагувати властивості пакета у Visual Studio 2022, клацніть правою кнопкою миші на проекті в Solution Explorer, виберіть «Properties» та перейдіть до меню «Package » у лівій частині вікна.

    На екрані пакета є три різні поля версії. Версія збірки та версія файлу використовують ту саму схему, яка базується на семантичному версіонуванні (https://semver.org). Перше число – це основна версія збірки, друге – проміжна версія збірки, а третє – номер патча. Четверте число зазвичай використовується для позначення номера збірки. Номер версії пакета має відповідати семантичному версіонуванню, використовуючи лише заповнювачі {major}.{minor}.{patch} Семантичне версіонування дозволяє використовувати буквено-цифрове розширення версії, яке розділяється тире замість крапки (наприклад, 1.0.0-rc). Це позначає неповні версії, такі як бета-версії та реліз-кандидати. Версія пакета встановлює версію пакета NuGet (пакування NuGet детальніше розглядається далі в цьому розділі). Версія збірки використовується .NET під час збірки та виконання для пошуку, зв'язування та завантаження збірок. Версія файлу використовується лише Провідником Windows і не використовується .NET.

Інший спосіб додати метадані до вашої збірки – це безпосередньо у файлі проекту *.csproj. Наступне оновлення основної групи властивостей (PropertyGroup) у файлі проекту виконує те саме, що й заповнення форми. Зверніть увагу, що версія пакета у файлі проекту називається просто Version.

```xml
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <Copyright>Copyright 2026</Copyright>
    <Authors>Alex Po</Authors>
    <Company>BusinessSoft</Company>
    <Product>My look at C#</Product>
    <PackageId>CarLibrary</PackageId>
    <Description>This is an awesome library for cars.</Description>
    <AssemblyVersion>1.0.0.1</AssemblyVersion>
    <Version>1.0.3</Version>
  </PropertyGroup>
```
    Решта записів (і список файлів проекту) використовуються під час створення пакетів NuGet з вашої збірки. Це розглядається далі в цьому розділі.

## Дослідження CIL

Нагадаємо, що збірка не містить інструкцій, специфічних для платформи; вона містить інструкції Common Intermediate Language (CIL), незалежні від платформи. Коли середовище виконання .NET завантажує збірку в пам'ять, базовий CIL компілюється (за допомогою JIT-компілятора) в інструкції, які можуть бути зрозумілі цільовій платформі. Наприклад, метод TurboBoost() класу SportsCar представлений наступним CIL:

```
.method public hidebysig virtual instance void 
        TurboBoost() cil managed
{
  // Code size       13 (0xd)
  .maxstack  8
  IL_0000:  nop
  IL_0001:  ldstr      "Ramming speed! Faster is better..."
  IL_0006:  call       void [System.Console]System.Console::WriteLine(string)
  IL_000b:  nop
  IL_000c:  ret
} // end of method SportsCar::TurboBoost
```
Як і в інших прикладах CIL у цій книзі, більшості розробників .NET не потрібно глибоко заглиблюватися в деталі.

## Дослідження метаданих типів

Перш ніж створювати деякі програми, що використовують вашу власну бібліотеку .NET, перевірте метадані для типів у збірці CarLibrary.dll. Для прикладу, ось TypeDef для EngineStateEnum:

```
EngineStateEnum:
 TypeDef #2
 -------------------------------------------------------
  TypDefName: CarLibrary.EngineStateEnum
  Flags     : [Public] [AutoLayout] [Class] [Sealed] [AnsiClass]
  Extends   : [TypeRef] System.Enum
  Field #1
  -------------------------------------------------------
   Field Name: value__
   Flags     : [Public] [SpecialName] [RTSpecialName]
   CallCnvntn: [FIELD]
   Field type:  I4
  Field #2
  -------------------------------------------------------
   Field Name: EngineAlive
   Flags     : [Public] [Static] [Literal] [HasDefault]
  DefltValue: (I4) 0
   CallCnvntn: [FIELD]
   Field type:  ValueClass CarLibrary.EngineStateEnum
  Field #3
  -------------------------------------------------------
   Field Name: EngineDead
   Flags     : [Public] [Static] [Literal] [HasDefault]
  DefltValue: (I4) 1
   CallCnvntn: [FIELD]
   Field type:  ValueClass CarLibrary.EngineStateEnum
```
Як пояснюється в наступному розділі, метадані збірки є важливим елементом платформи .NET і слугують основою для численних технологій (серіалізація об'єктів, пізнє зв'язування, розширювані програми тощо). У будь-якому разі, тепер, коли ви зазирнули всередину збірки CarLibrary.dll, ви можете створювати клієнтські програми, які використовують ваші типи.

# Створення клієнтської програми C#

Оскільки кожен із типів проекту CarLibrary було оголошено за допомогою ключового слова public, інші програми .NET також можуть їх використовувати. Нагадаємо, що ви також можете визначати типи за допомогою ключового слова internal у C# (фактично, це режим доступу C# за замовчуванням для класів). Внутрішні типи можуть використовуватися лише збіркою, в якій вони визначені. Зовнішні клієнти не можуть ні бачити, ні створювати типи, позначені ключовим словом internal.

    Винятком із внутрішнього правила є випадок, коли збірка явно дозволяє доступ до іншої збірки за допомогою атрибута InternalsVisibleTo, який буде розглянуто пізніше.

Щоб скористатися функціональністю вашої бібліотеки, створіть новий проект консольного застосунку C# з назвою CSharpCarClient у тому ж рішенні, що й CarLibrary. Ви можете зробити це за допомогою Visual Studio (клацніть правою кнопкою миші на рішенні та виберіть Add ➤ New Project) або за допомогою командного рядка в каталозі рішення (три рядки, кожен з яких виконується окремо).

```
dotnet new console -n CSharpCarClient
dotnet add CSharpCarClient reference CarLibrary
dotnet sln add .\CSharpCarClient
```
Попередні команди створили консольну програму, додали посилання на проект CarLibrary для нового проекту та додали його до вашого рішення.

    Команда add reference створює посилання на проект. Це зручно для розробки, оскільки CSharpCarClient завжди використовуватиме останню версію CarLibrary. Ви також можете посилатися на збірку безпосередньо. Прямі посилання створюються шляхом посилання на скомпільовану бібліотеку класів.

Якщо рішення все ще відкрите у Visual Studio, ви помітите, що новий проект відображається в Solution Explorer. Остання зміна, яку потрібно внести, – це клацнути правою кнопкою миші на CSharpCarClient у Solution Explorer і вибрати «Set as Startup Project». Якщо ви не використовуєте Visual Studio, ви можете запустити новий проект, виконавши команду dotnet run у каталозі проекту.
Ви також можете встановити посилання на проект у Visual Studio, клацнувши правою кнопкою миші на проекті CSharpCarClient у Solution Explorer, вибравши Add ➤ Project Reference та вибравши проект CarLibrary з вузла проекту.

На цьому етапі ви можете створити клієнтську програму для використання зовнішніх типів. Оновіть файл Program.cs наступним чином:

```cs
using CarLibrary;

void UsingTypeFromCarLibrary()
{
    // Make a sports car.
    SportsCar viper = new SportsCar("Viper", 240, 40);
    viper.TurboBoost();

    // Make a minivan.
    MiniVan mv = new MiniVan();
    mv.TurboBoost();
}
UsingTypeFromCarLibrary();
```
```
Ramming speed! Faster is better...
Eek! Your engine block exploded!
```
Цей код виглядає так само, як і код інших розроблених досі програм.  Запустіть свою програму та переконайтеся, що ви бачите відображення повідомлень.

Вам може бути цікаво, що саме сталося, коли ви посилалися на проект CarLibrary. Коли створюється посилання на проект, порядок збірки рішення коригується таким чином, що залежні проекти (у цьому прикладі CarLibrary) збираються першими, а потім вивід цієї збірки копіюється до вихідного каталогу батьківського проекту (CSharpCarLibrary). Скомпільована клієнтська бібліотека посилається на скомпільовану бібліотеку класів. Коли клієнтський проект перебудовується, залежна бібліотека також перебудовується, і нова версія знову копіюється до цільової папки.
Якщо ви використовуєте Visual Studio, ви можете натиснути кнопку «Show All Files» в Solution Explorer, щоб переглянути всі вихідні файли та перевірити наявність скомпільованої CarLibrary. Якщо ви використовуєте Visual Studio Code, перейдіть до каталогу bin/debug/netX.0 на вкладці «Explorer». Коли створюється пряме посилання замість посилання на проект, скомпільована бібліотека також копіюється до вихідного каталогу клієнтської бібліотеки, але в момент створення посилання. Без посилання на проект проекти можуть бути зібрані незалежно один від одного, і файли можуть стати несинхронізованими. Коротше кажучи, якщо ви розробляєте залежні бібліотеки (як це зазвичай буває у випадку з реальними програмними проектами), найкраще посилатися на проект, а не на його результат.

# Відкриття внутрішніх типів іншим збіркам

Як згадувалося раніше, внутрішні класи видимі лише для інших об'єктів у збірці, де вони визначені. Винятком є ​​випадок, коли видимість явно надана іншому проекту. 
Почніть з додавання нового класу з назвою MyInternalClass до проєкту CarLibrary та оновіть код до наступного:

```cs
namespace CarLibrary;

internal class MyInternalClass
{
    internal void Hi()
    {
        Console.WriteLine("Hi");
    }
}
```
Навіщо взагалі розкривати внутрішні типи? Зазвичай це робиться для модульного та інтеграційного тестування. Розробники хочуть мати можливість тестувати свій код, але не обов'язково розкривати його за межами збірки.

## Використання атрибута збірки

У наступній главі атрибути будуть розглянуті детально, але поки що відкрийте клас Car.cs у проекті CarLibrary та додайте наступний атрибут і оператор using:

```cs
using System.Runtime.CompilerServices;
[assembly:InternalsVisibleTo("CSharpCarClient")]
namespace CarLibrary;
```
Атрибут InternalsVisibleTo приймає назву проекту, який може бачити клас, для якого встановлено атрибут. Зверніть увагу, що інші проекти не можуть «запитувати» цей дозвіл; його має надати проект, що містить внутрішні типи.

Тепер ви можете оновити проект CSharpCarClient, додавши наступний код :

```cs
void UsingInternalType()
{
    var internalClassInstance = new MyInternalClass();
    internalClassInstance.Hi();
}
UsingInternalType();
```
```
Hi
```

## Використання файлу проекту

Інший спосіб досягти того ж результату – використати оновлені можливості у файлі проекту .NET. Закоментуйте атрибут, який ви щойно додали, та відкрийте файл проєкту для CarLibrary. Додайте наступний ItemGroup до файлу проекту:

```xml
   <ItemGroup>
        <AssemblyAttribute Include="System.Runtime.CompilerServices.InternalsVisibleToAttribute">
            <_Parameter1>CSharpCarClient</_Parameter1>
        </AssemblyAttribute>
    </ItemGroup>
```
Це досягає того ж самого ефекту, що й використання атрибута для класу, і, на мою думку, є кращим рішенням, оскільки інші розробники побачать його безпосередньо у файлі проекту, замість того, щоб знати, де шукати по всьому проекту.

# NuGet та .NET

NuGet — це менеджер пакетів для .NET. Це механізм для спільного використання програмного забезпечення у форматі, який розуміють .NET-додатки, і є механізмом за замовчуванням для завантаження .NET та пов'язаних з ним частин платформи (ASP.NET Core, EF Core тощо). Багато організацій упаковують свої стандартні збірки для комплексних завдань у пакети NuGet для використання у своїх бізнес-додатках.

## Пакування збірок за допомогою NuGet

Щоб побачити це в дії, ми перетворимо CarLibrary на пакет NuGet, а потім посилатимемося на нього з клієнтської програми. 

Властивості пакета NuGet можна переглянути на сторінках властивостей проекту. Клацніть правою кнопкою миші на проекті CarLibrary та виберіть «Properties». Перейдіть на сторінку Package і перегляньте значення, які ми ввели раніше для налаштування збірки. Для пакета NuGet можна встановити додаткові властивості (наприклад, прийняття ліцензійної угоди та інформація про проект, така як URL-адреса та розташування репозиторію).

    Усі значення на сторінці інтерфейсу користувача пакета Visual Studio можна ввести у файл проєкту вручну, але вам потрібно знати ключові слова. Варто хоча б один раз використати Visual Studio, щоб заповнити все, а потім ви зможете редагувати файл проєкту вручну. Ви також можете знайти всі допустимі властивості в документації .NET.

У цьому прикладі нам не потрібно встановлювати жодних додаткових властивостей, окрім встановлення прапорця «Generate NuGet package on build» або оновлення файлу проекту наступним:

```cs
  <PropertyGroup>
    //...
    <Version>1.0.3</Version>
    <GeneratePackageOnBuild>True</GeneratePackageOnBuild>
  </PropertyGroup>
```
Це призведе до перебудови пакета щоразу, коли програмне забезпечення збирається. За замовчуванням пакет буде створено в папці bin/Debug або bin/Release, залежно від вибраної конфігурації.
Пакети також можна створювати з командного рядка, а CLI надає більше опцій, ніж Visual Studio. Наприклад, щоб зібрати пакет і помістити його в каталог під назвою Publish, введіть такі команди (у каталозі проекту CarLibrary). Перша команда збирає збірку, а друга пакує пакет NuGet.

```
dotnet build -c Release
dotnet pack -o .\Publish -c Release
```

## Посилання на пакети NuGet

Вам може бути цікаво, звідки взялися пакети, додані в попередніх прикладах. Розташування пакетів NuGet контролюється файлом на основі XML з назвою NuGet.Config. У Windows цей файл знаходиться в каталозі %appdata%\NuGet. Це головний файл. Відкрийте його, і ви побачите кілька джерел пакетів.

```xml
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <add key="nuget.org" value="https://api.nuget.org/v3/index.json" protocolVersion="3" />
    <add key="Microsoft Visual Studio Offline Packages" value="C:\Program Files (x86)\Microsoft SDKs\NuGetPackages\" />
  </packageSources>
  <packageRestore>
    <add key="enabled" value="True" />
    <add key="automatic" value="True" />
  </packageRestore>
  <bindingRedirects>
    <add key="skip" value="False" />
  </bindingRedirects>
  <packageManagement>
    <add key="format" value="0" />
    <add key="disabled" value="False" />
  </packageManagement>
</configuration>
```
У попередньому списку файлів показано два джерела. Перше вказує на NuGet.org, який є найбільшим репозиторієм пакетів NuGet у світі. Другий знаходиться на вашому локальному диску та використовується Visual Studio як кеш пакетів.

Важливо зазначити, що файли NuGet.Config за замовчуванням є адитивними. Щоб додати додаткові джерела, не змінюючи список для всієї системи, можна додати додаткові файли NuGet.Config. Кожен файл дійсний для каталогу, в якому він розміщений, а також для будь-якого підкаталогу. Додайте новий файл з іменем NuGet.Config до каталогу рішення та оновіть його вміст таким чином:

```xml
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <add key="local-packages" value=".\CarLibrary\Publish" />
  </packageSources>
</configuration>
```
Ви також можете скинути список пакетів, додавши <clear/> до вузла <packageSources>, ось так:

```xml
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <clear />
    <add key="local-packages" value=".\CarLibrary\Publish" />
    <add key="NuGet" value="https://api.nuget.org/v3/index.json" />
  </packageSources>
</configuration>
```

    Якщо ви використовуєте Visual Studio, вам доведеться перезапустити IDE, перш ніж оновлені налаштування nuget.config набудуть чинності.

Видаліть посилання на проект із проекту CSharpCarClient, а потім додайте посилання на пакети (з каталогу проекту):

```
dotnet add package CarLibrary
```
Після встановлення посилань зберіть рішення та перегляньте вивід у цільових каталогах (bin\Debug\newX.0), і ви побачите CarLibrary.dll у каталозі, а не файл CarLibrary.nupkg. Це пояснюється тим, що .NET розпаковує вміст і додає збірки, що містяться в ньому, як прямі посилання. 
Тепер запустіть програму, і вона працює точно так само, як і раніше. 
Тепер змініть назву класу з SportsCar на SportCar. Далі оновіть номер версії пакета CarLibrary до 1.0.4 та перепакуйте його. 
```
dotnet build -c Release
dotnet pack -o .\Publish -c Release

```

У каталозі Publish тепер є два пакети CarLibrary NuGet. Якщо повторно виконати команди додавання пакета(в каталозі проекту), проект буде оновлено для використання нової версії.

```
 dotnet add package CarLibrary
```
При цьому оскілки змінилась назва типу для клієнтськох програма потрібно поміняти код. 

Якщо перевага надавалася старішій версії, команда додавання пакета дозволяє додавати номери версій для певного пакета.

```
    dotnet add package -h
    dotnet add package CarLibrary -v 1.0.3
```

# Публікація консольних застосунків

Тепер, коли у вас є ваш застосунок CSharpCarClient (і пов'язана з ним збірка CarLibrary), як ви можете передати його своїм користувачам?

Пакування вашої програми та пов'язаних з нею залежностей називається публікацією. Для публікації програм .NET Framework було потрібно встановити платформу на цільовому комп'ютері, а потім для запуску програми на іншому комп'ютері потрібно було просто скопіювати виконуваний файл програми та пов'язані з ним файли.
Як і слід було очікувати, .NET-додатки також можна публікувати подібним чином, що називається розгортанням, залежним від фреймворку. Однак, .NET-додатки також можна публікувати як автономні програми, які взагалі не потребують встановлення .NET.
Під час публікації програм як автономні, необхідно вказати цільовий ідентифікатор середовища виконання (RID) у файлі проекту або за допомогою параметрів командного рядка. Ідентифікатор середовища виконання використовується для пакування вашої програми для певної операційної системи. Повний список доступних ідентифікаторів середовища виконання (RID) див. за запитом ".NET RID Catalog" 

Програми можна публікувати безпосередньо з Visual Studio або за допомогою інтерфейсу командного рядка .NET. Команда для CLI — dotnet publish. Щоб переглянути всі параметри, використовуйте dotnet publish -h. У таблиці наведено поширені параметри, що використовуються під час публікації з командного рядка.

Деякі варіанти публікації застосунків

|Опції|Сенс у використанні |
|-----|--------------------|
| --use-current-runtime|Використовувати поточне середовище виконання як цільове середовище виконання. |
|-o, --output <OUTPUT_DIR>|Вихідний каталог для розміщення опублікованих артефактів.|
|--self-contained|Опублікуйте середовище виконання .NET разом із вашою програмою, щоб середовище виконання не потрібно було встановлювати на цільовому комп’ютері.|
|--no-self-contained|Опублікуйте свою програму як програму, залежну від фреймворку, без середовища виконання .NET. Для запуску вашої програми має бути встановлено підтримуване середовище виконання .NET.|
|-r <RUNTIME_IDENTIFIER>--runtime <RUNTIME_IDENTIFIER>|Цільове середовище виконання для публікації. Використовується під час створення автономного розгортання. За замовчуванням публікується застосунок, залежний від фреймворку.|
|-c debug | release--configuration debug | release|Конфігурація для публікації. Для більшості проектів за замовчуванням використовується debug.|
|-v, --verbosity <d|detailed|diag|diagnostic|m|minimal|n|normal|q|quiet>|Встановіть рівень деталізації MSBuild. Допустимі значення: q/тихий, m/мінімальний, n/нормальний, d/деталізований та diag/діагностичний.|

## Публікація програм, залежних від фреймворку

Якщо ідентифікатор середовища виконання не вказано, для команди dotnet publish використовується розгортання, залежне від фреймворку, за замовчуванням. Щоб упакувати вашу програму та необхідні файли, все, що вам потрібно виконати за допомогою CLI, це таку команду:

```
dotnet publish
```
    Для проектів NET 8.0 і вище значення за замовчуванням — «Release», а для старіших проектів — «Debug».
 

Це розміщує вашу програму та її допоміжні файли (загалом шість файлів) у каталозі CSharpCarClient\bin\Release\netX.0\publish\ . Переглядаючи файли, додані до цього каталогу, ви бачите два файли *.dll (CarLibrary.dll та CSharpCarClient.dll), які містять весь код програми. Нагадуємо, що файл CSharpCarClient.exe – це упакована версія dotnet.exe, налаштована для запуску CSharpCarClient.dll. Файл CSharpCarClient.deps.json містить список усіх залежностей для програми, а файл CSharpCarClient.runtimeconfig.json визначає цільовий фреймворк (netX.0) та його версію. Останній файл – це файл налагодження для CSharpCarClient.

## Публікація автономних застосунків

Як і розгортання, залежні від фреймворку, автономні розгортання включають весь код вашої програми та посилання на збірки, а також файли середовища виконання .NET, необхідні вашій програмі. Щоб опублікувати свою програму як автономне розгортання, потрібно включити ідентифікатор середовища виконання до команди (або до файлу проекту). Введіть наступну команду CLI, яка розміщує вивід у папці з назвою selfcontained.

```
dotnet publish --self-contained -r win-x64 -o selfcontained
```
Це розміщує вашу програму та її допоміжні файли (загалом 226 файлів) у каталозі selfcontained. Якщо ви скопіювали ці файли на інший комп’ютер, який відповідає ідентифікатору середовища виконання, ви можете запустити програму, навіть якщо середовище виконання .NET не встановлено.

## Публікація автономних програм як єдиного файлу

У більшості випадків розгортання 226 файлів ймовірно, не є найефективнішим способом представити вашу програму користувачам. Існує можливість публікувати ваш застосунок та кросплатформні файли середовища виконання в одному файлі. Цей процес усуває необхідність існування власних бібліотек поза межами одного EXE-файлу. Наведена нижче команда створює автономний пакет розгортання з одного файлу для 64-розрядних операційних систем Windows і розміщує отримані файли в папці з назвою singlefile.

```
dotnet publish -r win-x64 -c release -o singlefile --self-contained -p:PublishSingleFile=true
```
Переглядаючи створені файли, ви знайдете один виконуваний файл (CSharpCarClient.exe) та файл налагодження (CSharpCarClient.pdb). Хоча попередній процес публікації створював велику кількість менших файлів, версія CSharpCarClient.exe з одним файлом займає 60 МБ. Створення публікації в одному файлі призвело до упакування всіх 226 файлів в один новий файл. Те, що було компенсовано зменшенням кількості файлів, було обміняно на збільшення їх розміру.
Щоб включити файл символів налагодження в один файл (щоб дійсно зробити його одним файлом), оновіть свою команду до наступного:

```
dotnet publish -r win-x64 -c release -o singlefile -p:PublishSingleFile=true -p:DebugType=embedde
```

Тепер у вас є один файл, який містить усе, але він все ще досить великий. Один із варіантів, який може допомогти з розміром файлу, – це стиснення. Вивід можна стиснути для економії місця, але це, найімовірніше, ще більше вплине на час запуску вашої програми. Щоб увімкнути стиснення, скористайтеся такою командою (всі в одному рядку):

```
dotnet publish -c release -r win-x64 -o singlefilecompressed -p:PublishSingleFile=true -p:DebugType=embedded  -p:EnableCompressionInSingleFile=true
```
Ви можете обрізати дані під час процесу публікації. Процес обрізання файлів визначає, що можна видалити з середовища виконання, залежно від того, що використовує ваша програма. Процес обрізання не лише шукає збірки, які можна видалити; він також шукає невикористовувані члени. Використовуйте таку команду, щоб обрізати вивід з одного файлу (все в одному рядку):

```
dotnet publish -c release -r win-x64 -o singlefilecompressedandtrimmed -p:PublishSingleFile=true -p:DebugType=embedded  -p:EnableCompressionInSingleFile=true -p:PublishTrimmed=true
```
Останнім кроком у цьому процесі є публікація вашого застосунку у стані, готовому до запуску.Це може покращити час запуску, оскільки частина JIT-компіляції виконується заздалегідь (ahead of time AOT), під час процесу публікації.

```
dotnet publish -c release -r win-x64 -o singlefilefinal -p:PublishSingleFile=true -p:DebugType=embedded  -p:EnableCompressionInSingleFile=true -p:PublishTrimmed=true -p:PublishReadyToRun=true
```
Кінцевий розмір нашої програми становить 11 МБ, що значно менше за 60 МБ, з якими ми починали.

Насамкінець, усі ці параметри можна налаштувати у файлі проєкту для вашої програми, ось так:

```xml
<PropertyGroup>
  //...
  <PublishSingleFile>true</PublishSingleFile>
  <SelfContained>true</SelfContained>
  <RuntimeIdentifier>win-x64</RuntimeIdentifier>
  <PublishTrimmed>true</PublishTrimmed>
  <DebugType>embedded</DebugType>
  <EnableCompressionInSinglefile>true</EnableCompressionInSinglefile>
  <PublishReadyToRun>true</PublishReadyToRun>
</PropertyGroup>
```
З урахуванням цих значень, встановлених у файлі проекту, командний рядок стає значно коротшим:

```
dotnet publish -o singlefile
```

## Як .NET знаходить збірки

До цього моменту в цій книзі всі створені вами збірки були безпосередньо пов'язані (за винятком щойно завершеного прикладу NuGet). Ви додали або посилання на проект, або пряме посилання між проектами. У цих випадках (а також у прикладі NuGet) залежна збірка копіювалася безпосередньо в цільовий каталог клієнтської програми. Знаходження залежної збірки не є проблемою, оскільки вона знаходиться на диску поруч із програмою, яка її потребує. 
А як щодо .NET Framework? Як вони знаходяться? Попередні версії .NET встановлювали файли framework у глобальний кеш збірок (GAC), і всі програми .NET Framework знали, як знаходити ці файли.
Однак, GAC запобігає можливості паралельного використання в .NET Core, тому немає єдиного репозиторію файлів середовища виконання та фреймворку. Натомість файли, що складають фреймворк, встановлюються разом у C:\Program Files\dotnet (у Windows), розділені за версіями. На основі версії програми (як зазначено у файлі .csproj), необхідні файли середовища виконання та фреймворку завантажуються для програми з каталогу зазначеної версії. Зокрема, коли запускається версія середовища виконання, хост середовища виконання надає набір шляхів зондування, які він використовуватиме для пошуку залежностей програми. Існує п'ять властивостей зондування (кожна з них необов'язкова), як зазначено в таблиці.

Властивості зондування застосунку

|Опція|Використання|
|-----|------------|
|TRUSTED_PLATFORM_ASSEMBLIES|Список шляхів до файлів збірок платформи та програми|
|PLATFORM_RESOURCE_ROOTS|Список шляхів до каталогів для пошуку збірок ресурсів|
|NATIVE_DLL_SEARCH_DIRECTORIES|Список шляхів до каталогів для пошуку некерованих (нативних) бібліотек|
|APP_PATHS|Список шляхів до каталогів для пошуку керованих збірок|
|APP_NI_PATHS|Список шляхів до каталогів для пошуку власних образів керованих збірок|

Щоб переглянути шляхи за замовчуванням для них, створіть нову консольну програму .NET з назвою WorkWithProbingPaths.

```cs
Console.WriteLine($"TRUSTED_PLATFORM_ASSEMBLIES: ");
//Use ':' on non-Windows platforms
var list = AppContext.GetData("TRUSTED_PLATFORM_ASSEMBLIES").ToString().Split(';');
foreach (var dir in list.Where(x => !x.StartsWith(@"C:\Program Files")))
{
    Console.WriteLine(dir);
}
Console.WriteLine();
Console.WriteLine($"PLATFORM_RESOURCE_ROOTS: {AppContext.GetData("PLATFORM_RESOURCE_ROOTS")}");
Console.WriteLine($"NATIVE_DLL_SEARCH_DIRECTORIES: {AppContext.GetData("NATIVE_DLL_SEARCH_DIRECTORIES")}");
Console.WriteLine($"APP_PATHS: {AppContext.GetData("APP_PATHS")}");
Console.WriteLine($"APP_NI_PATHS: {AppContext.GetData("APP_NI_PATHS")}");

```
```
TRUSTED_PLATFORM_ASSEMBLIES:
D:\MyWork\...\WorkWithProbingPaths\bin\Debug\net9.0\WorkWithProbingPaths.dll

PLATFORM_RESOURCE_ROOTS:
NATIVE_DLL_SEARCH_DIRECTORIES: C:\Program Files\dotnet\shared\Microsoft.NETCore.App\9.0.12\;
APP_PATHS:
APP_NI_PATHS:
```
Коли ви запустите цю програму, ви побачите, що більшість значень надходять зі змінної TRUSTED_PLATFORM_ASSEMBLIES. Окрім збірки, створеної для цього проєкту в цільовому каталозі, ви побачите список бібліотек базових класів з поточного каталогу середовища виконання, C:\Program Files\dotnet\shared\Microsoft.NETCore.App\X.X.X. 
Кожен із файлів, на які безпосередньо посилається ваша програма, додається до списку, а також будь-які файли середовища виконання, необхідні для вашої програми. Список бібліотек середовища виконання заповнюється одним або кількома файлами *.deps.json, які завантажуються разом із середовищем виконання .NET. У каталозі встановлення є кілька файлів для SDK (використовується для збірки програмного забезпечення) та середовища виконання (використовується для запуску програмного забезпечення). У нашому простому прикладі єдиним використаним файлом є Microsoft.NETCore.App.deps.json.
Зі зростанням складності вашої програми збільшуватиметься і список файлів у TRUSTED_PLATFORM_ASSEMBLIES. Наприклад, якщо додати посилання на пакет Microsoft.EntityFrameworkCore, список необхідних збірок зросте. Щоб продемонструвати це, введіть таку команду в консолі менеджера пакетів (у тому ж каталозі, що й файл *.csproj):

```
dotnet add package Microsoft.EntityFrameworkCore -v ?.0.?
```
Після додавання пакета перезапустіть програму та зверніть увагу, скільки ще файлів з'явилося у списку. Навіть якщо ви додали лише одне нове посилання, пакет Microsoft.EntityFrameworkCore має свої залежності, які додаються до списку необхідних файлів.

