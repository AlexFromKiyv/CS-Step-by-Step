# Простори імен

# Визначення користувацьких просторів імен

Перш ніж заглиблюватися в аспекти розгортання та налаштування бібліотеки, першим завданням є вивчення деталей упаковки ваших користувацьких типів у простори імен .NET. До цього моменту в тексті ви створювали невеликі тестові програми, які використовують існуючі простори імен у всесвіті .NET (зокрема, System). Однак, під час створення більших програм з багатьма типами може бути корисним групувати пов'язані типи у власні простори імен. У C# це досягається за допомогою ключового слова namespace. Явне визначення користувацьких просторів імен ще важливіше під час створення спільних збірок, оскільки іншим розробникам потрібно буде посилатися на бібліотеку та імпортувати ваші користувацькі простори імен, щоб використовувати ваші типи. Користувацькі простори імен також запобігають колізіям імен, відокремлюючи ваші користувацькі класи від інших користувацьких класів, які можуть мати таку саму назву.

Щоб дослідити проблеми безпосередньо, почніть зі створення нового проекту консольної програми .NET з назвою CustomNamespaces. Тепер припустимо, що ви розробляєте колекцію геометричних класів з назвами Square, Circle та Hexagon. З огляду на їхню схожість, ви хочете згрупувати їх в унікальний простір імен під назвою CustomNamespaces.MyShapes у збірці CustomNamespaces.exe.

    Рекомендації Хоча ви можете використовувати будь-яке ім’я для своїх просторів імен, правила іменування зазвичай подібні до наступного: НазваКомпанії.НазваПродукту.НазваЗбірки.Шлях.

Хоча компілятор C# не має проблем з одним файлом коду C#, що містить кілька типів, це може бути проблематично під час роботи в команді. Якщо ви працюєте над класом Circle, а вашому колезі потрібно працювати над класом Hexagon, вам доведеться по черзі працювати в монолітному файлі або зіткнутися зі складними для вирішення (ну, принаймні, трудомісткими) конфліктами злиття.
Кращий підхід полягає в тому, щоб розмістити кожен клас в окремому файлі з визначенням простору імен. Щоб переконатися, що кожен тип упаковано в одну логічну групу, просто оберніть задані визначення класів в одну й ту саму область видимості простору імен.

У наступному прикладі використовується синтаксис простору імен, що був до версії C# 10, де кожне оголошення простору імен обгортало свій вміст відкриваючою та закриваючою фігурними дужками, ось так:

```cs
// Circle.cs
namespace CustomNamespaces.MyShapes
{
  // Circle class
  public class Circle { /* Interesting methods... */ }
}
// Hexagon.cs
namespace CustomNamespaces.MyShapes
{
  // Hexagon class
  public class Hexagon { /* More interesting methods... */ }
}
// Square.cs
namespace CustomNamespaces.MyShapes
{
  // Square class
  public class Square { /* Even more interesting methods...*/}
}
```
Одним із оновлень у C# 10 є додавання просторів імен, що обмежені файловою областю видимості. Це усуває необхідність використання фігурних дужок, що відкривають та закривають вміст. Просто оголосіть простір імен, і все, що йде після цього оголошення простору імен, буде включено до простору імен. Наведений нижче приклад коду дає той самий результат, що й у прикладі, але з просторами імен, що обгортають їхній вміст:

```cs
// Circle.cs
namespace CustomNamespaces.MyShapes;
// Circle class
public class Circle { /* Interesting methods... */ }
// Hexagon.cs
namespace CustomNamespaces.MyShapes;
// Hexagon class
public class Hexagon { /* More interesting methods... */ }
// Square.cs
namespace CustomNamespaces.MyShapes;
// Square class
public class Square { /* Even more interesting methods...*/}
```

Зверніть увагу, як простір імен CustomNamespaces.MyShapes діє як концептуальний «контейнер» цих класів. Коли інший простір імен (наприклад, CustomNamespaces) хоче використовувати типи в окремому просторі імен, використовується ключове слово using, так само, як і під час використання просторів імен бібліотек базових класів .NET, наступним чином:

```cs

//Example1
// Make use of types defined the MyShapes namespace.
using CustomNamespaces.MyShapes;
void Example1()
{
    Hexagon h = new Hexagon();
    Circle c = new Circle();
    Square s = new Square();
}
```
У цьому прикладі припущення полягає в тому, що файли C#, які визначають простір імен CustomNamespaces.MyShapes, є частиною одного проекту консольної програми; іншими словами, всі файли компілюються в одну збірку. Якщо ви визначили простір імен CustomNamespaces.MyShapes у зовнішній збірці, вам також потрібно буде додати посилання на цю бібліотеку, перш ніж ви зможете успішно скомпілювати. У цьому розділі ви дізнаєтеся про всі деталі створення програм, що використовують зовнішні бібліотеки.

## Вирішення конфліктів імен за допомогою повністю кваліфікованих імен

Технічно кажучи, вам не потрібно використовувати ключове слово using у C# під час звернення до типів, визначених у зовнішніх просторах імен. Ви можете використовувати повне ім'я типу, яке є ім'ям типу з префіксом, що визначає простір імен. Ось приклад:

```cs
//Example2

void Example2()
{
    // Note we are not importing CustomNamespaces.MyShapes anymore!
    CustomNamespaces.MyShapes.Hexagon h = new CustomNamespaces.MyShapes.Hexagon();
    CustomNamespaces.MyShapes.Circle c = new CustomNamespaces.MyShapes.Circle();
    CustomNamespaces.MyShapes.Square s = new CustomNamespaces.MyShapes.Square();
}
```

Зазвичай немає потреби використовувати повне ім'я. Це не лише вимагає більшої кількості натискань клавіш, але й не впливає на розмір коду чи швидкість виконання. Фактично, у CIL-коді типи завжди визначаються з повним ім'ям. У цьому світлі ключове слово using у C# просто економить час на введення тексту. Однак, повні імена можуть бути корисними (а іноді й необхідними), щоб уникнути потенційних конфліктів імен під час використання кількох просторів імен, що містять однаково названі типи. Припустимо, у вас є новий простір імен під назвою CustomNamespaces.My3DShapes, який визначає такі три класи, здатні відображати фігуру у приголомшливому 3D:

```cs
// Another shape-centric namespace.
//Circle3D.cs
namespace CustomNamespaces.My3DShapes;
// 3D Circle class.
public class Circle { }
//Hexagon3D.cs
namespace CustomNamespaces.My3DShapes;
// 3D Hexagon class.
public class Hexagon { }
//Square3D.cs
namespace CustomNamespaces.My3DShapes;
// 3D Square class.
public class Square { }
```
Якщо ви оновите оператори верхнього рівня, як показано далі, ви отримаєте кілька помилок під час компіляції, оскільки обидва простори імен визначають класи з однаковими іменами:

```cs
// Example3
// Ambiguities abound!
using CustomNamespaces.MyShapes;
using CustomNamespaces.My3DShapes;
void Example3()
{
    // Which namespace do I reference?
    Hexagon h = new Hexagon(); // Compiler error!
    Circle c = new Circle();   // Compiler error!
    Square s = new Square();   // Compiler error!
}
```
Неоднозначність можна вирішити, використовуючи повне ім'я типу, ось так:

```cs
void Example3()
{
    //// Which namespace do I reference?
    //Hexagon h = new Hexagon(); // Compiler error!
    //Circle c = new Circle();   // Compiler error!
    //Square s = new Square();   // Compiler error!

    // We have now resolved the ambiguity.
    CustomNamespaces.My3DShapes.Hexagon h = new CustomNamespaces.My3DShapes.Hexagon();
    CustomNamespaces.My3DShapes.Circle c = new CustomNamespaces.My3DShapes.Circle();
    CustomNamespaces.MyShapes.Square s = new CustomNamespaces.MyShapes.Square();
}
```

## Вирішення конфліктів імен за допомогою псевдонімів

Ключове слово using у C# також дозволяє створювати псевдонім для повного імені типу. Коли ви це робите, ви визначаєте токен, який замінює повне ім'я типу під час компіляції. Визначення псевдонімів надає другий спосіб вирішення конфліктів імен. Ось приклад:

```cs
// Example4
using CustomNamespaces.MyShapes;
using CustomNamespaces.My3DShapes;
using The3DHexagon = CustomNamespaces.My3DShapes.Hexagon;
void Example4()
{
    // This is really creating a My3DShapes.Hexagon class.
    The3DHexagon h2 = new The3DHexagon();
}
```
Існує ще один (більш поширений) синтаксис using, який дозволяє створювати псевдонім для простору імен замість типу. Наприклад, ви можете створити псевдонім простору імен CustomNamespaces.My3DShapes та створити екземпляр 3D Hexagon наступним чином:

```cs
//Example5
using CustomNamespaces.MyShapes;
using CustomNamespaces.My3DShapes;
using TreeDShapes = CustomNamespaces.My3DShapes;

void Example5()
{
    TreeDShapes.Hexagon h = new();
}
```

    Майте на увазі, що надмірне використання псевдонімів C# для типів може призвести до заплутаної кодової бази. Якщо інші програмісти у вашій команді не знають про ваші власні псевдоніми для типів, їм може бути важко знайти справжні типи в проекті(-ах).

## Створення вкладених просторів імен

Під час організації типів ви можете вільно визначати простори імен всередині інших просторів імен. Бібліотеки базових класів роблять це в багатьох місцях, щоб забезпечити глибші рівні організації типів. Наприклад, простір імен IO вкладено в System, що призводить до System.IO. Фактично, ви вже створили вкладені простори імен у попередньому прикладі.Багатокомпонентні простори імен (CustomNamespaces.MyShapes та CustomNamespaces.My3DShapes) вкладено в кореневий простір імен CustomNamespaces.

Як ви вже бачили в цій книзі, шаблони проектів .NET додають початковий код для консольних застосунків у файл з назвою Program.cs. Цей файл містить простір імен, названий на честь проекту, та один клас Program. Цей базовий простір імен називається кореневим простором імен. У нашому поточному прикладі кореневий простір імен, створений шаблоном .NET, — це CustomNamespaces. Щоб вкладати простори імен MyShapes та My3DShapes у кореневий простір імен, існує три варіанти. Перший — просто вкладати ключове слово namespace, ось так (використовуючи синтаксис, попередній за C# 10):

```cs
namespace CustomNamespaces
{
  namespace MyShapes
  {
    // Circle class
    public class Circle
    {
      /* Interesting methods... */
    }
  }
}
```
Другий варіант, використовуючи C# 10 (і пізніші версії), використовує простір імен у файловій області, а потім простір імен у блочній області для вкладеного простору імен:

```cs
namespace CustomNamespaces;
namespace MyShapes
{
  // Circle class
  public class Circle
  {
    /* Interesting methods... */
  }
}
```
Третій варіант (і частіше використовуваний) — це використання «крапкової нотації» у визначенні простору імен, як ми це зробили в попередніх прикладах класів:

```cs
namespace CustomNamespaces.MyShapes;
// Circle class
public class Circle
{
  /* Interesting methods... */
}
```
Простори імен не обов'язково повинні безпосередньо містити будь-які типи. Це дозволяє розробникам використовувати простори імен для забезпечення додаткового рівня області видимості.

    Рекомендації. Поширеною практикою є групування файлів у просторі імен за каталогами. Розташування файлу в структурі каталогів не впливає на простори імен. Однак, це робить структуру простору імен зрозумілішою для інших розробників. Тому багато розробників та інструментів для лінтування коду очікують, що простори імен відповідатимуть структурам папок.

## Зміна кореневого простору імен за допомогою Visual Studio

Як згадувалося, під час створення нового проекту C# за допомогою Visual Studio (або .NET CLI) назва кореневого простору імен вашої програми буде ідентичною назві проекту. З цього моменту, коли ви використовуєте Visual Studio для вставки нових файлів коду за допомогою меню Project ➤ Add New Item, типи автоматично будуть обгорнуті в кореневий простір імен і до них буде додано шлях до каталогу. Якщо ви хочете змінити назву кореневого простору імен, просто перейдіть до опції «Default namespace» за допомогою вкладки «Application/General» у вікні властивостей проекту.

```
$(MSBuildProjectName.Replace(" ", "_"))
```

    На сторінках властивостей Visual Studio кореневий простір імен все ще посилається на простір імен за замовчуванням. Далі ви побачите, чому я називаю його кореневим простором імен.

## Зміна кореневого простору імен за допомогою файлу проекту

Ви також можете налаштувати кореневий простір імен, оновивши файл проекту (*.csproj). У проектах .NET редагування файлу проекту у Visual Studio так само просте, як подвійне клацання файлу проекту в Solution Explorer (або клацання правою кнопкою миші файлу проекту в Solution Explorer та вибір опції «Edit project file»). Після відкриття файлу оновіть головну групу властивостей (PropertyGroup), додавши вузол RootNamespace, ось так:

```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <RootNamespace>CustomNamespaces2</RootNamespace>
  </PropertyGroup>

</Project>
```
Тепер, коли ви ознайомилися з деякими деталями щодо пакування користувацьких типів у добре організовані простори імен, давайте коротко розглянемо переваги та формат збірки .NET. Після цього ви заглибитеся в деталі створення, розгортання та налаштування власних бібліотек класів.