# Ресурси WPF, анімація, стилі та шаблони

Цей розділ знайомить вас із трьома важливими (і взаємопов’язаними) темами, які поглиблять ваше розуміння API Windows Presentation Foundation (WPF). Перше, що потрібно зробити – це дізнатися про роль логічних ресурсів. Як ви побачите, система логічного ресурсу (також відомого як ресурс об’єкта) — це спосіб іменування та посилання на часто використовувані об’єкти в програмі WPF. Хоча логічні ресурси часто створюються в XAML, вони також можуть бути визначені в процедурному коді.
Далі ви дізнаєтеся, як визначати, виконувати та контролювати послідовність анімації. Незважаючи на те, що ви думаєте, анімація WPF не обмежується відеоіграми чи мультимедійними програмами. У API WPF анімація може бути такою ж тонкою, як створення такої, що кнопка світиться, коли вона отримує фокус, або збільшення розміру вибраного рядка в DataGrid. Розуміння анімації є ключовим аспектом створення користувацьких шаблонів елементів керування (як ви побачите далі в цьому розділі).
Потім ви дослідите роль стилів і шаблонів WPF. Подібно до веб-сторінки, яка використовує CSS або механізм тем ASP.NET, програма WPF може визначити загальний вигляд для набору елементів керування. Ви можете визначити ці стилі в розмітці та зберегти їх як об’єктні ресурси для подальшого використання, а також ви можете застосовувати їх динамічно під час виконання. Останній приклад навчить вас створювати власні шаблони керування.

# Розуміння системи ресурсів WPF

Ваше перше завдання — вивчити тему вбудовування та доступу до ресурсів програми. WPF підтримує два різновиди ресурсів. Перший — це двійковий ресурс, і ця категорія зазвичай включає елементи, які більшість програмістів вважають ресурсами в традиційному розумінні (вбудовані файли зображень або звукові кліпи, значки, які використовуються програмою тощо).
Друга різновид, яка називається ресурсами об’єкта або логічними ресурсами, представляє іменований об’єкт .NET, який можна запакувати та повторно використовувати у всій програмі.Хоча будь-який об’єкт .NET можна запакувати як об’єктний ресурс, логічні ресурси особливо корисні під час роботи з графічними даними будь-якого типу, враховуючи, що ви можете визначити типові графічні примітиви (пензлі, ручки, анімацію тощо) і посилатися на них, коли потрібно.

## Робота з бінарними ресурсами

Перш ніж перейти до теми об’єктних ресурсів, давайте швидко розглянемо, як запакувати бінарні ресурси, такі як іконки або файли зображень (наприклад, логотипи компанії або зображення для анімації) у ваші програми. Створіть нову програму WPF під назвою BinaryResourcesApp. Оновіть розмітку для вашого початкового вікна, щоб обробляти подію Window Loaded і використовувати DockPanel як корінь макета, наприклад:

```xml
  <Window x:Class="BinaryResourcesApp.MainWindow"
        ...
        Title="Binary Resources" Height="450" Width="800" Loaded="Window_Loaded">
    <DockPanel LastChildFill="True">

    </DockPanel>
</Window>

```
Тепер, припустімо, вашій програмі потрібно відобразити один із трьох файлів зображень усередині частини вікна на основі введення користувача. Елемент керування зображенням WPF можна використовувати для відображення не лише типового файлу зображення (*.bmp, *.gif, *.ico, *.jpg, *.png, *.wdp або *.tiff), але й даних у DrawingImage. Ви можете створити інтерфейс користувача для свого вікна, який підтримує DockPanel, що містить просту панель інструментів із кнопками Next та Previous. Під цією панеллю інструментів ви можете розмістити елемент керування Image, який наразі не має значення властивості Source, наприклад:

```xml
    <DockPanel LastChildFill="True">
        <ToolBar Height="60" Name="picturePickerToolbar" DockPanel.Dock="Top">
            <Button x:Name="btnPreviousImage" Height="40" Width="100" BorderBrush="Black"
                    Margin="5" Content="Previous" Click="btnPreviousImage_Click"/>
            <Button x:Name="btnNextImage" Height="40" Width="100" BorderBrush="Black"
                    Margin="5" Content="Next" Click="btnNextImage_Click"/>
        </ToolBar>

        <!-- We will fill this Image in code. -->
        <Border BorderThickness="2" BorderBrush="Green">
            <Image x:Name="imageHolder" Stretch="Fill" />
        </Border>

    </DockPanel>
```
Далі додайте такі пусті обробники подій:

```cs
        private void Window_Loaded(object sender, RoutedEventArgs e)
        {

        }

        private void btnPreviousImage_Click(object sender, RoutedEventArgs e)
        {

        }

        private void btnNextImage_Click(object sender, RoutedEventArgs e)
        {

        }
```
Коли вікно завантажується, зображення буде додано до колекції, яку циклічно переміщатимуть кнопки. Тепер, коли структура програми створена, давайте розглянемо різні варіанти її реалізації.

### Включення незакріплених файлів ресурсів у проект

Одним із варіантів є надсилання файлів зображень у вигляді набору незакріплених файлів у підкаталозі шляху встановлення програми. Почніть із додавання нової папки (з назвою Images) до вашого проекту. У цю папку додайте кілька зображень, клацнувши правою кнопкою миші та вибравши Add ➤ Existing Item. Ви можете додати власні файли зображень або використати три файли зображень Deer.jpg, Dogs.jpg і Welcome.jpg із завантажуваного коду.

### Налаштування вільних ресурсів

Щоб скопіювати вміст папки \Images до папки \bin\Debug під час створення проекту, почніть із вибору всіх зображень у Solution Explorer. Тепер, коли ці зображення все ще вибрано, клацніть правою кнопкою миші та виберіть Properties. Установіть властивість Build Action на Content, а для властивості Copy to Output Directory встановіть значення Установіть властивість Build Action на Content, а для властивості Copy to Output Directory встановіть значення Copy always.
Ви також можете вибрати Copy if Newer, що заощадить ваш час, якщо ви створюєте великі проекти з великою кількістю вмісту. Для цього прикладу працює Copy always.
Якщо ви build свій проект, тепер ви можете натиснути кнопку Show All Files в Solution Explorer і переглянути скопійовану папку Images в каталозі \bin\Debug (може знадобитися натиснути кнопку Refresh).

### Програмне завантаження зображення

WPF надає клас під назвою BitmapImage, який є частиною простору імен System.Windows.Media.Imaging. Цей клас дозволяє завантажувати дані з файлу зображення, розташування якого представлено об’єктом System.Uri. Додайте List<BitmapImage> для зберігання зображень, а також int для збереження індексу зображення, яке зараз відображається.

```cs
    public partial class MainWindow : Window
    {
        // A List of BitmapImage files.
        List<BitmapImage> _images = new List<BitmapImage>();

        // Current position in the list.
        private int _currImage = 0;
        
        //...
    }
```
У події Loaded вашого вікна заповніть список зображень, а потім установіть для джерела керування зображенням перше зображення у списку.

```cs
        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            try
            {
                string path = Environment.CurrentDirectory;
                //Load these images from disk when the window loads.
                _images.Add(new BitmapImage(new Uri($@"{path}\Images\Deer.jpg")));
                _images.Add(new BitmapImage(new Uri($@"{path}\Images\Dogs.jpg")));
                _images.Add(new BitmapImage(new Uri($@"{path}\Images\Welcome.jpg")));

                // Show first image in the List.
                imageHolder.Source = _images[_currImage];
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.Message);
            }
        }
```
Далі реалізуйте обробники для циклічного перегляду зображень. Якщо користувач дійде до кінця списку, почніть його на початок і навпаки.

```cs
        private void btnPreviousImage_Click(object sender, RoutedEventArgs e)
        {
            if (--_currImage < 0)
            {
                _currImage = _images.Count - 1;
            }
            imageHolder.Source = _images[_currImage];
        }

        private void btnNextImage_Click(object sender, RoutedEventArgs e)
        {
            if (++_currImage >= _images.Count)
            {
                _currImage = 0;
            }
            imageHolder.Source = _images[_currImage];
        }
```
На цьому етапі ви можете запустити програму та прогортати кожне зображення.

### Вбудовування ресурсів програми

Якщо ви бажаєте налаштувати файли зображень для компіляції безпосередньо у збірку .NET як двійкові ресурси, виберіть файли зображень у Solution Explorer (у папці \Images, а не в папці \bin\Debug\Images). Змініть властивість Build Action на Resource і встановіть властивість Copy to Output Directory на «Do not copy».
Тепер, використовуючи меню Build Visual Studio, виберіть параметр Clean Solution, щоб видалити поточний вміст \bin\Debug\Images, а потім перебудуйте свій проект. Оновіть Solution Explorer і спостерігайте за відсутністю даних у вашому каталозі \bin\Debug\Images. З поточними параметрами збірки ваші графічні дані більше не копіюються до вихідної папки, а тепер вбудовані в саму збірку. Це гарантує наявність ресурсів, але також збільшує розмір вашої скомпільованої збірки.
Вам потрібно змінити код, щоб завантажити ці зображення у свій список, витягнувши їх зі скомпільованої збірки.

```cs
                // Extract from the assembly and then load images
                _images.Add(new BitmapImage(new Uri(@"/Images/Deer.jpg", UriKind.Relative)));
                _images.Add(new BitmapImage(new Uri(@"/Images/Dogs.jpg", UriKind.Relative)));
                _images.Add(new BitmapImage(new Uri(@"/Images/Welcome.jpg", UriKind.Relative)));
```

У цьому випадку вам більше не потрібно визначати шлях інсталяції, і ви можете просто перерахувати ресурси за іменами, що враховує назву вихідного підкаталогу. Також зауважте, коли ви створюєте свої об’єкти Uri, ви вказуєте значення UriKind як Relative. На даний момент ваш виконуваний файл є автономною сутністю, яку можна запускати з будь-якого місця на машині, оскільки всі скомпільовані дані знаходяться в двійковому файлі.

## Робота з об'єктними (логічними) ресурсами

Коли ви створюєте програму WPF, типово визначати аннотацію XAML для використання в кількох місцях у вікні або, можливо, у кількох вікнах чи проектах. Наприклад, припустимо, що ви створили ідеальний лінійний градієнтний пензель, який складається з десяти рядків розмітки. Тепер ви хочете використовувати цей пензель як колір фону для кожного елемента керування Button у проекті (який складається з восьми вікон), щоб загалом було 16 елементів керування Button.
Найгірше, що ви можете зробити, це скопіювати та вставити XAML у кожен елемент керування. Зрозуміло, що підтримувати це було б кошмаром, оскільки вам потрібно було б вносити численні зміни кожного разу, коли ви хотіли б налаштувати вигляд і відчуття пензля.
На щастя, об’єктні ресурси дозволяють визначити blob XAML, дати йому ім’я та зберегти його у відповідному словнику для подальшого використання. Подібно до бінарного ресурсу, об’єктні ресурси часто компілюються в збірку, яка їх вимагає. Однак для цього не потрібно возитися з властивістю Build Action. Якщо ви розмістите свій XAML у правильному місці, компілятор подбає про все інше.
Робота з об'єктними ресурсами є великою частиною розробки WPF. Як ви побачите, ресурси об’єктів можуть бути набагато складнішими, ніж спеціальний пензель. Ви можете визначити анімацію на основі XAML, 3D-візуалізацію, настроюваний стиль керування, шаблон даних, шаблон керування тощо та запакувати кожен із них як ресурс для повторного використання.

### Роль властивості ресурсів

Як згадувалося, об’єктні ресурси повинні бути розміщені в відповідному об’єкті словника, який буде використовуватися в програмі. У поточному стані кожен нащадок FrameworkElement підтримує властивість Resources. Ця властивість інкапсулює об’єкт ResourceDictionary, який містить визначені ресурси об’єкта. ResourceDictionary може містити будь-який тип елемента, оскільки він працює з типами System.Object і ним можна керувати через XAML або процедурний код. 
У WPF усі елементи керування, Windows, сторінки (використовуються для створення навігаційних програм) і UserControls розширюють FrameworkElement, тому майже всі віджети надають доступ до ResourceDictionary. Крім того, клас Application, не розширюючи FrameworkElement, підтримує властивість Resources з ідентичною назвою для тієї ж мети.

### Визначення загальновіконних ресурсів

Щоб розпочати вивчення ролі об’єктних ресурсів, створіть нову програму WPF під назвою ObjectResourcesApp і змініть початкову сітку на горизонтально вирівняний менеджер макета StackPanel. У цій панелі StackPanel визначте два елементи керування Button ось так (вам справді не потрібно багато, щоб проілюструвати роль ресурсів об’єкта, тому це підійде):

```xml
    <StackPanel Orientation="Horizontal">
        <Button Margin="25" Height="200" Width="200" Content="OK" FontSize="20"/>
        <Button Margin="25" Height="200" Width="200" Content="Cancel" FontSize="20"/>
    </StackPanel>
```
Тепер клацніть кнопку OK і встановіть властивість Background  на спеціальний тип brush за допомогою інтегрованого редактора пензлів. Після того, як ви це зробите, зверніть увагу на те, як пензель вбудовано в область тегів Button, як показано тут:

```xml
            <Button.Background>
                <RadialGradientBrush>
                    <GradientStop Color="#FFC5F4BC" Offset="0" />
                    <GradientStop Color="#FF44C342" Offset="1" />
                    <GradientStop Color="#FF50800C" Offset="0.669" />
                </RadialGradientBrush>
            </Button.Background>
```
Щоб дозволити кнопці Cancel також використовувати цей пензель, вам слід підвищити область дії вашого RadialGradientBrush до словника ресурсів батьківського елемента. Наприклад, якщо ви перемістите його в StackPanel, обидві кнопки зможуть використовувати один пензель, оскільки вони є дочірніми елементами менеджера макета. Ще краще, ви можете запакувати пензель у словник ресурсів самого вікна, щоб вміст вікна міг використовувати його.
Коли вам потрібно визначити ресурс, ви використовуєте синтаксис елемента властивості, щоб встановити властивість Resources власника. Ви також надаєте елементу ресурсу значення x:Key, яке використовуватиметься іншими частинами вікна, коли вони хочуть посилатися на ресурс об’єкта. Майте на увазі, що x:Key і x:Name – це не одне й те саме! Атрибут x:Name дозволяє вам отримати доступ до об’єкта як змінної-члена у вашому файлі коду, тоді як атрибут x:Key дозволяє посилатися на елемент у словнику ресурсу.
Visual Studio дозволяє підняти ресурс до вищого обсягу за допомогою відповідного вікна властивостей. Для цього спочатку визначте властивість, яка містить складний об’єкт, який ви хочете запакувати як ресурс (у цьому прикладі властивість Background). Праворуч від властивості є невеликий квадрат, натиснувши на який, відкривається спливаюче меню. У ньому виберіть параметр «Convert to New Resource».
Вас попросять назвати свій ресурс (myBrush) і вказати, де його розмістити. Для цього прикладу залиште стандартний вибір поточного документа.
Коли ви закінчите, ви побачите, що пензель було переміщено всередину тегу Window.Resources.

```xml
    <Window.Resources>
        <RadialGradientBrush x:Key="MyBrush">
            <GradientStop Color="#FFBCEEF4" Offset="0"/>
            <GradientStop Color="#FF42C3C3" Offset="1"/>
            <GradientStop Color="#FF0C7380" Offset="0.669"/>
        </RadialGradientBrush>
    </Window.Resources>
```
А фон елемента керування Button оновлено для використання нового ресурсу.
```xml
        <Button Background="{DynamicResource MyBrush}" Margin="25" Height="200" Width="200" Content="OK" FontSize="20">
        </Button>
```
Майстер створення ресурсу створює новий ресурс як DynamicResource. Ви дізнаєтеся про DynamicResources пізніше в цьому тексті, а поки що змініть його на StaticResource, наприклад:

```xml
        <Button Background="{StaticResource MyBrush}" Margin="25" Height="200" Width="200" Content="OK" FontSize="20" />
```
Щоб побачити переваги, оновіть властивість Background кнопки Cancel  до того самого StaticResource, і ви зможете побачити повторне використання в дії.

```xml
        <Button Background="{StaticResource MyBrush}" Margin="25" Height="200" Width="200" Content="Cancel" FontSize="20"/>
```

### Розширення розмітки {StaticResource}

Розширення розмітки {StaticResource} застосовує ресурс лише один раз (під час ініціалізації) і залишається «підключеним» до оргігінального об’єкта протягом життя програми. Деякі властивості (наприклад, межі градієнта) буде оновлено, але якщо ви, наприклад, створите новий пензель, елемент керування не буде оновлено. Щоб побачити це в дії, додайте Name та обробник події  Click до кожного елемента керування Button, як показано нижче:

```cs
        private void btnOk_Click(object sender, RoutedEventArgs e)
        {
            // Get the brush and make a change.
            var b = (RadialGradientBrush)Resources["MyBrush"];
            b.GradientStops[1] = new GradientStop(Colors.WhiteSmoke, 0.0);
        }
```

    Ви використовуєте індексатор ресурсів, щоб знайти тут ресурс за назвою. Ви також можете використати метод TryFindResource(), який не викличе помилку виконання;він просто поверне значення null, якщо вказаний ресурс неможливо знайти.

Коли ви запускаєте програму та натискаєте кнопку OK, ви бачите, що градієнти змінюються належним чином. Тепер додайте такий код до обробника події:

```cs
        private void btnCancel_Click(object sender, RoutedEventArgs e)
        {
            // Put a totally new brush into the myBrush slot.
            Resources["MmyBrush"] = new SolidColorBrush(Colors.Red);
        }

```
Запустіть програму ще раз, натисніть кнопку Cancel, і нічого не відбувається.

### Розширення розмітки {DynamicResource}

Також властивість може використовувати розширення розмітки DynamicResource. Щоб побачити різницю, змініть розмітку для кнопки Cancel на таку:

```xml
        <Button x:Name="btnCancel" Background="{DynamicResource MyBrush}" Margin="25" Height="200" Width="200" Content="Cancel" FontSize="20" Click="btnCancel_Click"/>
```
Цього разу, коли ви натискаєте кнопку Cancel, фон для кнопки Cancel змінюється, але фон для кнопки ОК залишається тим самим. Це пов’язано з тим, що розширення розмітки {DynamicResource} може визначити, чи базовий ключовий об’єкт було замінено новим об’єктом. Як ви могли здогадатися, для цього потрібна додаткова інфраструктура середовища виконання, тому вам зазвичай слід використовувати {StaticResource}, якщо ви не знаєте, що у вас є ресурс об’єкта, який буде замінено іншим об’єктом під час виконання, і ви хочете, щоб усі елементи, які використовують цей ресурс, отримували інформацію.

### Ресурси на рівні програми

Якщо у словнику ресурсів вікна є ресурси об’єктів, усі елементи у вікні можуть вільно використовувати його, але інші вікна програми не можуть. Рішення для спільного використання ресурсів у вашій програмі полягає у визначенні об’єктного ресурсу на рівні програми, а не на рівні вікна. У Visual Studio це неможливо автоматизувати, тому просто виріжте поточний об’єкт пензля з області Windows.Resources і розмістіть його в області Application.Resources у файлі App.xaml.
Тепер будь-яке додаткове вікно або елемент керування у вашій програмі може вільно використовувати цей самий пензель. Якщо ви хочете встановити властивість Background для елемента керування, ресурси рівня програми доступні для вибору, як показано на малюнку.

Застосування ресурсів на рівні програми

![Resourse](Resourse.jpg)

Розміщення ресурсів на рівні програми та призначення їх властивості елемента керування заморозить ресурс, запобігаючи зміні значень під час виконання. Ресурс можна клонувати, а клон можна оновлювати.

### Визначення словників об’єднаних ресурсів

Ресурси на рівні додатків досить часто є достатньо хорошими, але вони не допомагають повторно використовувати в проектах. У цьому випадку ви хочете визначити так званий словник об’єднаного ресурсу. Подумайте про це як про бібліотеку класів для ресурсів WPF; це не що інше, як файл XAML, який містить колекцію ресурсів. Один проект може мати скільки завгодно таких файлів (один для пензлів, один для анімації тощо). Додайте за допомогою діалогового вікна Add New Item, яке активується через меню Project файл MyBrushes.xalm. У новому файлі виріжте поточні ресурси в області Application.Resources і перемістіть їх у свій словник, ось так:

```xml
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <RadialGradientBrush x:Key="MyBrush">
        <GradientStop Color="#FFBCEEF4" Offset="0"/>
        <GradientStop Color="#FF42C3C3" Offset="1"/>
        <GradientStop Color="#FF0C7380" Offset="0.669"/>
    </RadialGradientBrush>

</ResourceDictionary>
```
Незважаючи на те, що цей словник ресурсів є частиною вашого проекту, для використання всі словники ресурсів мають бути об’єднані (зазвичай на рівні програми) в існуючий словник ресурсів. Для цього використовуйте такий формат у файлі App.xaml (зауважте, що кілька словників ресурсів можна об’єднати, додавши кілька елементів ResourceDictionary в область ResourceDictionary.MergedDictionaries):

```xml
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <ResourceDictionary Source="MyBrushes.xaml"/>
            </ResourceDictionary.MergedDictionaries>
        </ResourceDictionary>
    </Application.Resources>
```
Проблема цього підходу полягає в тому, що кожен файл ресурсу потрібно додати до кожного проекту, який потребує ресурсів. Кращим підходом для спільного використання ресурсів є визначення бібліотеки класів .NET для спільного використання між проектами, що ви зробите далі.

### Визначення збірки лише для ресурсів

Найпростіший спосіб побудувати збірку, в якій лише ресурси, — почати з проекту WPF User Control Library. Додайте такий проект (під назвою MyBrushesLibrary) до поточного рішення за допомогою пункту меню Add ➤ New Project і додайте до нього посилання на проект із проекту ObjectResourcesApp.
Тепер видаліть файл UserControl1.xaml із проекту. Потім перетягніть файл MyBrushes.xaml у свій проект MyBrushesLibrary і видаліть його з проекту ObjectResourcesApp. 

Скомпілюйте проект бібліотеки керування користувачами. Тепер об’єднайте ці бінарні ресурси в словник ресурсів рівня програми проекту ObjectResourcesApp. Однак для цього потрібен досить дивний синтаксис, показаний тут:

```xml
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <ResourceDictionary Source="/MyBrushesLibrary;Component/MyBrushes.xaml"/>
            </ResourceDictionary.MergedDictionaries>
        </ResourceDictionary>
    </Application.Resources>
```
По-перше, майте на увазі, що цей рядок чутливий до пробілу. Якщо у вас є зайві пробіли навколо крапки з комою або скісної риски, ви створите помилки. Перша частина рядка — це зрозуміла назва зовнішньої бібліотеки (без розширення файлу). Після крапки з комою введіть слово Компонент, а потім назву скомпільованого двійкового ресурсу, який буде ідентичним вихідному словнику ресурсів XAML.
На цьому розгляд системи управління ресурсами WPF завершується. Ви добре використаєте ці методи для більшості (якщо не для всіх) ваших програм. Далі розглянемо інтегрований API анімації Windows Presentation Foundation.

