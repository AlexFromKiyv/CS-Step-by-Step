# Сповіщення, верифікація, команди та MVVM у WPF

У цьому розділі завершиться ваше дослідження моделі програмування WPF, розглянувши можливості, що підтримують патерн Model-View-ViewModel (MVVM). У першому розділі розглядається шаблон Model-View-ViewModel. Далі ви дізнаєтеся про систему сповіщень WPF та її реалізацію шаблону Observable за допомогою моделей Observable та колекцій Observable. Точне відображення поточного стану даних в інтерфейсі користувача автоматично значно покращує взаємодію з користувачем та зменшує обсяг ручного кодування, необхідний у старіших технологіях (таких як WinForms) для досягнення того ж результату.
Спираючись на шаблон Observable, ви розглянете механізми додавання валідації до вашої програми.Валідація є життєво важливою частиною будь-якої програми, яка не лише повідомляє користувачеві про помилку, але й повідомляє йому, що саме не так. Щоб повідомити користувача про помилку, ви також дізнаєтеся, як включити валідацію в розмітку представлення.
Далі ви глибше зануритеся в систему команд WPF та створите власні команди для інкапсуляції логіки програми, так само, як ви робили це з вбудованими командами. Існує кілька переваг створення власних команд, включаючи (але не обмежуючись) можливість повторного використання коду, інкапсуляцію логіки та розділення завдань.
Нарешті, ви об'єднаєте все це разом у зразку MVVM-додатку.

# Вступ до Model-View-ViewModel

Перш ніж заглиблюватися в сповіщення, перевірки та команди в WPF, було б добре зрозуміти кінцеву мету цього розділу, а саме патерн Model-View-ViewModel (MVVM). Похідний від шаблону «Presentation Model» Мартіна Фаулера, MVVM використовує специфічні для XAML можливості, обговорені в цьому розділі, щоб зробити розробку на WPF швидшою та чистішою. ​​Сама назва описує основні компоненти шаблону: модель, вигляд, модель вигляду.

## Модель

Модель – це об’єктне представлення ваших даних. У MVVM моделі концептуально ідентичні моделям з вашого рівня доступу до даних (DAL). Іноді вони належать до одного фізичного класу, але для цього немає жодної вимоги. Читаючи цей розділ, ви дізнаєтеся, як вирішити, чи можете ви використовувати свої моделі DAL, чи потрібно створювати нові. Моделі зазвичай використовують вбудовані (або користувацькі) перевірки за допомогою анотацій даних та інтерфейсу INotifyDataErrorInfo і налаштовуються як спостережувані для зв'язку з системою сповіщень WPF. Ви побачите все це пізніше в цій главі.

## Представлення

Представлення – це інтерфейс користувача програми, і воно розроблено дуже легким. Уявіть собі меню в ресторані з обслуговуванням через автомобіль. Плата відображає пункти меню та ціни, а також має механізм, за допомогою якого користувач може взаємодіяти з серверними системами. Однак, на меню немає жодного вбудованого інтелектуального забезпечення, хіба що це стосується безпосередньо логіки інтерфейсу користувача, наприклад, увімкнення світла, якщо темніє.
Представлення MVVM слід розробляти з урахуванням тих самих цілей. Будь-який інтелектуальний підхід має бути вбудований у застосунок. Єдиний код у файлі коду програмної частини (наприклад, MainWindow.xaml.cs) має бути безпосередньо пов'язаний з маніпулюванням інтерфейсом користувача. Він не повинен базуватися на бізнес-правилах чи чомусь, що потрібно зберігати для майбутнього використання. Хоча це не є головною метою MVVM, добре розроблені MVVM-додатки зазвичай мають дуже мало коду в коді програми.

## Модель представлення

У WPF та інших технологіях XAML модель представлення виконує дві функції.

1. Модель представлення забезпечує єдине місце для всіх даних, необхідних представленню. Це не означає, що модель представлення відповідає за отримання фактичних даних; натомість, це просто транспортний механізм для переміщення даних зі сховища даних до представлення. Зазвичай між представленнями та моделями представлень існує однозначна кореляція, але існують архітектурні відмінності, і ваші результати можуть відрізнятися.
2. Друге завдання — діяти як контролер для представлення. Як і меню, модель перегляду отримує вказівки від користувача та передає ці виклики відповідному коду, щоб переконатися, що виконано правильні дії. Досить часто цей код має форму користувацьких команд.

### Анемічні моделі або анемічні моделі перегляду

На ранніх етапах розвитку WPF, коли розробники ще шукали способи найкращої реалізації шаблону MVVM, точилися значні (а іноді й гарячі) дискусії щодо того, де реалізувати такі елементи, як валідація та шаблон Observable.
Один табір (табір прихильників анемічної моделі) стверджував, що все це має бути в моделі представлення, оскільки додавання цих можливостей до моделі порушує розділення обов'язків. Інший табір (табір прихильників анемічної моделі погляду) стверджував, що все це має бути в моделях, оскільки це зменшує дублювання коду.
Справжня відповідь, звичайно, залежить від ситуації. Коли INotifyPropertyChanged, IDataErrorInfo та INotifyDataErrorInfo реалізовані в класах моделей, це гарантує, що відповідний код близький до цільового коду (як ви побачите в цьому розділі) та реалізується лише один раз для кожної моделі. З огляду на це, бувають випадки, коли класи моделей перегляду потрібно розробляти як самі спостережувані об'єкти. Зрештою, вам потрібно визначити, що має найбільший сенс для вашої програми, не ускладнюючи надмірно код і не жертвуючи перевагами MVVM.

    Для WPF доступні різні фреймворки MVVM, такі як MVVMLite, Caliburn.Micro та Prism (хоча Prism — це набагато більше, ніж просто фреймворк MVVM). У цій главі обговорюється шаблон MVVM та функції WPF, які підтримують реалізацію цього шаблону. Я залишаю це вам – вивчити різні фреймворки та вибрати той, який найкраще відповідає потребам вашого застосунку.

# Система зв'язування сповіщень WPF.

Істотним недоліком системи зв'язування для WinForms є відсутність сповіщень. Якщо дані, представлені у view, оновлюються програмно, інтерфейс користувача також має оновлюватися програмно, щоб вони були синхронізовані. Це призводить до великої кількості викликів Refresh() для елементів керування, зазвичай більше, ніж це абсолютно необхідно для безпеки. Хоча зазвичай включення занадто великої кількості викликів Refresh() не є суттєвою проблемою продуктивності, якщо ви не включите достатньо, це може негативно вплинути на враження користувача.
Система зв'язування, вбудована в програми на основі XAML, виправляє цю проблему, дозволяючи вам підключати ваші об'єкти даних та колекції до системи сповіщень, розробляючи їх як спостережувані об'єкти. Щоразу, коли значення властивості змінюється у спостережуваній моделі або змінюється колекція (наприклад, елементи додаються, видаляються або перевпорядковуються) у спостережуваній колекції, викликається подія (NotifyPropertyChanged або NotifyCollectionChanged). Фреймворк зв'язування автоматично прослуховує ці події та оновлює зв'язані елементи керування, коли вони спрацьовують. Ще краще те, що як розробник ви можете контролювати, які властивості викликають сповіщення. Звучить ідеально, чи не так? Що ж, це не зовсім ідеально. Налаштування цього для спостережуваних моделей може зайняти чимало коду, якщо робити все вручну. На щастя, існує фреймворк з відкритим кодом, який значно спрощує це, як ви скоро побачите.

## Спостережувані (Observable) моделі та колекції

У цьому розділі ви створите застосунок, який використовує спостережувані моделі та колекції. Щоб розпочати, створіть нову WPF-застосунок з назвою WpfNotifications. Застосунок буде формою типу «головний-детальний», що дозволить користувачеві вибрати певний автомобіль за допомогою поля зі списком (ComboBox), а потім деталі цього автомобіля відображатимуться в наступних елементах керування TextBox. Оновіть MainWindow.xaml, замінивши стандартну Grid наступною розміткою:

```xml
    <Grid IsSharedSizeScope="True" Margin="5,0,5,5">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>
        <Grid Grid.Row="0">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto"
        SharedSizeGroup="CarLabels"/>
                <ColumnDefinition Width="*"/>
            </Grid.ColumnDefinitions>
            <Label Grid.Column="0" Content="Vehicle"/>
            <ComboBox Name="cboCars"  Grid.Column="1"
      DisplayMemberPath="PetName" />
        </Grid>
        <Grid Grid.Row="1" Name="DetailsGrid">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto"
      SharedSizeGroup="CarLabels"/>
                <ColumnDefinition Width="*"/>
            </Grid.ColumnDefinitions>
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
            </Grid.RowDefinitions>
            <Label Grid.Column="0" Grid.Row="0" Content="Id"/>
            <TextBox Grid.Column="1" Grid.Row="0" />
            <Label Grid.Column="0" Grid.Row="1" Content="Make"/>
            <TextBox Grid.Column="1" Grid.Row="1" />
            <Label Grid.Column="0" Grid.Row="2" Content="Color"/>
            <TextBox Grid.Column="1" Grid.Row="2" />
            <Label Grid.Column="0" Grid.Row="3" Content="Pet Name"/>
            <TextBox Grid.Column="1" Grid.Row="3" />
            <StackPanel Grid.Column="0" Grid.ColumnSpan="2" Grid.Row="4"
       HorizontalAlignment="Right" Orientation="Horizontal" Margin="0,5,0,5">
                <Button x:Name="btnAddCar" Content="Add Car" Margin="5,0,5,0" Padding="4, 2" />
                <Button x:Name="btnChangeColor" Content="Change Color" Margin="5,0,5,0"
       Padding="4, 2"/>
            </StackPanel>
        </Grid>
    </Grid>
```
Тег IsSharedSizeScope в елементі керування Grid налаштовує дочірні сітки для спільного використання вимірів. Визначення стовпців (ColumnDefinicions), позначені як SharedSizeGroup, автоматично змінять розмір на ту саму ширину без необхідності будь-якого програмування. У цьому прикладі, якщо label Pet Name змінити на щось набагато довше, розмір стовпця Vehicle (який знаходиться в іншому елементі керування Grid) буде змінено відповідно до нього, що збереже вигляд вікна акуратним та охайним.
Далі клацніть правою кнопкою миші на назві проекту в Solution Explorer, виберіть Add ➤ New Folder та назвіть папку Models. У цій новій папці створіть клас з назвою Car. Початковий клас наведено тут:

```cs
namespace WpfNotifications.Models;

public class Car
{
    public int Id { get; set; }
    public string Make { get; set; } = null!;
    public string Color { get; set; } = null!;
    public string PetName { get; set; } = null!;
}
```

## Додавання прив’язок та даних

Наступний крок – додати оператори зв’язування для елементів керування. Пам’ятайте, що оператори зв’язування даних обертаються навколо контексту даних, і це можна встановити на самому елементі керування або на батьківському елементі керування. Тут ви збираєтеся встановити контекст для DetailsGrid, щоб кожен елемент керування, що міститься в ньому, успадковував цей контекст даних. Встановіть для DataContext значення властивості SelectedItem елемента ComboBox.

```xml
        <Grid Grid.Row="1" Name="DetailsGrid"
              DataContext="{Binding ElementName=cboCars, Path=SelectedItem}">
```
Текстові поля в DetailsGrid відображатимуть окремі властивості вибраного автомобіля. Додайте відповідні текстові атрибути та пов’язані з ними прив’язки до елементів керування TextBox, ось так:

```xml
            <Label Grid.Column="0" Grid.Row="0" Content="Id"/>
            <TextBox Grid.Column="1" Grid.Row="0" Text="{Binding Path=Id}" />
            <Label Grid.Column="0" Grid.Row="1" Content="Make"/>
            <TextBox Grid.Column="1" Grid.Row="1" Text="{Binding Path=Make}" />
            <Label Grid.Column="0" Grid.Row="2" Content="Color"/>
            <TextBox Grid.Column="1" Grid.Row="2" Text="{Binding Path=Color}"/>
            <Label Grid.Column="0" Grid.Row="3" Content="Pet Name"/>
            <TextBox Grid.Column="1" Grid.Row="3" Text="{Binding Path=PetName}"/>
```

Нарешті, додайте дані до ComboBox. У MainWindow.xaml.cs створіть новий список записів Car та встановіть ItemsSource для ComboBox у цьому списку. Також додайте оператор using для простору імен Notifications.Models.

```cs
        public IList<Car> _cars = new List<Car>();
        public MainWindow()
        {
            InitializeComponent();
            _cars.Add(new Car { Id = 1, Color = "Blue", Make = "Chevy", PetName = "Kit" });
            _cars.Add(new Car { Id = 2, Color = "Red", Make = "Ford", PetName = "Red Rider" });
            cboCars.ItemsSource = _cars;
        }
```

Запустіть програму. Ви побачите, що у селекторі транспортних засобів є два автомобілі на вибір. Виберіть один із них, і текстові поля будуть автоматично заповнені деталями транспортного засобу. Змініть колір одного з транспортних засобів, виберіть інший транспортний засіб, а потім поверніться до транспортного засобу, який ви редагували. Ви побачите, що новий колір справді все ще прив'язаний до транспортного засобу. У цьому немає нічого надзвичайного; ви вже бачили можливості прив'язки даних XAML у попередніх прикладах.

## Програмна зміна даних транспортного засобу

Хоча попередній приклад працює належним чином, якщо дані змінюються програмно, інтерфейс користувача не відображатиме зміни, якщо ви не запрограмуєте додаток на оновлення даних. Щоб продемонструвати це, додайте обробник подій для кнопки btnChangeColor, ось так:
```xml
                <Button x:Name="btnChangeColor" Content="Change Color" Margin="5,0,5,0"
       Padding="4, 2" Click="btnChangeColor_Click"/>
```
В обробнику події BtnChangeColor_Click() скористайтеся властивістю SelectedItem об'єкта ComboBox, щоб знайти вибраний запис зі списку автомобілів і змінити колір на Pink. Код наведено нижче:

```cs
        private void btnChangeColor_Click(object sender, RoutedEventArgs e)
        {
            _cars.First(x => x.Id == ((Car)cboCars.SelectedItem)?.Id).Color = "Pink";
        }
```
Запустіть програму, виберіть транспортний засіб і натисніть кнопку «Change Color». Помітно нічого не змінюється. Виберіть інший транспортний засіб і поверніться до початково вибраного транспортного засобу. Тепер ви побачите оновлене значення. Це не дуже зручно для користувача!
Тепер додайте обробник подій до кнопки btnAddCar, ось так:

```xml
                <Button x:Name="btnAddCar" Content="Add Car" Margin="5,0,5,0" Padding="4, 2" Click="btnAddCar_Click" />
```
В обробнику події BtnAddCar_Click додайте новий запис до списку автомобілів.

```cs
        private void btnAddCar_Click(object sender, RoutedEventArgs e)
        {
            int maxId = _cars?.Max(c => c.Id) ?? 0;
            Car car = new() 
            { 
                Id = ++maxId, 
                Color = "Yellow", 
                Make = "VW", 
                PetName = "Birdie" 
            };
            _cars?.Add(car);
        }
```
Запустіть програму, натисніть кнопку «Add Car» та перегляньте вміст ComboBox. Хоча ви знаєте, що у списку є три автомобілі, відображаються лише два! Щоб виправити обидві ці проблеми, вам потрібно перетворити клас Car на спостережувану модель та використовувати спостережувану колекцію для зберігання всіх екземплярів Car.

## Спостережувані моделі

Проблема зміни даних у властивості вашої моделі, яка не відображається в інтерфейсі користувача, вирішується шляхом реалізації інтерфейсу INotifyPropertyChanged у класі моделі Car. Інтерфейс INotifyPropertyChanged містить одну подію: PropertyChangedEvent. Механізм зв'язування XAML прослуховує цю подію для кожної зв'язаної властивості в класах, що реалізують інтерфейс INotifyPropertyChanged. Інтерфейс показано тут:

```cs
public interface INotifyPropertyChanged
{
  event PropertyChangedEventHandler PropertyChanged;
}
```
Додайте наступні оператори using до класу Car.cs:

```cs
using System.ComponentModel;
using System.Runtime.CompilerServices;
```

Далі, реалізуйте інтерфейс INotifyPropertyChanged у класі наступним чином:

```cs
public class Car : INotifyPropertyChanged
{
    //...
    public event PropertyChangedEventHandler? PropertyChanged;
}
```
Подія PropertyChanged приймає посилання на об'єкт та новий екземпляр класу PropertyChangedEventArgs, як у цьому прикладі:

```cs
PropertyChanged?.Invoke(this, new PropertyChangedEventArgs("Color"));
```
Перший параметр – це екземпляр об'єкта, який викликає подію. Конструктор PropertyChangedEventArgs приймає рядок, який вказує на властивість, що була змінена та потребує оновлення. Коли виникає подія, механізм прив'язки шукає будь-які елементи керування, пов'язані з іменованою властивістю цього екземпляра. Якщо передати String.Empty в PropertyChangedEventArgs, усі зв'язані властивості екземпляра оновлюються. 
Ви контролюєте, які властивості враховуються в автоматичних оновленнях. Тільки ті властивості, які викликають подію PropertyChanged у set, будуть автоматично оновлені. Зазвичай це всі властивості ваших класів моделей, але ви можете пропустити певні властивості залежно від вимог вашої програми. Замість того, щоб викликати подію безпосередньо в set для кожної з перелічених властивостей, поширеним шаблоном є створення допоміжного методу (зазвичай з назвою OnPropertyChanged()), який викликає подію від імені властивостей, зазвичай у базовому класі для ваших моделей. Додайте наступний метод і код до класу Car.cs:

```cs
    protected void OnPropertyChanged([CallerMemberName] string propertyName = "")
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
```
Далі оновіть кожну з автоматичних властивостей у класі Car, щоб мати повноцінний геттер та сеттер з резервним полем.

```cs
    private string _make = null!;
    private int _id;
    private string _color = null!;
    private string _petName = null!;

    public int Id
    {
        get => _id;
        set
        {
            if (value == _id) return;
            _id = value;
            OnPropertyChanged();
        }
    }

    public string Make
    {
        get => _make;
        set
        {
            if (value == _make) return;
            _make = value;
            OnPropertyChanged();
        }
    }

    public string Color
    {
        get => _color;
        set
        {
            if (value == _color) return;
            _color = value;
            OnPropertyChanged();
        }
    }

    public string PetName
    {
        get => _petName;
        set
        {
            if (value == _petName) return;
            _petName = value;
            OnPropertyChanged();
        }
    }

```
Запустіть програму ще раз. Виберіть транспортний засіб і натисніть кнопку «Change Color». Ви одразу побачите зміни в інтерфейсі користувача. Першу проблему вирішено!

### Використання nameof

Ви можете використовувати оператор nameof, який надає рядкове ім'я елемента, переданого в метод nameof. Ви можете використовувати це у викликах OnPropertyChanged() у ваших сеттерах, ось так:

```cs
public string Color
{
  get { return _color; }
  set
  {
    if (value == _color) return;
    _color = value;
    OnPropertyChanged(nameof(Color));
  }
}
```
Зверніть увагу, що вам не потрібно видаляти атрибут CallerMemberName з OnPropertyChanged() під час використання методу nameof (хоча це стає непотрібним). Зрештою, використання методу nameof чи атрибута CallerMemberName залежить від особистого вибору.

## Спостережувані колекції

Наступна проблема, яку потрібно вирішити, — це оновлення інтерфейсу користувача, коли вміст колекції змінюється. Це робиться шляхом реалізації інтерфейсу INotifyCollectionChanged. Як і інтерфейс INotifyPropertyChanged, цей інтерфейс надає одну подію – подію CollectionChanged. На відміну від події INotifyPropertyChanged, реалізація цього інтерфейсу вручну — це більше, ніж просто виклик методу в сеттері. Вам потрібно створити повну реалізацію List та викликати подію CollectionChanged щоразу, коли ваш список змінюється.

## Використання класу ObservableCollections

На щастя, існує набагато простіший спосіб, ніж створення власного класу колекції. Клас ObservableCollection<T> реалізує INotifyCollectionChanged, INotifyPropertyChanged та Collection<T>  і є частиною .NET Core. Додаткової роботи не потрібно. Щоб побачити це, додайте оператор using для System.Collections.ObjectModel, а потім оновіть приватне поле для _cars наступним чином:

```cs
using System.Collections.ObjectModel;
 //...
        public IList<Car> _cars = new ObservableCollection<Car>();
```
Запустіть програму ще раз і натисніть кнопку «Add Car». Ви побачите, що нові записи відображаються належним чином.

## Реалізація прапорця «брудного» стану

Ще однією перевагою спостережуваних моделей є можливість відстежувати зміни стану. Брудне відстеження (відстеження, коли одне або декілька значень об'єкта змінилися) у WPF є досить простим. Додайте властивість типу bool з назвою IsChanged до класу Car. Обов’язково викликайте OnPropertyChanged() так само, як і інші властивості в класі Car.

```cs
private bool _isChanged;
public bool IsChanged {
  get => _isChanged;
  set
  {
    if (value == _isChanged) return;
    _isChanged = value;
    OnPropertyChanged();
  }
}
```
Вам потрібно встановити властивість IsChanged у значення true у методі OnPropertyChanged(). Також потрібно переконатися, що ви не встановлюєте IsChanged на true під час оновлення IsChanged, інакше ви зіткнетеся з винятком переповнення стека! Оновіть метод OnPropertyChanged() до наступного (який використовує метод nameof, обговорений раніше):

```cs
    protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = "")
    {
        if (propertyName != nameof(IsChanged))
        {
            IsChanged = true;
        }
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
```
Відкрийте MainWindow.xaml та додайте додатковий RowDefinition до DetailsGrid. Додайте наступний код до кінця Grid, який містить Label та CheckBox, пов'язані з властивістю IsChanged, наступним чином:

```xml
        <Grid Grid.Row="1" Name="DetailsGrid" DataContext="{Binding ElementName=cboCars, Path=SelectedItem}">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto" SharedSizeGroup="CarLabels"/>
                <ColumnDefinition Width="*"/>
            </Grid.ColumnDefinitions>
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
            </Grid.RowDefinitions>
            <Label Grid.Column="0" Grid.Row="0" Content="Id"/>
            <TextBox Grid.Column="1" Grid.Row="0" Text="{Binding Path=Id}" />
            <Label Grid.Column="0" Grid.Row="1" Content="Make"/>
            <TextBox Grid.Column="1" Grid.Row="1" Text="{Binding Path=Make}" />
            <Label Grid.Column="0" Grid.Row="2" Content="Color"/>
            <TextBox Grid.Column="1" Grid.Row="2" Text="{Binding Path=Color}" />
            <Label Grid.Column="0" Grid.Row="3" Content="Pet Name"/>
            <TextBox Grid.Column="1" Grid.Row="3" Text="{Binding Path=PetName}"/>
            <StackPanel Grid.Column="0" Grid.ColumnSpan="2" Grid.Row="4"
                        HorizontalAlignment="Right" Orientation="Horizontal" Margin="0,5,0,5">
                <Button x:Name="btnAddCar" Content="Add Car" Margin="5,0,5,0" Padding="4, 2" Click="btnAddCar_Click" />
                <Button x:Name="btnChangeColor" Content="Change Color" Margin="5,0,5,0" Click="btnChangeColor_Click"
                        Padding="4, 2"/>
            </StackPanel>
            <Label Grid.Column="0" Grid.Row="5" Content="Is Changed"/>
            <CheckBox Grid.Column="1" Grid.Row="5" VerticalAlignment="Center"
                      Margin="10,0,0,0" IsEnabled="False" IsChecked="{Binding Path=IsChanged}" />
        </Grid>
```
Якби ви зараз запустили програму, ви б побачили, що кожен запис відображається як змінений, навіть якщо ви нічого не змінювали! Це пояснюється тим, що створення об'єкта встановлює значення властивостей, а встановлення будь-яких значень викликає OnPropertyChanged(). Це встановлює властивість об'єкта IsChanged. Щоб виправити це, встановіть для властивості IsChanged значення false як останньої властивості в коді ініціалізації об'єкта. Відкрийте MainWindow.xaml.cs та змініть код, який створює список, на такий:

```cs
            _cars.Add(new Car { Id = 1, Color = "Blue", Make = "Chevy", PetName = "Kit", IsChanged = false });
            _cars.Add(new Car { Id = 2, Color = "Red", Make = "Ford", PetName = "Red Rider", IsChanged = false });
```
Також треба змінити метод:

```cs
        private void btnAddCar_Click(object sender, RoutedEventArgs e)
        {
            int maxId = _cars?.Max(c => c.Id) ?? 0;
            Car car = new() 
            { 
                Id = ++maxId, 
                Color = "Yellow", 
                Make = "VW", 
                PetName = "Birdie",
                IsChanged = false                
            };
            _cars?.Add(car);
        }
```

Знову запустіть програму, виберіть транспортний засіб і натисніть кнопку «Change Color». Ви побачите, що прапорець встановлено разом з оновленим кольором.

## Оновлення джерела інформації через взаємодію з інтерфейсом користувача

Ви можете помітити, що якщо ввести текст в інтерфейс користувача, прапорець «Змінено» насправді не встановлюється, доки ви не вийдете з елемента керування, що редагується, за допомогою клавіші Tab. Це пов'язано з властивістю UpdateSourceTrigger у прив'язках TextBox. UpdateSourceTrigger визначає, яка подія (наприклад, зміна значення, перехід до іншого елемента керування тощо) змушує інтерфейс користувача оновлювати базові дані. Існує чотири варіанти, як показано в таблиці.

UpdateSourceTrigger значення

|Член|Значення|
|--------|-----|
|Default|Встановлює значення за замовчуванням для елемента керування (наприклад, LostFocus для елементів керування TextBox).|
|Explicit|Оновлює вихідний об'єкт лише тоді, коли викликається метод UpdateSource.|
|LostFocus|Оновлюється, коли елемент керування втрачає фокус. Це значення за замовчуванням для елементів керування TextBox.|
|PropertyChanged|Оновлюється одразу після зміни властивості. Це значення за замовчуванням для елементів керування CheckBox.|

Тригером за замовчуванням для TextBox є подія LostFocus. Змініть це на PropertyChanged, оновивши прив'язку для Color TextBox до наступного XAML:

```xml
<TextBox Grid.Column="1" Grid.Row="2" Text="{Binding Path=Color, UpdateSourceTrigger=PropertyChanged}" />
```
Тепер, коли ви запускаєте програму та починаєте вводити текст у текстове поле «Color», прапорець одразу встановлюється. Ви можете запитати, чому для елементів керування TextBox за замовчуванням встановлено значення LostFocus. Будь-яка перевірка (про яку буде розказано трохи згодом) для моделі спрацьовує разом з UpdateSourceTrigger. Для текстового поля це може призвести до постійного миготіння помилок, доки користувач не введе правильні значення. Наприклад, якщо правила перевірки не дозволяють використовувати менше п’яти символів у текстовому полі (TextBox), помилка відображатиметься з кожним натисканням клавіші, доки користувач не введе п’ять або більше символів. У таких випадках найкраще зачекати, поки користувач вийде з текстового поля за допомогою клавіші Tab (після завершення зміни тексту), щоб оновити джерело.

## Завершення роботи зі сповіщеннями та спостережуваними елементами

Використання INotifyPropertyChanged у ваших моделях та класах ObservableCollections для ваших списків покращує взаємодію з користувачем, синхронізуючи дані та інтерфейс користувача. Хоча жоден з інтерфейсів не є складним, вони вимагають оновлень коду. На щастя, Microsoft включила клас ObservableCollection для обробки всіх етапів створення спостережуваних колекцій. Так само вдалим є оновлення проєкту Fody, яке автоматично додає функціональність INotifyPropertyChanged. Маючи ці два інструменти в руках, немає жодної причини не реалізовувати observables у ваших WPF-застосунках.

# Валідація в WPF

Тепер, коли ви реалізували INotifyPropertyChanged та використовуєте ObservableCollection, настав час додати валідації до вашої програми. Програми повинні перевіряти введені користувачем дані та надавати користувачеві зворотний зв'язок, коли введені дані неправильні. У цьому розділі розглядаються найпоширеніші механізми перевірки для сучасних WPF-застосунків, але це лише частина можливостей, вбудованих у WPF. 
Валідація відбувається, коли прив'язка даних намагається оновити джерело даних. Окрім вбудованих валідацій, таких як винятки в методі set, ви можете створювати власні правила валідації. Якщо будь-яке правило перевірки (вбудоване чи користувальницьке) не працює, у гру вступає клас Validation, який обговорюватиметься трохи пізніше.
    Для кожного з розділів цієї глави ви можете продовжувати роботу в тому ж проєкті з попереднього розділу або створювати копію проєкту для кожного нового розділу. У репозиторії для цього розділу кожен розділ є окремим проєктом.

## Оновлення зразка для прикладів перевірки

Створимо новий преокт WpfValidations. Скрпіюємо розмітку з попередьного проекту а також клас Car та визначення в класі MainWindow.

## Клас Validation

Перш ніж додавати валідації до вашого проєкту, важливо зрозуміти клас Validation. Цей клас є частиною фреймворку валідації та надає методи та додані властивості, які можна використовувати для відображення результатів валідації. Існує три основні властивості класу Validation, які зазвичай використовуються під час обробки помилок перевірки. Ви використовуватимете кожен з них у решті цього розділу.

Ключові члени класу валідації
|Член|Значення|
|----|--------|
|HasError|Додана властивість, яка вказує на те, що правило перевірки десь у процесі завершилося невдало|
|Errors|Колекція всіх активних об'єктів ValidationError|
|ErrorTemplate|Шаблон елемента керування, який стає видимим і прикрашає зв'язаний елемент, коли для HasError встановлено значення true|

## Варіанти перевірки

Як згадувалося, технології XAML мають кілька механізмів для включення логіки валідації у вашу програму. У наступних розділах ви розглянете три найпоширеніші варіанти перевірки.

## Повідомляти про винятки

Хоча винятки не слід використовувати для забезпечення бізнес-логіки, винятки можуть траплятися і трапляються, і їх слід обробляти належним чином. Якщо вони не обробляються в коді, користувач має отримати візуальний зворотний зв'язок про проблему. Важливою зміною порівняно з WinForms є те, що винятки зв'язування WPF за замовчуванням не поширюються на користувача як винятки. Однак вони візуально позначені за допомогою декоратора (візуального шару, який розташований поверх ваших елементів керування).
Щоб перевірити це, запустіть програму, виберіть запис з ComboBox та очистіть значення Id. Оскільки властивість Id визначена як ціле число (не null-допустиме ціле число), обов'язкове числове значення. Коли ви переходите за межі поля Id за допомогою клавіші Tab, фреймворк зв'язування надсилає до властивості Id порожній рядок, і оскільки порожній рядок не може бути перетворений на ціле число, у методі встановлення виникає виняток. Зазвичай, необроблений виняток генерував би вікно повідомлення для користувача, але в цьому випадку нічого подібного не сталося. Якщо ви подивитеся в розділ «Debug» вікна «Output», ви побачите наступне:

```
System.Windows.Data Error: 7 : ConvertBack cannot convert value '' (type 'String'). BindingExpression:Path=Id; DataItem='Car' (HashCode=11404133); target element is 'TextBox' (Name=''); target property is 'Text' (type 'String') FormatException:'System.FormatException: The input string '' was not in a correct format.
   at System.Number.ThrowFormatException[TChar](ReadOnlySpan`1 value)
```
Візуальне відображення винятку – це тонка червона рамка навколо елемента керування. Червоний прямокутник – це властивість ErrorTemplate об’єкта Validation, яка діє як декоратор для пов’язаного елемента керування. Хоча декоратор помилки за замовчуванням показує, що помилка справді є, немає жодної ознаки того, що саме не так. Гарна новина полягає в тому, що шаблон помилки ErrorTemplate повністю налаштовується, як ви побачите далі в цьому розділі.

## IDataErrorInfo

Інтерфейс IDataErrorInfo надає механізм для додавання користувацьких валідацій до ваших класів моделей. Цей інтерфейс додається безпосередньо до класів вашої моделі (або моделі перегляду), а код перевірки розміщується всередині класів вашої моделі (бажано в часткових класах). Це централізує код перевірки у вашому проєкті, на відміну від проєктів WinForms, де перевірка зазвичай виконувалася в самому інтерфейсі користувача.
Інтерфейс IDataErrorInfo, показаний тут, містить дві властивості: індексатор та рядкову властивість з назвою Error. Зверніть увагу, що механізм зв'язування WPF не використовує властивість Error.

```cs
public interface IDataErrorInfo
{
  string this[string columnName] { get; }
  string Error { get; }
}
```

Спочатку потрібно оновити клас Car.cs та позначити його як partial.

```cs
public partial class Car : INotifyPropertyChanged
{
    //...
}
```
Далі, додайте ще один файл класу до каталогу Models з назвою CarPartial.cs. Перейменуйте цей клас на Car, переконайтеся, що клас позначено як частковий, та додайте інтерфейс IDataErrorInfo. Нарешті, реалізуйте API для інтерфейсу. Початковий код наведено тут:

```cs
namespace WpfValidations.Models;

public partial class Car : IDataErrorInfo
{
    public string this[string columnName] => string.Empty;
    public string Error { get; }
}
```
Щоб зв'язаний елемент керування міг підключитися до інтерфейсу IDataErrorInfo, він повинен додати ValidatesOnDataErrors до виразу зв'язування. Оновіть вираз зв’язування для текстового поля «Id» до наступного (і оновіть решту операторів зв’язування таким самим чином):

```xml
            <TextBox Grid.Column="1" Grid.Row="0" Text="{Binding Path=Id,  ValidatesOnDataErrors=True}" />
```

Після внесення цього оновлення до операторів зв'язування індексатор моделі викликається щоразу, коли виникає подія PropertyChanged. Ім'я властивості з події використовується як параметр columnName в індексаторі. Якщо індексатор повертає string.Empty, фреймворк припускає, що всі перевірки пройдено, і жодної помилки не існує. Якщо індексатор повертає будь-що, крім string.Empty, передбачається, що для властивості цього екземпляра об'єкта існує помилка, і кожен елемент керування, пов'язаний з властивістю, що перевіряється в цьому конкретному екземплярі класу, вважається таким, що містить помилку, властивість HasError об'єкта Validation встановлюється на значення true, а для відповідних елементів керування активується елемент керування ErrorTemplate.
Далі ви додасте просту логіку перевірки до індексатора в CarPartial.cs. Правила перевірки прості.

1. Якщо значення Make дорівнює значенню ModelT, встановіть значення помилки, що дорівнює «Too Old».
2. Якщо марка дорівнює Chevy, а колір дорівнює Pink, встановіть помилку, що дорівнює $"{Marke}'s don't come in {Color}".

Почніть з додавання оператора switch для кожної властивості. Щоб уникнути використання магічних рядків в операторах case, ви знову використовуватимете метод nameof. Якщо код не проходить через оператор switch, поверніть string.Empty. Далі додайте правила перевірки. У відповідних операторах case додайте перевірку значення властивості на основі правил, перелічених раніше. В операторі case для властивості Make спочатку перевірте, чи значення не дорівнює ModelT. Якщо так, поверніть помилку. Якщо це пройде, наступний рядок викличе допоміжний метод, який повертає помилку, якщо друге правило порушено, або повертає string.Empty, якщо ні. В операторі case для властивості Color також викличте допоміжний метод. Код виглядає наступним чином:

```cs
    public string this[string columnName]
    {
        get
        {
            switch (columnName)
            {
                case nameof(Id):
                    break;
                case nameof(Make):
                    return Make == "ModelT" ? "Too Old" : CheckMakeAndColor();
                case nameof(Color):
                    return CheckMakeAndColor();
                case nameof(PetName):
                    break;
            }
            return string.Empty;
        }
    }

    private string CheckMakeAndColor()
    {
        if (Make == "Chevy" && Color == "Pink")
        {
            return $"{Make}'s don't come in {Color}";
        }
        return string.Empty;
    }

```
Запустіть програму, виберіть автомобіль Red Rider (Ford) та змініть марку на ModelT. Після того, як ви вийдете з поля за допомогою клавіші Tab, з’явиться червоний декоратор помилки. Тепер виберіть Kit (це Chevy) з випадаючого списку та натисніть кнопку «Change Color», щоб змінити колір на Pink. Червона позначка помилки одразу з’являється в полі Color, але не в текстовому полі Make. Тепер змініть марку на Ford, вийдіть з текстового поля за допомогою клавіші Tab і зверніть увагу, що червона прикраса не зникає!
Це пояснюється тим, що індексатор запускається лише тоді, коли для властивості спрацьовує подія PropertyChanged. Як обговорювалося раніше, подія PropertyChanged спрацьовує, коли змінюється властивість вихідного об'єкта, і це відбувається або через код (наприклад, натискання кнопки «Change Color»), або через взаємодію з користувачем (час цього контролюється через UpdateSourceTrigger). Коли ви змінили колір, властивість Make не змінилася, тому подія для властивості Make не спрацювала. Оскільки подія не спрацювала, індексатор не викликався, тому перевірка властивості Make не виконувалася.
Існує два способи виправити це. Перший — змінити PropertyChangedEventArgs, щоб оновлювати кожну зв'язану властивість, передаючи string.Empty замість назви поля. Як обговорювалося, це змушує механізм зв'язування оновлювати кожну властивість цього екземпляра. Оновіть метод OnPropertyChanged() у класі Car.cs ось так:

```cs
    protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
    {
        if (propertyName != nameof(IsChanged))
        {
            IsChanged = true;
        }
        //PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(string.Empty));
    }
```
Тепер, коли ви запускаєте той самий тест, ви бачите, що обидва текстові поля Make та Color прикрашені шаблоном помилки, коли одне з них оновлюється. То чому ж не завжди викликати подію таким чином? Це значною мірою питання продуктивності. Можливо, що оновлення кожної властивості об'єкта може негативно вплинути на продуктивність. Звичайно, без тестування неможливо дізнатися, і ваша продуктивність може (і, ймовірно, буде) відрізнятися.
Інше рішення полягає в тому, щоб викликати подію PropertyChanged для інших залежних полів, коли одне з них змінюється. Недоліком використання цього механізму є те, що ви (або інші розробники, які підтримують ваш додаток) повинні знати, що властивості Make та Color пов'язані через код перевірки.

## INotifyDataErrorInfo

Інтерфейс INotifyDataErrorInfo базується на інтерфейсі IDataErrorInfo та додає додаткові можливості для перевірки. Звісно, ​​з додатковими можливостями приходить і додаткова робота! У рамках різкого переходу від попередніх методів перевірки, які потрібно було спеціально використовувати, властивість прив’язки ValidatesOnNotifyDataErrors за замовчуванням має значення true, тому додавання цієї властивості до ваших операторів прив’язки є необов’язковим.
Інтерфейс INotifyDataErrorInfo надзвичайно малий, але для його ефективної роботи потрібен досить великий обсяг коду, як ви скоро побачите. Інтерфейс показано тут:

```cs
public interface INotifyDataErrorInfo
{
  bool HasErrors { get; }
  event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;
  IEnumerable GetErrors(string propertyName);
}
```
Властивість HasErrors використовується механізмом зв'язування для визначення наявності помилок у будь-якій із властивостей екземпляра. Якщо метод GetErrors() викликається з порожнім рядком або null для параметра propertyName, він повертає всі помилки, що існують в екземплярі. Якщо в метод передається propertyName, повертаються лише помилки для цієї конкретної властивості. Подія ErrorsChanged (як і події PropertyChanged та CollectionChanged) повідомляє механізм зв'язування про необхідність оновлення інтерфейсу користувача для поточного списку помилок.

## Реалізація допоміжного коду

Під час реалізації INotifyDataErrorInfo більшість коду зазвичай поміщається в базовий клас моделі, тому його потрібно написати лише один раз. Почніть із заміни IDataErrorInfo на INotifyDataErrorInfo у класі CarPartial.cs та додайте члени інтерфейсу (ви можете залишити код з IDataErrorInfo в класі; ви оновите його пізніше).

```cs
public partial class Car : INotifyDataErrorInfo, IDataErrorInfo
{

    //...
    public bool HasErrors => throw new NotImplementedException();

    public event EventHandler<DataErrorsChangedEventArgs>? ErrorsChanged;

    public IEnumerable GetErrors(string? propertyName)
    {
        throw new NotImplementedException();
    }
}
```
Далі додайте Dictionary<string,List<string>>, який міститиме всі помилки, згруповані за назвою властивості, як показано тут

```cs
    private readonly Dictionary<string, List<string>> _errors = new();
```

Властивість HasErrors повинна повертати значення true, якщо у словнику є помилки. Це легко зробити так:

```cs
    public bool HasErrors => _errors.Any();
```
Далі створіть допоміжний метод для виклику події ErrorsChanged (так само, як і для виклику події PropertyChanged), ось так:

```cs
private void OnErrorsChanged(string propertyName)
{
  ErrorsChanged?.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
}
```
Як згадувалося раніше, метод GetErrors() повинен повертати будь-які помилки у словнику, якщо параметр порожній або має значення null. Якщо передано значення propertyName, метод поверне будь-які помилки, знайдені для цієї властивості. Якщо параметр не збігається (або для властивості немає помилок), то метод поверне значення null.

```cs
    public IEnumerable GetErrors(string? propertyName)
    {
        if (string.IsNullOrEmpty(propertyName))
        {
            return _errors.Values;
        }
        return _errors.ContainsKey(propertyName) ? _errors[propertyName] : null;
    }
```

Останній набір допоміжних методів додасть одну або декілька помилок для властивості або очистить усі помилки для властивості (або всіх властивостей). Щоразу, коли словник змінюється, не забудьте викликати допоміжний метод OnErrorsChanged().

```cs
    private void AddError(string propertyName, string error)
    {
        AddErrors(propertyName, new List<string> { error });
    }
    private void AddErrors(string propertyName, IList<string> errors)
    {
        if (errors == null || !errors.Any())
        {
            return;
        }
        var changed = false;
        if (!_errors.ContainsKey(propertyName))
        {
            _errors.Add(propertyName, new List<string>());
            changed = true;
        }
        foreach (var err in errors)
        {
            if (_errors[propertyName].Contains(err)) continue;
            _errors[propertyName].Add(err);
            changed = true;
        }
        if (changed)
        {
            OnErrorsChanged(propertyName);
        }
    }
    protected void ClearErrors(string propertyName = "")
    {
        if (string.IsNullOrEmpty(propertyName))
        {
            _errors.Clear();
        }
        else
        {
            _errors.Remove(propertyName);
        }
        OnErrorsChanged(propertyName);
    }
```
Тепер питання: «Як активується цей код?» Механізм зв'язування прослуховує подію ErrorsChanged та оновлює інтерфейс користувача, якщо відбудуться зміни в колекції помилок для оператора зв'язування. Але коду перевірки все одно потрібен тригер для виконання. Для цього є два механізми, і вони будуть розглянуті далі.

## Використовуйте INotifyDataErrorInfo для перевірок

Одне з місць для перевірки помилок – це сеттери властивостей, як у наступному прикладі, спрощеному до перевірки лише на валідацію ModelT:

```cs
public string Make
{
  get { return _make; }
  set
  {
    if (value == _make) return;
    _make = value;
    if (Make == "ModelT")
    {
      AddError(nameof(Make), "Too Old");
    }
    else
    {
      ClearErrors(nameof(Make));
    }
    OnPropertyChanged(nameof(Make));
    OnPropertyChanged(nameof(Color));
  }
}
```
Основна проблема цього підходу полягає в тому, що вам доведеться поєднувати логіку перевірки з засобами встановлення властивостей, що ускладнює читання та підтримку коду.

## Поєднання IDataErrorInfo з INotifyDataErrorInfo для валідацій

У попередньому розділі ви бачили, що IDataErrorInfo можна додати до часткового класу, а це означає, що вам не потрібно оновлювати сеттери. Ви також бачили, що індексатор автоматично викликається, коли для властивості виникає PropertyChanged. Поєднання IDataErrorInfo та INotifyDataErrorInfo надає додаткові можливості для перевірки з INotifyDataErrorInfo та відокремлення від сеттерів, що надаються IDataErrorInfo.
Мета використання IDataErrorInfo не для виконання перевірок, а для того, щоб переконатися, що ваш код перевірки, який використовує INotifyDataErrorInfo, викликається щоразу, коли для вашого об'єкта виникає PropertyChanged. Оскільки ви не використовуєте IDataErrorInfo для перевірки, завжди повертайте string.Empty з індексатора. Оновіть індексатор та допоміжний метод CheckMakeAndColor() до наступного коду:

```cs
public string this[string columnName]
{
  get
  {
    ClearErrors(columnName);
    switch (columnName)
    {
      case nameof(Id):
        break;
      case nameof(Make):
        CheckMakeAndColor();
        if (Make == "ModelT")
        {
          AddError(nameof(Make), "Too Old");
        }
        break;
      case nameof(Color):
        CheckMakeAndColor();
        break;
      case nameof(PetName):
        break;
    }
    return string.Empty;
  }
}

private bool CheckMakeAndColor()
{
  if (Make == "Chevy" && Color == "Pink")
  {
    AddError(nameof(Make), $"{Make}'s don't come in {Color}");
    AddError(nameof(Color),$"{Make}'s don't come in {Color}");
    return true;
  }
  return false;
}
```
Запустіть програму, виберіть Chevy та змініть колір на Pink. Окрім червоних рамок навколо текстових полів Make та Model, ви також побачите червону рамку-орнамент навколо всієї сітки DetailsGrid. Це ще одна перевага використання INotifyDataErrorInfo. Окрім елементів керування, що містять помилки, елемент керування, що визначає контекст даних, також доповнюється шаблоном помилки.

## Показ всіх помилок

Властивість Errors класу Validation повертає всі помилки перевірки для певного об'єкта у вигляді об'єктів ValidationError. Кожен об'єкт ValidationError має властивість ErrorContent, яка містить список повідомлень про помилки для цієї властивості. Це означає, що повідомлення про помилки, які ви хочете відобразити, знаходяться в цьому списку всередині списку. Щоб відобразити їх належним чином, вам потрібно створити ListBox, який містить ListBox для відображення даних. Це звучить трохи рекурсивно, але стане зрозуміло, як тільки ви це побачите.
Почніть з додавання ще одного рядка до DetailsGrid та переконайтеся, що висота вікна (Height of Window) становить щонайменше 300. Додайте ListBox в останньому рядку та прив’яжіть ItemsSource до DetailsGrid, використовуючи Validation.Errors для шляху, наступним чином:

```xml
            <ListBox Grid.Row="6" Grid.Column="0" Grid.ColumnSpan="2"
                     ItemsSource="{Binding ElementName=DetailsGrid, Path=(Validation.Errors)}">
            </ListBox>
```
Додайте DataTemplate до ListBox, а в DataTemplate додайте ListBox, пов'язаний з властивістю ErrorContent. Контекст даних для кожного ListBoxItem у цьому випадку є об'єктом ValidationError, тому вам не потрібно встановлювати контекст даних, лише шлях. Встановіть шлях зв'язування на ErrorContent, ось так:

```xml
            <ListBox Grid.Row="6" Grid.Column="0" Grid.ColumnSpan="2"
                     ItemsSource="{Binding ElementName=DetailsGrid, Path=(Validation.Errors)}">
                <ListBox.ItemTemplate>
                    <DataTemplate>
                        <ListBox ItemsSource="{Binding Path=ErrorContent}"/>
                    </DataTemplate>
                </ListBox.ItemTemplate>
            </ListBox>
```
Запустіть програму, виберіть Chevy та встановіть колір на Pink. 
Це лише поверхневе знайомство з можливостями валідації та відображення згенерованих помилок, але це має допомогти вам розробити інформативні інтерфейси користувача, які покращують взаємодію з користувачем.

## Переміщення допоміжного коду до базового класу

Як ви, мабуть, помітили, у класі CarPartial.cs зараз багато коду. Оскільки цей приклад має лише один клас моделі, це не страшно. Але, додаючи моделі до реальної програми, вам не потрібно додавати всю цю допоміжний код до кожного часткового класу для ваших моделей. Найкраще, що можна зробити, це перенести весь цей допоміжний код до базового класу. Ви зробите це зараз.
Додайте новий файл класу до папки Models з назвою BaseEntity.cs. Додайте оператори using для System.Collections та System.ComponentModel. Зробіть клас публічним та додайте інтерфейс INotifyDataErrorInfo, ось так:

```cs
using System.Collections;
using System.ComponentModel;

namespace WpfValidations.Models;

public class BaseEntity : INotifyDataErrorInfo
{
    protected readonly Dictionary<string, List<string>> _errors = new Dictionary<string, List<string>>();

    public IEnumerable GetErrors(string propertyName)
    {
        if (string.IsNullOrEmpty(propertyName))
        {
            return _errors.Values;
        }
        return _errors.ContainsKey(propertyName) ? _errors[propertyName] : null;
    }

    public bool HasErrors => _errors.Any();
    public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;
    protected void OnErrorsChanged(string propertyName)
    {
        ErrorsChanged?.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
    }
    protected void AddError(string propertyName, string error)
    {
        AddErrors(propertyName, new List<string> { error });
    }
    protected void AddErrors(string propertyName, IList<string> errors)
    {
        if (errors == null || !errors.Any())
        {
            return;
        }
        var changed = false;
        if (!_errors.ContainsKey(propertyName))
        {
            _errors.Add(propertyName, new List<string>());
            changed = true;
        }
        foreach (var err in errors)
        {
            if (_errors[propertyName].Contains(err)) continue;
            _errors[propertyName].Add(err);
            changed = true;
        }
        if (changed)
        {
            OnErrorsChanged(propertyName);
        }
    }
    protected void ClearErrors(string propertyName = "")
    {
        if (string.IsNullOrEmpty(propertyName))
        {
            _errors.Clear();
        }
        else
        {
            _errors.Remove(propertyName);
        }
        OnErrorsChanged(propertyName);
    }
}

```
Перемістіть весь код з CarPartial.cs, що стосується INofityDataErrorInfo, у новий базовий клас. Будь-які private методи та змінні потрібно зробити protected. Далі видаліть інтерфейс INotifyDataErrorInfo з класу CarPartial.cs та додайте BaseEntity як базовий клас наступним чином:

```cs

public partial class Car : BaseEntity, IDataErrorInfo
{
    //...
}
```

Тепер будь-які додаткові класи моделей, які ви створите, успадкують весь код інженерії INotifyDataErrorInfo.

## Використання анотацій даних за допомогою WPF

WPF також може використовувати анотації даних для валідації даних в інтерфейсі користувача. Давайте додамо деякі анотації даних до моделі Car.

## Додавання анотацій даних до моделі

Відкрийте Car.cs та додайте using System.ComponentModel.DataAnnotations. Додайте атрибути [Required] та [StringLength(50)] до властивостей Make, Color та PetName. 

```cs
    [Required]
    [StringLength(50)]
    public string Color
    {
        get => _color;
        set
        {
            if (value == _color) return;
            _color = value;
            OnPropertyChanged();
        }
    }
```


Атрибут Required додає правило перевірки, що властивість не повинна бути null (щоправда, це надлишкове для властивості Id, оскільки вона не є цілим числом, що може мати значення null). Атрибут StringLength(50) додає правило перевірки, що значення властивості не може бути довшим за 50 символів.

## Перевірка на наявність помилок перевірки на основі анотацій даних

У WPF потрібно програмно перевіряти наявність помилок перевірки на основі анотацій даних. Двома ключовими класами для валідацій на основі анотацій є класи ValidationContext та Validator. Клас ValidationContext надає контекст для перевірки класу на наявність помилок перевірки. Клас Validator дозволяє перевіряти об'єкт на наявність помилок, пов'язаних з атрибутами, у межах ValidationContext.
Відкрийте BaseEntity.cs та додайте наступні оператори using:

```cs
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
```

Далі створіть новий метод з назвою GetErrorsFromAnnotations(). Цей метод є узагальненим, приймає назву рядкової властивості та значення типу T як параметри та повертає масив рядків. Переконайтеся, що метод позначено як захищений:

```cs
    protected string[]? GetErrorsFromAnnotations<T>(string propertyName, T value)
    {
    }
```
У методі створіть змінну List<ValidationResult>, яка зберігатиме результати перевірок валідації, та створіть ValidationContext з областю видимості, що відповідає назві властивості, переданій у метод. Коли ці два елементи будуть на місці, викличте Validate.TryValidateProperty, яка повертає логічне значення. Якщо все пройде успішно (щодо перевірки анотацій даних), повертається значення true. Якщо ні, повертається значення false та заповнюється List<ValidationResult> помилками. Повний код показано тут:

```cs
    protected string[]? GetErrorsFromAnnotations<T>(string propertyName, T value)
    {
        var results = new List<ValidationResult>();
        var vc = new ValidationContext(this, null, null) { MemberName = propertyName };
        var isValid = Validator.TryValidateProperty(value, vc, results);
        return !isValid ? Array.ConvertAll(results.ToArray(), o => o.ErrorMessage) : null;
    }
```
Тепер ви можете оновити метод індексатора в CarPartial.cs, щоб перевірити наявність помилок на основі анотацій даних. Якщо виявлено будь-які помилки, додайте їх до колекції помилок, що підтримує INotifyDataErrorInfo. Це дозволяє нам очистити обробку помилок. На початку методу індексатора очистіть помилки для стовпця. Потім обробіть перевірки та, нарешті, налаштуйте логіку для сутності. Оновлений код індексатора показано тут:

```cs
    public string this[string columnName]
    {
        get
        {
            ClearErrors(columnName);
            var errorsFromAnnotations = GetErrorsFromAnnotations(columnName,
                typeof(Car).GetProperty(columnName)?.GetValue(this, null));
            if (errorsFromAnnotations != null)
            {
                AddErrors(columnName, errorsFromAnnotations);
            }
            switch (columnName)
            {
                //...
            }
            return string.Empty;
        }
    }
```
Запустіть програму, виберіть один із транспортних засобів і додайте текст для кольору, який містить понад 50 символів. Коли ви перевищуєте поріг у 50 символів, анотація даних StringLength створює помилку перевірки, про яку повідомляється користувачеві.

## Налаштування ErrorTemplate

Остання тема — створити стиль, який застосовуватиметься, коли в елементі керування виникне помилка, а також оновити ErrorTemplate для відображення більш змістовної інформації про помилку. Як ви дізналися з попереднього розділу, елементи керування можна налаштовувати за допомогою стилів та шаблонів елементів керування. 
Почніть з додавання нового стилю в розділі Windows.Resources файлу MainWindow.xaml з цільовим типом TextBox. Далі додайте тригер до стилю, який встановлює властивості, коли властивість Validation.HasError має значення true. Властивості та значення, які потрібно встановити для ErrorContent, це Background (Pink), Foreground (Black) та Tooltip. Сетери Background та Foreground не є чимось новим, але синтаксис для встановлення ToolTip потребує деякого пояснення. Прив'язка вказує на елемент керування, до якого застосовується цей стиль, у цьому випадку, TextBox. Шлях – це перше значення ErrorContent колекції Validation.Errors. Розмітка виглядає наступним чином:

```xml
    <Window.Resources>
        <Style TargetType="{x:Type TextBox}">
            <Style.Triggers>
                <Trigger Property="Validation.HasError" Value="true">
                    <Setter Property="Background" Value="Pink" />
                    <Setter Property="Foreground" Value="Black" />
                    <Setter Property="ToolTip" Value="{Binding RelativeSource={RelativeSource Self},
                    Path=(Validation.Errors)[0].ErrorContent}" />
                </Trigger>
            </Style.Triggers>
        </Style>
    </Window.Resources>
```
Запустіть програму та створіть умову помилки. Результат буде з підказкою, яка відображає повідомлення про помилку.

Попередній стиль змінював зовнішній вигляд будь-якого текстового поля (TextBox), яке містить умову помилки. Далі ви створите шаблон власного елемента керування, щоб оновити ErrorTemplate класу Validation, щоб він відображав червоний знак оклику, та встановити підказки для знака оклику. Шаблон помилки (ErrorTemplate) – це декоратор, який розміщується поверх елемента керування. Хоча щойно створений стиль оновлює сам елемент керування, ErrorTemplate буде розташовуватися поверх нього. Розмістіть сеттер одразу після закриваючого тегу Style.Triggers у щойно створеному стилі. Ви створюватимете шаблон елемента керування, що складається з TextBlock (для відображення знака оклику) та BorderBrush, що оточує TextBox, що містить помилку(и). У XAML є спеціальний тег для елемента керування, який доповнюється ErrorTemplate, з назвою AdornedElementPlaceholder. Додавши ім'я до цього елемента керування, ви можете отримати доступ до помилок, пов'язаних з ним. У цьому прикладі вам потрібно отримати доступ до властивості Validation.Errors, щоб отримати ErrorContent (як ви це зробили у Style.Trigger). Ось повна розмітка для сеттера:

```xml
<Window.Resources>
        <Style TargetType="{x:Type TextBox}">
            <Style.Triggers>
                <Trigger Property="Validation.HasError" Value="true">
                    <Setter Property="Background" Value="Pink" />
                    <Setter Property="Foreground" Value="Black" />
                    <Setter Property="ToolTip" Value="{Binding RelativeSource={RelativeSource Self},
        Path=(Validation.Errors)[0].ErrorContent}" />
                </Trigger>
            </Style.Triggers>
            <Setter Property="Validation.ErrorTemplate">
                <Setter.Value>
                    <ControlTemplate>
                        <DockPanel LastChildFill="True">
                            <TextBlock Foreground="Red" FontSize="20" Text="!"
                                       ToolTip="{Binding ElementName=controlWithError,
          Path=AdornedElement.(Validation.Errors)[0].ErrorContent}" />
                            <Border BorderBrush="Red" BorderThickness="1">
                                <AdornedElementPlaceholder Name="controlWithError" />
                            </Border>
                        </DockPanel>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
    </Window.Resources>
```
Запустіть програму та створіть умову помилки.

На цьому ви завершуєте огляд методів валідації в WPF. Звичайно, ви можете зробити набагато більше. Для отримання додаткової інформації зверніться до документації WPF.

# Створення власних команд

Створіть новий проект WpfCommands та скопіюйте всі напрацювання з WpfValidations. 
Як ви вже дізналися раніше, команди є невід'ємною частиною WPF. Команди можна підключити до елементів керування WPF (таких як елементи керування Button та MenuItem) для обробки подій користувача, таких як подія Click(). Замість безпосереднього створення обробника подій та додавання коду безпосередньо до файлу коду програми, метод Execute() команди виконується під час спрацьовування події click. Метод CanExecute() використовується для ввімкнення або вимкнення елемента керування на основі користувацького коду. Окрім вбудованих команд, ви можете створювати власні команди, реалізуючи інтерфейс ICommand. Використовуючи команди замість обробників подій, ви отримуєте перевагу інкапсуляції коду програми, а також автоматичного вмикання та вимикання елементів керування на основі бізнес-логіки.

## Реалізація інтерфейсу ICommand

Інтерфейс ICommand наведено тут:

```cs
public interface ICommand
{
  event EventHandler CanExecuteChanged;
  bool CanExecute(object parameter);
  void Execute(object parameter);
}
```

## Додавання ChangeColorCommand

Обробники подій для ваших елементів керування Button будуть замінені командами, починаючи з кнопки «Change Color». Почніть з додавання нової папки (з назвою Commands) до вашого проекту. Додайте новий клас з назвою ChangeColorCommand.cs. Зробіть клас публічним та реалізуйте інтерфейс ICommand. Додайте наступні оператори using (перший може відрізнятися залежно від того, чи створювали ви новий проект для цього прикладу):

```cs
using System.Windows.Input;
using WpfCommands.Models;

namespace WpfCommands.Commands;

public class ChangeColorCommand : ICommand
{
    public event EventHandler? CanExecuteChanged;

    public bool CanExecute(object? parameter)
    {
        throw new NotImplementedException();
    }

    public void Execute(object? parameter)
    {
        throw new NotImplementedException();
    }
}
```

Якщо метод CanExecute() повертає значення true, будь-які пов'язані елементи керування будуть увімкнені, а якщо повертає значення false, вони будуть вимкнені. Якщо елемент керування увімкнено (оскільки CanExecute() повертає значення true) і натиснуто, спрацює метод Execute(). Параметр, що передається в обидва ці методи, надходить з інтерфейсу користувача на основі властивості CommandParameter, встановленої для операторів зв'язування. Подія CanExecuteChanged пов’язана із системою зв’язування та сповіщень, щоб повідомити інтерфейс користувача про зміну результату методу CanExecute() (подібно до події PropertyChanged). У цьому прикладі кнопка «Change Color» має працювати, лише якщо параметр не є null та має тип Car. Оновіть метод CanExecute() до наступного:

```cs
    public bool CanExecute(object? parameter) => (parameter as Car) != null;

```
Значення параметра методу Execute() таке ж, як і для методу CanExecute(). Оскільки метод Execute() може виконуватися лише якщо об'єкт має тип Car, аргумент має бути приведений до типу Car та оновлений колір наступним чином:

```cs
    public void Execute(object? parameter)
    {
        ((Car)parameter).Color = "Pink";
    }
```

## Приєднання команди до CommandManager

Остаточне оновлення для класу команд полягає в тому, щоб ввести команду в диспетчер команд. Метод CanExecute() спрацьовує, коли вікно вперше завантажується, а потім, коли менеджер команд дає команду на повторне виконання.
Кожен клас команд має підключитися до менеджера команд. Це робиться шляхом оновлення коду щодо події CanExecuteChanged наступним чином:

```cs
    public event EventHandler? CanExecuteChanged
    {
        add => CommandManager.RequerySuggested += value;
        remove => CommandManager.RequerySuggested -= value;
    }
```

## Оновлення MainWindow.xaml.cs

Наступна зміна полягає у створенні екземпляра цього класу, до якого зможе отримати доступ кнопка Button. Наразі ви розмістите це у файлі коду для MainWindow (пізніше в цьому розділі ви перемістите це в модель перегляду). Відкрийте MainWindow.xaml.cs та видаліть обробник події Click для кнопки «Change Color».
Додайте наступний код using оператор на початок файлу:

```cs
using WpfCommands.Commands;
```
Далі додайте публічну властивість з назвою ChangeColorCmd типу ICommand з полем private.

```cs
       private ICommand _changeColorCommand = null;
       public ICommand ChangeColorCmd =>
            _changeColorCommand ??= new ChangeColorCommand();
```

## Оновлення MainWindow.xaml

Клікувальні елементи керування в WPF (наприклад, елементи керування Button) мають властивість Command, яка дозволяє призначити об'єкт команди елементу керування. Почніть з підключення вашої команди, створеної в коді програмного забезпечення, до кнопки btnChangeColor. Оскільки властивість команди знаходиться в класі MainWindow, для доступу до вікна, яке містить кнопку, використовується синтаксис зв'язування RelativeSourceMode наступним чином:

```
Command="{Binding Path=ChangeColorCmd,
  RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"
```
Кнопка все ще має надсилати об'єкт Car як параметр для методів CanExecute() та Execute(). Це призначається через властивість CommandParameter. Ви встановлюєте для нього значення SelectedItem комбінованого списку cboCars наступним чином:

```
CommandParameter="{Binding ElementName=cboCars, Path=SelectedItem}"
```
Повна розмітка для кнопки показана тут:

```xml
                <Button x:Name="btnChangeColor" Content="Change Color" Margin="5,0,5,0" Padding="4, 2"
                        Command="{Binding Path=ChangeColorCmd, RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"
                        CommandParameter="{Binding ElementName=cboCars, Path=SelectedItem}" />
```
Запустіть програму. Ви побачите, що команда «Change Color» не активована,  оскільки транспортний засіб не вибрано. Тепер виберіть транспортний засіб; кнопка стане активною, і натискання на неї змінить колір, як і очікувалося.

## Створення класу CommandBase

Якщо ви продовжите використовувати цей шаблон для AddCarCommand.cs, код буде повторюватися між класами. Це гарна ознака того, що базовий клас може допомогти. Створіть новий клас з назвою CommandBase.cs та додайте використання для простору імен System.Windows.Input. Встановіть клас як публічний та реалізуйте інтерфейс ICommand. Змініть клас і методи Execute() і CanExecute() на abstract. Нарешті, додайте оновлену подію CanExecuteChanged з класу ChangeColorCommand. Повна реалізація наведена тут:

```cs
using System.Windows.Input;

namespace WpfCommands.Commands;

public abstract class CommandBase : ICommand
{
    public abstract bool CanExecute(object? parameter);
    public abstract void Execute(object? parameter);

    public event EventHandler? CanExecuteChanged
    {
        add => CommandManager.RequerySuggested += value;
        remove => CommandManager.RequerySuggested -= value;
    }
}
```

## Додавання класу AddCarCommand

Додайте новий клас з назвою AddCarCommand.cs. Зробіть клас публічним та додайте CommandBase як базовий клас. Додайте наступні оператори using на початок файлу:

```cs
using System.Collections.ObjectModel;
using WpfCommands.Models;
```
Очікується, що параметр буде ObservableCollection<Car>, тому перевірте це в методі CanExecute(). Якщо це так, то метод Execute() повинен додати додатковий автомобіль, як і обробник події Click.

```cs
using System.Collections.ObjectModel;
using WpfCommands.Models;

namespace WpfCommands.Commands;

class AddCarCommand : CommandBase
{
    public override bool CanExecute(object? parameter) =>
        parameter is ObservableCollection<Car>;

    public override void Execute(object? parameter)
    {
        if (parameter is not ObservableCollection<Car> cars)
        {
            return;
        }
        var maxCount = cars.Max(x => x.Id);
        cars.Add(new Car
        {
            Id = ++maxCount,
            Color = "Yellow",
            Make = "VW",
            PetName = "Birdie",
            IsChanged = false
        });
    }
}
```
## Оновлення MainWindow.xaml.cs

Додайте публічну властивість з назвою AddCarCmd типу ICommand з полем private. У тілі виразу для властивості поверніть резервну властивість (обов'язково створіть новий екземпляр AddCarCommand, якщо поле резервної властивості має значення null).

```cs
        private ICommand _addCarCommand = null;
        public ICommand AddCarCmd
          => _addCarCommand ??= new AddCarCommand();
```

## Оновлення MainWindow.xaml

Оновіть XAML, щоб видалити атрибут Click та додати атрибути Command та CommandParameter. AddCarCommand отримуватиме список автомобілів зі списку cboCars. Повний XAML кнопки виглядає наступним чином:

```xml
                <Button x:Name="btnAddCar" Content="Add Car" Margin="5,0,5,0" Padding="4, 2" 
                        Command="{Binding Path=AddCarCmd, RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"
                        CommandParameter="{Binding ElementName=cboCars, Path=ItemsSource}" />
```

Завдяки цьому ви тепер можете додавати автомобілі та оновлювати колір автомобілів, використовуючи код повторного використання, що міститься в окремих класах.

## Оновлення ChangeColorCommand

Останній крок – оновити ChangeColorCommand для успадкування від CommandBase. Змініть ICommand на CommandBase, додайте ключове слово override до обох методів та видаліть код CanExecuteChanged. Це справді так просто! Новий код наведено тут:

```cs
public class ChangeColorCommand : CommandBase
{
    public override bool CanExecute(object? parameter) => (parameter as Car) != null;
    
    public override void Execute(object? parameter)
    {
        ((Car)parameter).Color = "Pink";
    }
}
```

## RelayCommands

Ще однією реалізацією шаблону команд у WPF є RelayCommand. Замість створення нового класу для кожної команди, цей шаблон використовує делегати для реалізації інтерфейсу ICommand. Це спрощена реалізація, оскільки кожна команда не має власного класу. Команди RelayCommand зазвичай використовуються, коли для реалізації команди не потрібне повторне використання.

## Створення базової команди RelayCommand

Класи RelayCommand зазвичай реалізуються у двох класах. Базовий клас RelayCommand використовується, коли для методів CanExecute() та Execute() не потрібні параметри, а RelayCommand<T> використовується, коли параметр потрібен. Ви почнете з базового класу RelayCommand, який використовує клас CommandBase. Додайте новий клас з назвою RelayCommand.cs. Зробіть клас публічним та додайте CommandBase як базовий клас. Додайте дві змінні рівня класу для зберігання делегатів Execute() та CanExecute().

```cs
namespace WpfCommands.Commands;

public class RelayCommand : CommandBase
{
    private readonly Action _execute;
    private readonly Func<bool> _canExecute;
}

```
Створіть три конструктори. Перший — це конструктор за замовчуванням (потрібен класу, похідному від RelayCommand<T>), другий — це конструктор, який приймає параметр Action, а третій — це конструктор, який приймає параметр Action та параметр Func, як показано нижче:

```cs
    public RelayCommand() { }
    public RelayCommand(Action execute) : this(execute, null) { }
    public RelayCommand(Action execute, Func<bool> canExecute)
    {
        _execute = execute ?? throw new ArgumentNullException(nameof(execute));
        _canExecute = canExecute;
    }
```
Нарешті, реалізуйте перевизначення CanExecute() та Execute(). CanExecute() повертає true, якщо Func має значення null; або якщо воно не має значення null, виконується та повертає true. Execute() виконує параметр Action.

```cs
    public override bool CanExecute(object parameter) =>
        _canExecute == null || _canExecute();
    public override void Execute(object parameter) { _execute(); }
```

## Створення RelayCommand<T>

Додайте новий клас з назвою RelayCommandT.cs. Цей клас майже повністю відповідає базовому класу, за винятком того, що всі делегати приймають параметр. Зробіть клас публічним та узагальненим, а також додайте RelayCommand як базовий клас наступним чином:

```cs
namespace WpfCommands.Commands;

public class RelayCommand<T> : RelayCommand
{

}
```
Додайте дві змінні рівня класу для зберігання делегатів Execute() та CanExecute():
```cs
    private readonly Action<T> _execute;
    private readonly Func<T, bool> _canExecute;
```
Створіть два конструктори. Перший приймає параметр Action<T>, а другий приймає параметр Action<T> та параметр Func<T,bool>, наступним чином:
```cs
    public RelayCommand(Action<T> execute) : this(execute, null) { }

    public RelayCommand(Action<T> execute, Func<T, bool> canExecute)
    {
        _execute = execute ?? throw new ArgumentNullException(nameof(execute));
        _canExecute = canExecute;
    }
```
Нарешті, реалізуйте перевизначення CanExecute() та Execute(). CanExecute() повертає значення true, якщо Func має значення null; або, якщо воно не має значення null, виконується та повертає значення true. Execute() виконує параметр Action.

```cs
    public override bool CanExecute(object parameter) => _canExecute == null || _canExecute((T)parameter);
    public override void Execute(object parameter) { _execute((T)parameter); }
```
## Оновлення MainWindow.xaml.cs

Коли ви використовуєте RelayCommands, усі методи для делегатів потрібно вказати під час створення нової команди. Це не означає, що код має знаходитися в коді програмного забезпечення (як показано тут); він просто має бути доступним з коду програмного забезпечення. Він може знаходитися в іншому класі (або навіть в іншій збірці), забезпечуючи переваги інкапсуляції коду для створення власного класу команд. Додайте нову приватну змінну типу RelayCommand\<Car\> та публічну властивість з назвою DeleteCarCmd, як показано тут:

```cs
        private RelayCommand<Car> _deleteCarCommand = null;
        public RelayCommand<Car> DeleteCarCmd
            => _deleteCarCommand ??= new RelayCommand<Car>(DeleteCar, CanDeleteCar);
```
Також необхідно створити методи DeleteCar() та CanDeleteCar() наступним чином:

```cs
        private bool CanDeleteCar(Car car) => car != null;
        private void DeleteCar(Car car)
        {
            _cars.Remove(car);
        }
```
Зверніть увагу на сувору типізацію в методах — це одна з переваг використання RelayCommand\<T\>.

## Додавання та реалізація кнопки «Delete Car»

Останній крок для об'єднання всього цього – додати кнопку та призначити прив'язки Command та CommandParameter. Додайте таку розмітку:

```xml
                <Button x:Name="btnDeleteCar" Content="Delete Car" Margin="5,0,5,0" Padding="4, 2"
                        Command="{Binding Path=DeleteCarCmd, RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"
                        CommandParameter="{Binding ElementName=cboCars, Path=SelectedItem}"/>
```
Тепер, коли ви запускаєте програму, ви можете перевірити, чи кнопка «Delete Car» активна, лише якщо автомобіль вибрано у випадаючому списку, і чи натискання кнопки дійсно видаляє автомобіль зі списку автомобілів.

## Підсумок команд

На цьому завершується ваша коротка екскурсія в команди WPF. Переносячи обробку подій з файлу коду програмного забезпечення в окремі класи команд, ви отримуєте переваги інкапсуляції коду, повторного використання та покращеної зручності обслуговування. Якщо вам не потрібне таке суттєве розділення завдань, ви можете використовувати легшу реалізацію RelayCommand. Мета полягає в покращенні зручності обслуговування та якості коду, тому оберіть метод, який найкраще підходить саме вам.

# Міграція коду та даних до ViewModel

Створіть новий проект WpfViewModel та скопіюйте всі напрацювання з попереднього.
Створіть нову папку з назвою ViewModels у вашому проекті та додайте до неї новий клас з назвою MainWindowViewModel.cs. Додайте наступні простори імен та зробіть клас публічним:

```cs
using System.Collections.ObjectModel;
using System.Windows.Input;
using WpfViewModel.Commands;
using WpfViewModel.Models;
```

    Популярною домовленістю є називання ViewModel на честь вікна, яке вони підтримують.

## Переміщення коду MainWindow.xaml.cs

Майже весь код з файлу коду буде перенесено до моделі представлення. В кінці буде лише кілька рядків, включаючи виклик InitializeComponent() та код для встановлення контексту даних для вікна в моделі перегляду.

Створіть публічну властивість типу IList<Car> з назвою Cars, ось так:

```cs
    public IList<Car> Cars { get; } = new ObservableCollection<Car>();
```
Створіть конструктор за замовчуванням та перемістіть весь код створення автомобіля з файлу MainWindow.xaml.cs, оновивши назву змінної списку.

```cs
    public MainWindowViewModel()
    {
        Cars.Add( new Car { Id = 1, Color = "Blue", Make = "Chevy", PetName = "Kit", IsChanged = false });
        Cars.Add( new Car { Id = 2, Color = "Red", Make = "Ford", PetName = "Red Rider", IsChanged = false });
    }
```
Далі перемістіть весь код, пов'язаний з командами  до моделі представлення, оновивши посилання на змінну _cars на Cars.

```cs
   private ICommand _changeColorCommand = null;
   public ICommand ChangeColorCmd => _changeColorCommand ??= new ChangeColorCommand();

   private ICommand _addCarCommand = null;
   public ICommand AddCarCmd => _addCarCommand ??= new AddCarCommand();

   private RelayCommand<Car> _deleteCarCommand = null;
   public RelayCommand<Car> DeleteCarCmd
       => _deleteCarCommand ??= new RelayCommand<Car>(DeleteCar, CanDeleteCar);
   private bool CanDeleteCar(Car car) => car != null;
   private void DeleteCar(Car car)
   {
       Cars.Remove(car);
   }
```
Тепер це має виглядати так:

```cs
public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
    }
}
```
Додайте наступний оператор using на початок файлу:

```cs
using WpfViewModel.ViewModels;
```
Далі створіть строго типізовану властивість для зберігання екземпляра моделі представлення.

```cs
        public MainWindowViewModel ViewModel { get; set; } = new();
```
Нарешті, додайте властивість DataContext до оголошення вікна в XAML.

```xml
<Window x:Class="WpfViewModel.MainWindow"
        ...
        DataContext="{Binding ViewModel, RelativeSource={RelativeSource Self}}"
        ...
        Title="MainWindow" Height="450" Width="800">
```

## Оновлення розмітки елемента керування

Тепер, коли DataContext для вікна встановлено на модель перегляду, потрібно оновити прив’язки XAML для елементів керування. Починаючи з combo box, оновіть розмітку, додавши ItemsSource.

```xml
<ComboBox Name="cboCars"  Grid.Column="1" DisplayMemberPath="PetName" ItemsSource="{Binding Cars}"/>
```
Це працює, оскільки контекстом даних для Window є MainWindowViewModel, а Cars є публічною властивістю моделі представлення. Нагадаємо, що виклики прив'язок проходять вгору по дереву елементів, доки не буде знайдено контекст даних. Далі вам потрібно оновити прив’язки для елементів керування Button. Це просто; оскільки прив'язки вже встановлені на рівні вікна, вам просто потрібно оновити оператор прив'язки, щоб він починався з властивості DataContext, наступним чином:

```xml
                <Button x:Name="btnAddCar" Content="Add Car" Margin="5,0,5,0" Padding="4, 2" 
                        Command="{Binding Path=DataContext.AddCarCmd, RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"
                        CommandParameter="{Binding ElementName=cboCars, Path=ItemsSource}" />
                <Button x:Name="btnChangeColor" Content="Change Color" Margin="5,0,5,0" Padding="4, 2"
                        Command="{Binding Path=DataContext.ChangeColorCmd, RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"
                        CommandParameter="{Binding ElementName=cboCars, Path=SelectedItem}" />
                <Button x:Name="btnDeleteCar" Content="Delete Car" Margin="5,0,5,0" Padding="4, 2"
                        Command="{Binding Path=DataContext.DeleteCarCmd, RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"
                        CommandParameter="{Binding ElementName=cboCars, Path=SelectedItem}"/>
```

## Підсумок що до ViewModel

Вірите чи ні, але ви щойно завершили свою першу MVVM WPF-застосунок. Ви можете думати: "Це не реальна програма. Що з даними? Дані в цьому прикладі є жорсткими". І ви були б праві. Це не справжній додаток; це демоверсія. Однак, у цьому і полягає краса шаблону MVVM. Представлення нічого не знає про походження даних; воно просто прив'язується до властивості моделі представлення. Ви можете міняти реалізації моделі перегляду, можливо, використовуючи версію з жорстко закодованими даними для тестування та ту, яка надсилається до бази даних для виробництва.
Можна обговорити багато додаткових моментів, зокрема різні фреймворки з відкритим кодом, шаблон View Model Locator та безліч різних думок щодо того, як найкраще реалізувати цей шаблон. У цьому і полягає краса шаблонів проектування програмного забезпечення — зазвичай існує багато правильних способів їх реалізації, і вам просто потрібно знайти найкращий спосіб, виходячи з ваших бізнес-вимог та технічних вимог.

## Оновлення AutoLot.Dal для MVVM

Якщо ви хочете оновити AutoLot.Dal для MVVM, вам доведеться застосувати зміни, які ми внесли для класу Car, до всіх сутностей у проекті AutoLot.Dal.Models, включаючи BaseEntity.

# Підсумки

У цьому розділі розглянуто теми WPF, що підтримують паттерн Model-View-ViewModel. Ви почали з вивчення того, як прив'язувати класи моделей та колекції до системи сповіщень у менеджері зв'язування. Ви реалізували INotifyPropertyChanged та використали класи ObservableCollections для синхронізації інтерфейсу користувача зі зв'язаними даними.
Далі ви додали код перевірки до моделі за допомогою IDataErrorInfo та INotifyDataErrorInfo та перевірили наявність помилок анотації даних. Потім ви відобразили будь-які помилки перевірки в інтерфейсі користувача, щоб користувач знав, у чому проблема та як її виправити, а також створили стиль і шаблон власного елемента керування для змістовного відображення помилок.
Зрештою, ви зібрали все це разом, додавши модель перегляду, та очистили розмітку інтерфейсу користувача та файл коду програмного забезпечення, щоб покращити розділення завдань.