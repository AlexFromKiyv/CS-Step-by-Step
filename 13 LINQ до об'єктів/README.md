# LINQ до об'єктів.

Більша частина програм обробляє дані в пеаних формах при виконанні. Це може бути массив, коллекція в пам'яті, база даних, файл XML. Доступ до ціх даних схожий але довгий час виористовувався різний API. Набір технологій LINQ забезпечує стислий, симетричний і строго типізований спосіб доступу до широкого спектру сховищ даних.

## Спеціфічні конструкції програмування LINQ.

LINQ можна розглядати як вбудована в C# строго типізована мова запитів до даних. Про це говорить розшифровка абрівіатура LINQ Language Integreted Quary.
Використовуючи LINQ можна створювати вирази у вигляді запитів до даних схожі на SQL. Вони можуть бути застосована для різних сховищ, які не мають нічого спільного з реляційними базами даних. Синтаксис SQL і LINQ не індентичний. Краще сприймати запити LINQ як унікальні оператори.
В LINQ використовується:
    Неявно типізовані локальні змінні.
    Синтаксис ініціалізації об'єкта та коллекції.
    Лямбда-вирази.
    Методи розширення.
    Анонімні типи.

Переглянемо ці можливості коротоко в проекті FeaturesForLINQ. 

### Неявна типізація локальних змінних.
```cs
void ImpicitlyTypedLocalVariables()
{
    var variable1 = 2;
    var variable2 = "Hi";
    var variable3 = false; 
    
    Console.WriteLine($"{nameof(variable1)}\t{variable1}\t{variable1.GetType()}");
    Console.WriteLine($"{nameof(variable2)}\t{variable2}\t{variable2.GetType()}");
    Console.WriteLine($"{nameof(variable3)}\t{variable3}\t{variable3.GetType()}");
}

ImpicitlyTypedLocalVariables();
```
```
variable1       2       System.Int32
variable2       Hi      System.String
variable3       False   System.Boolean
```
Ключеве слово var дозволяє визначити зміну без явного вказування типу на якому вона базується. Однак зміна є строго типізованою оскільки тип визначив компілятор з контексту.
Ця розумність компілятора зручна для LINQ, оскільки деякі типи бувають дуже громізьки а іноді їх визначити складно. Деякі типи, які поверає запит LinQ, не відомі до моменту компіляції. Не знаючи тип ви не можете визначити зміну явно.

### Синтаксис ініціалізації об'єкта та коллекції.

```cs

void ObjectAndCollectionInitializationSyntax()
{
    List<Rectangle> rectangles = new() 
    {
        new Rectangle()
        {
            X = 0,Y = 0,Width = 10, Height = 10,
        },
        new Rectangle()
        {
            X = 10,Y = 10,Width = 20, Height = 20
        },
        new Rectangle()
        {
            X = 30,Y = 30,Width = 40, Height = 40
        },
    };
}
```
Синтаксис ініціалізації компактний варіант створення об'єктів на льоту. Таким же чином можна створювати коллекції. Компактність коду основана користь від цього. 
Цей синтаксис у поєдняні з неявною типізацією дозволяє оголосити анонімний тип, що корисний при створені проекції LINQ. 

### Лямбда-вирази.

Лямбда-вираз можна використовувати будь-коли, коли викликаете метод, який вимагає строго типізований делегат як аргумент. Вони значно спрощують роботу з делегатами, оскільки зменьшують кількість коду який треба робити вручну. 
Лямда-вирази схематично виглядають так.
```cs
( ArgumentsToProcess ) => { StatementsToProcessThem }
``` 
Для об'єктів коллекції List<T> є метод FindAll(Predicate<T> match) в якому для делегата зручно використовувати лямбда-вираз.

```cs
void LambdaExpressions()
{
    List<int> ints = new();

    ints.AddRange(new[] { 12, 31, 23, 21, 34 });

    List<int> evenNumbers = ints.FindAll( x => (x%2) == 0);

    foreach (var item in evenNumbers)
    {
        Console.WriteLine(item);
    }
}

LambdaExpressions();
```
```
12
34
```
Лямбда-вирази дуже корисні для роботи з лежачимі в основі об'єктів моделями LINQ. Оператори запитів LINQ це скорочена нотація для визову методів класу System.Linq.Enumerable. Для ціх методів зазвичай як параметри потрібні делегати (зазвичай Func<>), які використовуються для обробки даних для отримання правільного наботу результатів. За допомогою лямбда-виразу ви можете оптімізувати ваш код даючи компілятору можливість зробити висновок як виглядає об'єкт делегату.

### Методи розширення.

Методи розширеня дозволяють додавати нову функціональність до існуючих класів без необхідності створювати підклас. Вони дозволяють церобити і для класів та структур які не дозволяють успадкування.  

```cs
    internal static class ObjectExtentions
    {
        public static void DisplayDefiningAssembly(this object  obj)
        {
            Console.WriteLine($"{obj.GetType().Name} live here: {Assembly.GetAssembly(obj.GetType())}");
        }
    }
```
Коли створюється метод розширення, перший параметр доповнюється словом this і позначає тип шо розширюється. Крім того методи розширення повині оперовати на рівні класу і тому вони мають бути static і визначені в статичному класі.

```cs
void UseExtentionMethod()
{
    int variable1 = 1;
    variable1.DisplayDefiningAssembly();

    System.Data.DataSet dataSet = new();
    dataSet.DisplayDefiningAssembly();
}

UseExtentionMethod();
```
```
Int32 live here: System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e
DataSet live here: System.Data.Common, Version=7.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
```
При роботі з LINQ рідко коли треба робити їх вручну. Але коли створюється запити ви будите використовувати числені методи розширеня які вбудовані в платформу. Кожен оператор LINQ є скороченою нотацією для ручного виклику методу розширення. Вони як правило визначені в службовому класі System.Linq.Enumerable.

### Анонімні типи.

Анотімні типи дозволяють швидко створити "форму" даних, дозволяючи компілятору генерувати нове визначення класу, під час компіляції, на основі наданого набору пар назва-значення.

```cs
void UseAnonymousType()
{
    var purchaseItem = new
    {
        TimeBought = DateTime.Now,
        ItemBought = new
        {
            Color = "Grey",
            Make = "BMW",
        },
        Price = 35000

    };

    Console.WriteLine(purchaseItem.GetType());
    Console.WriteLine(purchaseItem.ItemBought.Color);
}
```
```
<>f__AnonymousType0`3[System.DateTime,<>f__AnonymousType1`2[System.String,System.String],System.Int32]
Grey

```
Щоб визначити ананімний тип оголошується неявно тепізована змінна та вказується форма данних для за допомогою синтаксису ініціалізації об'єктів.
LINQ часто використовує анонімні типи, коли потрібно проектувати нові форми даних на льоту. Припустимо із колекції об'єктів Person за допомогою запиту LINQ треба отримати призвище та вік кожного. Використовуючи проекцію LINQ ви вкажете компілятору створити новий анонімний тип який буде мати цю інформацію.

## Роль LINQ.

Якшо говорити про дані то це не тілки те шо зберігається в базі данних. Це можуть бути XML документи або текстовий файл. Дані можуть знаходитись в багатьох місцях. Це може бути масив або список List<T>. Однозначно виникне потреба пошукі та виділення підмножини елементів. 
Колись для роботи з різними даними використовувалось дуже різне API. Наче нічого паганого немає в використані різних підходів до різних даних. Однак основна проблема в тому що кожний такій підхід є окремим "островом".
LINQ API - це спроба забезпечити послідовний симетричний спосіб, за допомогою якого можна отримати і маніпулювати "даними" в широкому розумінні цього терміну.
Використовуючи LINQ, можна сворювати конструкції безпосередньов в C#, які називають виразами запитів. Вираз запиту можна використовувати для взаємодії з багатьма типами даних. По суті це опис загального підходу до доступу до даних. 
Однак залежно від того, де ви застосовуєте свої запити LINQ, ви зустрінете різні терміни, наприклад такі:

    LINQ to Objects: цей термін відноситься до акту застосування запитів LINQ до масивів і колекцій.

    LINQ to XML: цей термін стосується використання LINQ для роботи з документами XML і запитів.

    LINQ to Entities: цей аспект LINQ дозволяє використовувати запити LINQ в основному API ADO.NET Entity Framework (EF).

    Parallel LINQ (він же PLINQ): це дозволяє паралельно обробляти дані, отримані із запиту LINQ.

Зараз LINQ є невід’ємною частиною бібліотек базових класів .NET, керованих мов і самої Visual Studio.
Запити LINQ строго типізовані. Це забезпечує компілятор. 
Роботу ціх запитів забезпечує System.Linq як задіюється завдяки global using.

## Застосування LINQ до массивів.







