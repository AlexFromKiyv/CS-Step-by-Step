# Вказівники (Pointers)

Ви дізналися, що платформа .NET визначає дві основні категорії даних: типи значень та типи посилань. Правду кажучи, існує й третя категорія: типи вказівників. Для роботи з типами вказівників використовуються спеціальні оператори та ключові слова, які дозволяють обійти схему керування пам'яттю середовища виконання .NET та взяти справу у свої руки.

Оператори та ключові слова C#, орієнтовані на вказівники

|Operator/Keyword|Значення|
|----------------|--------|
|*|Цей оператор використовується для створення змінної-вказівника (тобто змінної, яка представляє пряме розташування в пам'яті). Як і в C++, цей самий оператор використовується для індирекції вказівника.|
|&|Цей оператор використовується для отримання адреси змінної в пам'яті.|
|->|Цей оператор використовується для доступу до полів типу, представленого вказівником (небезпечна версія оператора крапки в C#).|
|[]|Цей оператор (у небезпечному контексті) дозволяє індексувати слот, на який вказує змінна-вказівник (якщо ви програміст на C++, ви пам'ятаєте взаємодію між змінною-вказівником та оператором []).|
|++, --|У небезпечному контексті оператори інкременту та декременту можна застосовувати до типів вказівників.|
|+, -|У небезпечному контексті оператори додавання та віднімання можуть застосовуватися до типів вказівників.|
|==, !=, <, >, <=, =>|У небезпечному контексті оператори порівняння та рівності можуть бути застосовані до типів вказівників.|
|Stackalloc|У небезпечному контексті ключове слово stackalloc можна використовувати для виділення масивів C# безпосередньо в стеку.|
|Fixed|У небезпечному контексті ключове слово fixed можна використовувати для тимчасового виправлення змінної, щоб можна було знайти її адресу.|

Перш ніж заглиблюватися в деталі, дозвольте мені ще раз зазначити, що вам рідко, якщо взагалі коли-небудь, знадобиться використовувати типи вказівників. Хоча C# дозволяє вам опускатися до рівня маніпуляцій з вказівниками, пам'ятайте, що середовище виконання .NET абсолютно не має уявлення про ваші наміри. Таким чином, якщо ви неправильно керуєте вказівником, саме ви відповідаєте за усунення наслідків. З огляду на ці попередження, коли саме вам знадобиться працювати з типами вказівників? Існує дві поширені ситуації.

1. Ви хочете оптимізувати окремі частини вашої програми, безпосередньо маніпулюючи пам'яттю поза межами керування середовищем виконання.
2. Ви викликаєте методи на основі C .dll-файлу або COM-сервера, які вимагають типи вказівників як параметри. Навіть у цьому випадку часто можна обійти типи вказівників на користь типу System.IntPtr та членів типу System.Runtime.InteropServices.Marshal.

Коли ви вирішите скористатися цією функцією мови C#, вам потрібно повідомити компілятор C# про свої наміри, дозволивши вашому проєкту підтримувати «небезпечний код». Створіть новий проект консольної програми з назвою UnsafeCode та налаштуйте підтримку небезпечного коду для проекту, додавши наступний код до файлу UnsafeCode.csproj:

```xml
  <PropertyGroup>
    ...
    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
  </PropertyGroup>
```

## Ключове слово unsafe

Якщо ви хочете працювати з вказівниками в C#, вам потрібно спеціально оголосити блок «небезпечного коду» за допомогою ключового слова unsafe (будь-який код, не позначений ключовим словом unsafe, автоматично вважається «безпечним»). Наприклад, у наступному файлі Program.cs оголошується область видимості небезпечного коду в безпечних операторах верхнього рівня:

```cs
using UnsafeCode;

unsafe
{
  // Work with pointer types here!
}
// Can't work with pointers here!
```

Окрім оголошення області дії небезпечного коду в межах методу, ви можете створювати структури, класи, члени типів та параметри, які є «небезпечними». Ось кілька прикладів для розгляду (немає потреби визначати типи Node або Node2 у вашому поточному проекті):

```cs
// This entire structure is 'unsafe' and can
// be used only in an unsafe context.
unsafe struct Node
{
  public int Value;
  public Node* Left;
  public Node* Right;
}

// This struct is safe, but the Node2* members
// are not. Technically, you may access 'Value' from
// outside an unsafe context, but not 'Left' and 'Right'.
public struct Node2
{
  public int Value;
  // These can be accessed only in an unsafe context!
  public unsafe Node2* Left;
  public unsafe Node2* Right;
}
```
Методи (статичні або рівня екземпляра) також можуть бути позначені як небезпечні. Наприклад, припустимо, що ви знаєте, що статичний метод використовуватиме логіку вказівників. Щоб переконатися, що цей метод можна викликати лише з небезпечного контексту, ви можете визначити метод наступним чином:

```cs
static unsafe void SquareIntPointer(int* myIntPointer)
{
  // Square the value just for a test.
  *myIntPointer *= *myIntPointer;
}
```
Конфігурація вашого методу вимагає, щоб викликаюча сторона викликала SquareIntPointer() наступним чином:

```cs
unsafe
  {
    int myInt = 10;
    // OK, because we are in an unsafe context.
    SquareIntPointer(&myInt);
    Console.WriteLine('myInt: {0}', myInt);
  }

  int myInt2 = 5;
  // Compiler error! Must be in unsafe context!
  SquareIntPointer(&myInt2);
  Console.WriteLine('myInt: {0}', myInt2);
```
Якщо ви не хочете змушувати викликаючу сторону обгортати виклик у небезпечний контекст, ви можете обгорнути всі оператори верхнього рівня блоком unsafe. Якщо ви використовуєте метод Main() як точку входу, ви можете оновити Main() ключовим словом unsafe. У цьому випадку наступний код буде скомпільовано:

```cs
static unsafe void Main(string[] args)
{
  int myInt2 = 5;
  SquareIntPointer(&myInt2);
  Console.WriteLine('myInt: {0}', myInt2);
}
```

    Важливо зазначити, що термін «небезпечний» був обраний не просто так. Безпосередній доступ до стеку та робота з вказівниками може спричинити неочікувані проблеми як з вашою програмою, так і з машиною, на якій вона працює. Якщо вам доводиться працювати з небезпечним кодом, будьте особливо уважні.

## Робота з операторами * та &

Після встановлення небезпечного контексту ви можете створювати вказівники на типи даних за допомогою оператора * та отримувати адресу того, на що вказується, за допомогою оператора &. На відміну від C або C++, у C# оператор * застосовується лише до базового типу, а не як префікс до кожного імені змінної-вказівника. Наприклад, розглянемо наступний код, який ілюструє як правильний, так і неправильний способи оголошення вказівників на цілочисельні змінні:

```cs
// No! This is incorrect under C#!
int *pi, *pj;
// Yes! This is the way of C#.
int* pi, pj;
```
Розглянемо наступний небезпечний метод:

```cs
static unsafe void PrintValueAndAddress()
{
    int myInt;

    // Define an int pointer, and
    // assign it the address of myInt.
    int* ptrToMyInt = &myInt;

    // Assign value of myInt using pointer indirection.
    *ptrToMyInt = 123;

    // Print some stats.
    Console.WriteLine($"Value of myInt {myInt}");
    Console.WriteLine($"Address of myInt {(int)&ptrToMyInt:X}");
}
unsafe
{
    PrintValueAndAddress();
}
```
```
Value of myInt 123
Address of myInt 257ED30
```

## Небезпечна (і безпечна) функція обміну.

Звичайно, оголошення вказівників на локальні змінні просто для присвоєння їхнього значення (як у попередньому прикладі) ніколи не є обов'язковим і не зовсім корисним. Щоб проілюструвати більш практичний приклад небезпечного коду, припустимо, що ви хочете створити функцію swap, використовуючи арифметику вказівників.

```cs
unsafe static void UnsafeSwap(int* i, int* j)
{
  int temp = *i;
  *i = *j;
  *j = temp;
}
```
Дуже схоже на C, чи не так? Однак, враховуючи вашу попередню роботу, ви повинні знати, що можете написати таку безпечну версію вашого алгоритму заміни, використовуючи ключове слово ref у C#:

```cs
static void SafeSwap(ref int i, ref int j)
{
  int temp = i;
  i = j;
  j = temp;
}
```
Функціональність кожного методу ідентична, що підкреслює той факт, що пряме маніпулювання вказівником не є обов'язковим завданням у C#. Ось логіка виклику з використанням безпечних операторів верхнього рівня з небезпечним контекстом:

```cs
static void CallingSwaps()
{
    int i = 10, j = 20;

    // Swap values "safely."
    Console.WriteLine("\n***** Safe swap *****");
    Console.WriteLine($"Values before safe swap: i = {i}, j = {j}");
    SafeSwap(ref i, ref j);
    Console.WriteLine($"Values after safe swap: i = {i}, j = {j}");

    // Swap values "unsafely."
    Console.WriteLine($"\n***** Unsafe swap *****");
    Console.WriteLine($"Values before unsafe swap: i = {i}, j = {j}");
    unsafe { UnsafeSwap(&i, &j); }

    Console.WriteLine($"Values after unsafe swap: i = {i}, j = {j}");
}
CallingSwaps();
```
```
***** Safe swap *****
Values before safe swap: i = 10, j = 20
Values after safe swap: i = 20, j = 10

***** Unsafe swap *****
Values before unsafe swap: i = 20, j = 10
Values after unsafe swap: i = 10, j = 20
```

## Доступ до полів за допомогою вказівників (оператор ->)

Тепер припустимо, що ви визначили просту, безпечну структуру Point, наступним чином:

```cs
struct Point
{
    public int x;
    public int y;
    public override string ToString() => $"({x},{y})";
}
```
Якщо ви оголошуєте вказівник на тип Point, вам потрібно буде використовувати оператор доступу до поля вказівника (представлений як ->) для доступу до його публічних членів. Як показано в таблиці, це небезпечна версія стандартного (безпечного) оператора крапки (.). Фактично, використовуючи оператор індирекції вказівника (*), можна розіменувати вказівник, щоб (знову ж таки) застосувати нотацію оператора крапки. Розгляньте небезпечний метод:

```cs
static unsafe void UsePointerToPoint()
{
    // Access members via pointer.
    Point point;
    Point* p = &point;
    p->x = 100;
    p->y = 200;
    Console.WriteLine(p->ToString());

    // Access members via pointer indirection.
    Point point2;
    Point* p2 = &point2;
    (*p2).x = 100;
    (*p2).y = 200;
    Console.WriteLine((*p2).ToString());
}
UsePointerToPoint();
```
```
(100,200)
(100,200)
```

## Ключове слово stackalloc

У небезпечному контексті вам може знадобитися оголосити локальну змінну, яка виділяє пам'ять безпосередньо зі стеку викликів (і, отже, не підлягає збиранню сміття .NET). Для цього в C# передбачено ключове слово stackalloc, яке є еквівалентом функції _alloca з бібліотеки середовища виконання C у C#. Ось простий приклад:

```cs
static unsafe string UnsafeStackAlloc()
{
  char* p = stackalloc char[52];
  for (int k = 0; k < 52; k++)
  {
    p[k] = (char)(k + 65)k;
  }
  return new string(p);
}
```

## Закріплення типу за допомогою ключового слова fixed

Як ви бачили в попередньому прикладі, виділення фрагмента пам'яті в небезпечному контексті може бути полегшене за допомогою ключового слова stackalloc. За самою природою цієї операції, виділена пам'ять очищається, щойно метод виділення повертає значення (оскільки пам'ять отримується зі стеку). Під час нашого розгляду оператора -> ви створили тип значення з назвою Point. Як і всі типи значень, виділена пам'ять видаляється зі стеку після завершення виконання області видимості. Для пояснення, припустимо, що Point було визначено як тип посилання, ось так:

```cs
namespace UnsafeCode;
class PointRef 
{
    public int x;
    public int y;
    public override string ToString() => $"({x}, {y})";
}
```
Як ви знаєте, якщо викликаюча сторона оголошує змінну типу Point, пам'ять виділяється на купі зі збиранням сміття. Тоді виникає пекуче питання: «Що робити, якщо небезпечний контекст захоче взаємодіяти з цим об'єктом (або будь-яким об'єктом у купі)?» Враховуючи, що збирання сміття може відбуватися в будь-який момент, уявіть собі проблеми, що виникають під час доступу до членів Point саме в той момент, коли розпочинається очищення купи. Теоретично, можливо, що небезпечний контекст намагається взаємодіяти з членом, який більше не доступний або був переміщений у купі після переживання зміни поколінь (що є очевидною проблемою).
Щоб заблокувати змінну типу посилання в пам'яті від небезпечного контексту, C# надає ключове слово fixed. Оператор fixed встановлює вказівник на керований тип і «закріплює» цю змінну під час виконання коду. Без фіксованих змінних вказівники на керовані змінні були б малокорисними, оскільки збирання сміття може непередбачувано перемістити змінні. (Фактично, компілятор C# не дозволить вам встановити вказівник на керовану змінну, окрім як у фіксованому операторі.)
Таким чином, якщо ви створюєте об'єкт PointRef і хочете взаємодіяти з його членами, ви повинні написати наступний код (або отримати помилку компілятора):

```cs
unsafe static void UseAndPinPoint()
{
    PointRef pt = new PointRef
    {
        x = 5,
        y = 6
    };

    // Pin pt in place so it will not
    // be moved or GC-ed.
    fixed (int* p = &pt.x)
    {
        // Use int* variable here!
    }

    // pt is now unpinned, and ready to be GC-ed once
    // the method completes.
    Console.WriteLine("Point is: {0}", pt);
}
UseAndPinPoint();

```
```
Point is: (5, 6)
```
Коротко кажучи, ключове слово fixed дозволяє створити оператор, який блокує змінну-посилання в пам'яті таким чином, щоб її адреса залишалася постійною протягом усього оператора (або блоку області видимості). Щоразу, коли ви взаємодієте з типом посилання з контексту небезпечного коду, закріплення посилання є обов'язковим.

## Ключове слово sizeof

Як і в C++, ключове слово sizeof у C# використовується для отримання розміру в байтах внутрішнього типу даних, але не власного типу, окрім випадків, коли це відбувається в небезпечному контексті. Наприклад, наступний метод не потрібно оголошувати як «небезпечний», оскільки всі аргументи ключового слова sizeof є внутрішніми типами:

```cs
static void UseSizeOfOperator()
{
    Console.WriteLine("The size of short is {0}.", sizeof(short));
    Console.WriteLine("The size of int is {0}.", sizeof(int));
    Console.WriteLine("The size of long is {0}.", sizeof(long));
    unsafe { Console.WriteLine("The size of Point is {0}.", sizeof(Point)); }
}
UseSizeOfOperator();
```
```
The size of short is 2.
The size of int is 4.
The size of long is 8.
```
Однак, якщо ви хочете отримати розмір вашої власної структури Point, вам потрібно оновити цей метод наступним чином (зверніть увагу, що було додано ключове слово unsafe):
```cs
static void UseSizeOfOperator()
{
    //...
    unsafe { Console.WriteLine("The size of Point is {0}.", sizeof(Point)); }
}
UseSizeOfOperator();
```
```
The size of Point is 8.
```

На цьому ми завершуємо огляд деяких більш просунутих функцій мови програмування C#. Щоб переконатися, що ми всі розуміємо одне й те саме, я ще раз мушу сказати, що більшість ваших проектів .NET можуть ніколи не потребувати безпосереднього використання цих функцій (особливо вказівників). Тим не менш, як ви побачите в наступних розділах, деякі теми є досить корисними, якщо не обов'язковими, під час роботи з API LINQ, зокрема методи розширення та анонімні типи.