# Перезавантаження операторів.

C#, як і будь-яка мова програмування, має стандартний набір токенів, які використовуються для виконання основних операцій з внутрішніми типами. Наприклад, ви знаєте, що оператор + можна застосувати до двох цілих чисел, щоб отримати більше ціле число.

```cs
    // The + operator with ints.
    int a = 100;
    int b = 240;
    int c = a + b;
    Console.WriteLine(c);

```
```
340
```
Знову ж таки, це не якась важлива новина, але чи звертали ви коли-небудь увагу на те, як той самий оператор + можна застосувати до більшості внутрішніх типів даних C#? Наприклад, розглянемо цей код:

```cs
    // + operator with strings.
    string s1 = "Hi";
    string s2 = " girl";
    string s3 = s1 + s2;
    Console.WriteLine(s3);
```
```
Hi girl
```
Оператор + функціонує певним чином залежно від наданих типів даних (у цьому випадку рядків або цілих чисел). Коли оператор + застосовується до числових типів, результатом є підсумовування операндів. Однак, коли оператор + застосовується до рядкових типів, результатом є об'єднання рядків.
Мова C# надає вам можливість створювати власні класи та структури, які також унікально реагують на той самий набір базових токенів (таких як оператор +). Хоча не кожен можливий оператор C# можна перевантажити, багато з них можна, як показано в таблиці
|Оператор|Можливість перезавантажити |
|--------|---------------------------|
|+, -, !, ~, ++, --, true, false|Ці унарні оператори можна перевантажувати. C# вимагає, щоб якщо перевантажено значення true або false, обидва значення мають бути перевантажені.|
|+, -, *, /, %, &, |, ^, <<, >>|Ці бінарні оператори можуть бути перевантажені.|
|==,!=, <, >, <=, >=|Ці оператори порівняння можна перевантажувати. C# вимагає, щоб оператори типу «подібні» (тобто < та >, <= та >=, == та !=) перевантажувалися разом.|
|[]|Оператор [] не можна перевантажувати. Однак, як ви бачили раніше в цьому розділі, конструкція індексатора забезпечує таку ж функціональність.|
|()|Оператор () не можна перевантажувати. Однак, як ви побачите далі в цьому розділі, користувацькі методи перетворення забезпечують таку саму функціональність.|
|+=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=|Скорочені оператори присвоєння не можна перевантажувати; проте ви отримуєте їх безкоштовно, коли перевантажуєте відповідний бінарний оператор.|

## Перевантаження бінарних операторів

Щоб проілюструвати процес перевантаження бінарних операторів, припустимо, що наступний простий клас Point визначено в новому проекті консольної програми з назвою OperatorOverloading:

```cs
// Just a simple, everyday C# class.
public class Point
{
    public int X { get; set; }
    public int Y { get; set; }
    public Point(int xPos, int yPos)
    {
        X = xPos;
        Y = yPos;
    }
    public override string ToString()
      => $"[{X},{Y}]";
}
```
Тепер, логічно кажучи, має сенс «додавати» точки (Points). Наприклад, якщо ви додали дві змінні типу Point, ви повинні отримати нову змінну Point, яка є сумою значень X та Y. Звичайно, також може бути корисним відняти одну змінну Point від іншої.
Однак, у вашому Point зараз ви отримуватимете помилки під час компіляції, оскільки тип Point не знає, як реагувати на оператор + або -. Щоб забезпечити унікальну реакцію власного типу на внутрішні оператори, C# надає ключове слово operator, яке можна використовувати лише разом із ключовим словом static. Коли ви перевантажуєте бінарний оператор (наприклад, + та -), найчастіше ви передаватимете два аргументи того ж типу, що й визначальний клас (у цьому прикладі Point), як показано в наступному оновленні коду:

```cs
// A more intelligent Point type.
public class Point
{
    //...

    // Overloaded operator +.
    public static Point operator +(Point p1, Point p2)
      => new Point(p1.X + p2.X, p1.Y + p2.Y);
    // Overloaded operator -.
    public static Point operator -(Point p1, Point p2)
      => new Point(p1.X - p2.X, p1.Y - p2.Y);
}
```
Логіка оператора + полягає в тому, щоб просто повернути новий об'єкт Point на основі підсумовування полів вхідних параметрів Point.

Логіка оператора + полягає в тому, щоб просто повернути новий об'єкт Point на основі підсумовування полів вхідних параметрів Point. Таким чином, коли ви пишете pt1 + pt2, під капотом ви можете уявити собі наступний прихований виклик статичного методів операторів :
```cs
// Pseudo-code: Point p3 = Point.operator+ (p1, p2)
Point p3 = p1 + p2;
// Pseudo-code: Point p4 = Point.operator- (p1, p2)
Point p4 = p1 - p2;
```
З цим оновленням ваша програма тепер компілюється, і ви можете додавати та віднімати об'єкти Point, як показано в наступному виводі:

```cs
static void UsingPointWithOperators()
{
    // Make two points.
    Point ptOne = new Point(100, 100);
    Point ptTwo = new Point(40, 40);
    Console.WriteLine($"ptOne = {ptOne}");
    Console.WriteLine($"ptTwo = {ptTwo}");
    // Add the points to make a bigger point?
    Console.WriteLine($"ptOne + ptTwo: {ptOne + ptTwo}");
    // Subtract the points to make a smaller point?
    Console.WriteLine($"ptOne - ptTwo: {ptOne - ptTwo}");
}
UsingPointWithOperators();
```
```
ptOne = [100,100]
ptTwo = [40,40]
ptOne + ptTwo: [140,140]
ptOne - ptTwo: [60,60]
```
Під час перевантаження бінарного оператора не потрібно передавати два параметри одного типу. Якщо це має сенс, один з аргументів може відрізнятися. Наприклад, ось перевантажений оператор +, який дозволяє викликаючій особі отримати новий об'єкт Point на основі числового коригування:

```cs
public class Point
{
    //...
    public static Point operator +(Point p1, int change)
    => new Point(p1.X + change, p1.Y + change);
    public static Point operator +(int change, Point p1)
      => new Point(p1.X + change, p1.Y + change);
}
```
Зверніть увагу, що вам потрібні обидві версії методу, якщо ви хочете, щоб аргументи передавалися в будь-якому порядку (тобто ви не можете просто визначити один із методів і очікувати, що компілятор автоматично підтримуватиме інший). Тепер ви можете використовувати ці нові версії оператора + наступним чином:

```cs
    Point point = new Point(100, 100);
    Console.WriteLine($"point = {point}");
    Console.WriteLine($"point + 10 = {point+10}");
    Console.WriteLine($"10 + point = {10+point}");
```
```
point = [100,100]
point + 10 = [110,110]
10 + point = [110,110]
```

## А як щодо операторів += та –=?

У термінології C# скорочені оператори присвоєння автоматично моделюються, якщо тип перевантажує пов'язаний бінарний оператор. Таким чином, враховуючи, що структура Point вже перевантажила оператори + та -, можна написати наступне:

```cs
    Point point1 = new Point(10, 10);
    point += point1;
    Console.WriteLine(point);

    point1 -= point;
    Console.WriteLine(point1);
```
```
[110,110]
[-100,-100]
```

## Перевантаження унарних операторів

C# також дозволяє перевантажувати різні унарні оператори, такі як ++ та --. Коли ви перевантажуєте унарний оператор, ви також повинні використовувати ключове слово static разом із ключовим словом operator; однак у цьому випадку ви просто передаєте один параметр того ж типу, що й визначальний клас/структура. Наприклад, якщо ви оновлюєте Point за допомогою таких перевантажених операторів:

```cs
// Add 1 to the X/Y values for the incoming Point.
  public static Point operator ++(Point p1)
    => new Point(p1.X+1, p1.Y+1);
  // Subtract 1 from the X/Y values for the incoming Point.
  public static Point operator --(Point p1)
    => new Point(p1.X-1, p1.Y-1);
```
Ви можете збільшувати та зменшувати значення x та y точки ось так:

```cs
    point = new(0, 0);
    point++; Console.WriteLine(point);
    point--; Console.WriteLine(point);
    ++point; Console.WriteLine(point);
    --point; Console.WriteLine(point);
```
```
[1,1]
[0,0]
[1,1]
[0,0]
```
Зверніть увагу, що у попередньому прикладі коду ви застосовуєте власні оператори ++ та -- двома різними способами. Однак, повернене значення інкременту/зменшення автоматично обробляється «правильно» безкоштовно (тобто, для перевантаженого оператора ++, pt++ має значення незміненого об'єкта як своє значення у виразі, тоді як ++pt має нове значення, застосоване до використання у виразі).

## Перевантаження операторів рівності

System.Object.Equals() можна перевизначити для виконання порівнянь між типами посилань на основі значень (а не на основі посилань). Якщо ви вирішите перевизначити Equals() (і часто пов'язаний з ним метод System.Object.GetHashCode()), перевантажити оператори рівності (== та !=) легко.  To illustrate, here is the updated Point type:

```cs
  public override bool Equals(object o) => 
    o.ToString() == this.ToString();
  public override int GetHashCode() => 
    this.ToString().GetHashCode();

  // Now let's overload the == and != operators.
  public static bool operator ==(Point p1, Point p2) => p1.Equals(p2);
  public static bool operator !=(Point p1, Point p2) => !p1.Equals(p2);

```
Зверніть увагу, як реалізація операторів == та != просто викликає перевизначений метод Equals(), щоб виконати більшу частину роботи. З огляду на це, тепер ви можете застосувати клас Point наступним чином:
```cs
    point = new(0, 0);
    point1 = new(1, 1);
    Console.WriteLine(point == point1);
    Console.WriteLine(point != point1);
```
```
False
True
```
Як бачите, порівнювати два об'єкти за допомогою відомих операторів == та != досить інтуїтивно, а не через виклик Object.Equals(). Якщо ви перевантажуєте оператори рівності для даного класу, пам'ятайте, що C# вимагає, щоб у разі перевизначення оператора == було також необхідно перевизначити оператор != (якщо ви забудете, компілятор повідомить вас про це).

## Перевантаження операторів порівняння

Раніше ви бачили, як реалізувати інтерфейс IComparable для порівняння зв'язків між двома подібними об'єктами. Фактично, ви також можете перевантажити оператори порівняння (<, >, <= та >=) для того самого класу. Як і у випадку з операторами рівності, C# вимагає, щоб у разі перевантаження < було також перевантажено >. Те саме стосується операторів <= та >=. Реалізуєм інтерфейс для Point:

```cs
public class Point : IComparable<Point>
{

    //...

    public int CompareTo(Point? other)
    {
        if (this.X > other.X && this.Y > other.Y)
        {
            return 1;
        }
        if (this.X < other.X && this.Y < other.Y)
        {
            return -1;
        }
        return 0;
    }

    public static bool operator <(Point p1, Point p2) => p1.CompareTo(p2) < 0;
    public static bool operator >(Point p1, Point p2) => p1.CompareTo(p2) > 0;
    public static bool operator <=(Point p1, Point p2) => p1.CompareTo(p2) <= 0;
    public static bool operator >=(Point p1, Point p2) => p1.CompareTo(p2) >= 0;
}
```
Користувач об'єкта тепер може порівнювати точки (Points) наступним чином:

```cs
    point = new(1, 1);
    point1 = new(2, 2);
    Console.WriteLine(point > point1);
    Console.WriteLine(point < point1);
```
```
False
True
```

## Заключні думки щодо перевантаження операторів

Як ви бачили, C# надає можливість створювати типи, які можуть унікально реагувати на різні вбудовані, добре відомі оператори. Тепер, перш ніж ви переналаштовуєте всі свої класи для підтримки такої поведінки, ви повинні переконатися, що оператори, які ви збираєтеся перевантажити, мають якийсь логічний сенс у світі загалом. Наприклад, припустимо, ви перевантажили оператор множення для класу MiniVan. Що саме означатиме множення двох об'єктів MiniVan? Небагато. Насправді, для членів команди було б заплутано таке використання об'єктів MiniVan:

```cs
// Huh?! This is far from intuitive...
MiniVan newVan = myVan * yourVan;
```
Перевантаження операторів зазвичай корисне лише під час створення атомарних типів даних. Вектори, матриці, текст, точки, фігури, множини тощо є хорошими кандидатами для перевантаження операторів. Люди, менеджери, автомобілі, підключення до баз даних та веб-сторінки – ні. Як правило, якщо перевантажений оператор ускладнює для користувача розуміння функціональності типу, не робіть цього. Використовуйте цю функцію з розумом.
