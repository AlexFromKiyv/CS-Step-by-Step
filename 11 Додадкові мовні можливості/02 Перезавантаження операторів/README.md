# Перезавантаження операторів.

C#, як і будь-яка мова програмування, має стандартний набір токенів, які використовуються для виконання основних операцій з внутрішніми типами. Наприклад, ви знаєте, що оператор + можна застосувати до двох цілих чисел, щоб отримати більше ціле число.

```cs
    // The + operator with ints.
    int a = 100;
    int b = 240;
    int c = a + b;
    Console.WriteLine(c);

```
```
340
```
Знову ж таки, це не якась важлива новина, але чи звертали ви коли-небудь увагу на те, як той самий оператор + можна застосувати до більшості внутрішніх типів даних C#? Наприклад, розглянемо цей код:

```cs
    // + operator with strings.
    string s1 = "Hi";
    string s2 = " girl";
    string s3 = s1 + s2;
    Console.WriteLine(s3);
```
```
Hi girl
```
Оператор + функціонує певним чином залежно від наданих типів даних (у цьому випадку рядків або цілих чисел). Коли оператор + застосовується до числових типів, результатом є підсумовування операндів. Однак, коли оператор + застосовується до рядкових типів, результатом є об'єднання рядків.
Мова C# надає вам можливість створювати власні класи та структури, які також унікально реагують на той самий набір базових токенів (таких як оператор +). Хоча не кожен можливий оператор C# можна перевантажити, багато з них можна, як показано в таблиці
|Оператор|Можливість перезавантажити |
|--------|---------------------------|
|+, -, !, ~, ++, --, true, false|Ці унарні оператори можна перевантажувати. C# вимагає, щоб якщо перевантажено значення true або false, обидва значення мають бути перевантажені.|
|+, -, *, /, %, &, |, ^, <<, >>|Ці бінарні оператори можуть бути перевантажені.|
|==,!=, <, >, <=, >=|Ці оператори порівняння можна перевантажувати. C# вимагає, щоб оператори типу «подібні» (тобто < та >, <= та >=, == та !=) перевантажувалися разом.|
|[]|Оператор [] не можна перевантажувати. Однак, як ви бачили раніше в цьому розділі, конструкція індексатора забезпечує таку ж функціональність.|
|()|Оператор () не можна перевантажувати. Однак, як ви побачите далі в цьому розділі, користувацькі методи перетворення забезпечують таку саму функціональність.|
|+=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=|Скорочені оператори присвоєння не можна перевантажувати; проте ви отримуєте їх безкоштовно, коли перевантажуєте відповідний бінарний оператор.|

## Перевантаження бінарних операторів

Щоб проілюструвати процес перевантаження бінарних операторів, припустимо, що наступний простий клас Point визначено в новому проекті консольної програми з назвою OperatorOverloading:

```cs
// Just a simple, everyday C# class.
public class Point
{
    public int X { get; set; }
    public int Y { get; set; }
    public Point(int xPos, int yPos)
    {
        X = xPos;
        Y = yPos;
    }
    public override string ToString()
      => $"[{X},{Y}]";
}
```
Тепер, логічно кажучи, має сенс «додавати» точки (Points). Наприклад, якщо ви додали дві змінні типу Point, ви повинні отримати нову змінну Point, яка є сумою значень X та Y. Звичайно, також може бути корисним відняти одну змінну Point від іншої.
Однак, у вашому Point зараз ви отримуватимете помилки під час компіляції, оскільки тип Point не знає, як реагувати на оператор + або -. Щоб забезпечити унікальну реакцію власного типу на внутрішні оператори, C# надає ключове слово operator, яке можна використовувати лише разом із ключовим словом static. Коли ви перевантажуєте бінарний оператор (наприклад, + та -), найчастіше ви передаватимете два аргументи того ж типу, що й визначальний клас (у цьому прикладі Point), як показано в наступному оновленні коду:

```cs
// A more intelligent Point type.
public class Point
{
    //...

    // Overloaded operator +.
    public static Point operator +(Point p1, Point p2)
      => new Point(p1.X + p2.X, p1.Y + p2.Y);
    // Overloaded operator -.
    public static Point operator -(Point p1, Point p2)
      => new Point(p1.X - p2.X, p1.Y - p2.Y);
}
```
Логіка оператора + полягає в тому, щоб просто повернути новий об'єкт Point на основі підсумовування полів вхідних параметрів Point.

Логіка оператора + полягає в тому, щоб просто повернути новий об'єкт Point на основі підсумовування полів вхідних параметрів Point. Таким чином, коли ви пишете pt1 + pt2, під капотом ви можете уявити собі наступний прихований виклик статичного методів операторів :
```cs
// Pseudo-code: Point p3 = Point.operator+ (p1, p2)
Point p3 = p1 + p2;
// Pseudo-code: Point p4 = Point.operator- (p1, p2)
Point p4 = p1 - p2;
```
З цим оновленням ваша програма тепер компілюється, і ви можете додавати та віднімати об'єкти Point, як показано в наступному виводі:

```cs
static void UsingPointWithOperators()
{
    // Make two points.
    Point ptOne = new Point(100, 100);
    Point ptTwo = new Point(40, 40);
    Console.WriteLine($"ptOne = {ptOne}");
    Console.WriteLine($"ptTwo = {ptTwo}");
    // Add the points to make a bigger point?
    Console.WriteLine($"ptOne + ptTwo: {ptOne + ptTwo}");
    // Subtract the points to make a smaller point?
    Console.WriteLine($"ptOne - ptTwo: {ptOne - ptTwo}");
}
UsingPointWithOperators();
```
```
ptOne = [100,100]
ptTwo = [40,40]
ptOne + ptTwo: [140,140]
ptOne - ptTwo: [60,60]
```
Під час перевантаження бінарного оператора не потрібно передавати два параметри одного типу. Якщо це має сенс, один з аргументів може відрізнятися. Наприклад, ось перевантажений оператор +, який дозволяє викликаючій особі отримати новий об'єкт Point на основі числового коригування:

```cs
public class Point
{
    //...
    public static Point operator +(Point p1, int change)
    => new Point(p1.X + change, p1.Y + change);
    public static Point operator +(int change, Point p1)
      => new Point(p1.X + change, p1.Y + change);
}
```
Зверніть увагу, що вам потрібні обидві версії методу, якщо ви хочете, щоб аргументи передавалися в будь-якому порядку (тобто ви не можете просто визначити один із методів і очікувати, що компілятор автоматично підтримуватиме інший). Тепер ви можете використовувати ці нові версії оператора + наступним чином:

```cs
    Point point = new Point(100, 100);
    Console.WriteLine($"point = {point}");
    Console.WriteLine($"point + 10 = {point+10}");
    Console.WriteLine($"10 + point = {10+point}");
```
```
point = [100,100]
point + 10 = [110,110]
10 + point = [110,110]
```