# Знайомство з C# та .NET

Платформа .NET від Microsoft та мова програмування C# були офіційно представлені приблизно у 2002 році та швидко стали основою сучасної розробки програмного забезпечення. Платформа .NET дозволяє мовам програмування (включаючи C#, F# та  VB.NET) взаємодіяти одна з одною.

У 2016 році Microsoft офіційно запустила .NET Core. Як і .NET, .NET Core дозволяє мовам програмування взаємодіяти одна з одною (хоча підтримується обмежена кількість мов). Що ще важливіше, цей новий фреймворк більше не обмежується операційною системою Windows, але також може працювати на iOS та Linux, а також розроблятися на MacOS та Linux. Ця незалежність від платформи відкрила .NET та C# для набагато ширшого кола розробників. Хоча кросплатформне використання C# підтримувалося і до появи .NET Core, це було завдяки різним іншим фреймворкам, таким як проект Mono.

    З виходом .NET 5 частину назви «Core» було вилучено. У цій документації термін .NET стосується .NET Core (до версії 3.1) та .NET до 6+.

Мета цього тексту подвійна. Перше завдання — надати вам глибокий та детальний огляд синтаксису та семантики C#. Другий (не менш важливий) крок – проілюструвати використання численних фреймворків для розробки .NET. До них належать доступ до бази даних за допомогою ADO.NET та Entity Framework (EF) Core, інтерфейси користувача з Windows Presentation Foundation (WPF) і, нарешті, RESTful сервіси та веб-додатки з ASP.NET Core. Як то кажуть, подорож у тисячу миль починається з одного кроку; і з цим я вітаю вас у розділі 1.

Цей перший розділ закладає концептуальну основу для решти. Тут ви знайдете загальне обговорення низки тем, пов'язаних з .NET, таких як збірки, Common Intermediate Language (CIL) та компіляція just-in-time (JIT). Окрім попереднього ознайомлення з деякими ключовими словами мови програмування C#, ви також зрозумієте взаємозв'язок між середовищем виконання .NET, системою типів Common Type System (CTS) та специфікацією Common Language Specification (CLS). 
У цьому розділі також наведено огляд функціональності, що надається бібліотеками базових класів .NET, які іноді скорочено називають BCL. Тут ви отримаєте огляд незалежності платформи .NET від мови програмування та платформи. Як і слід було очікувати, ці теми детальніше розглядаються в решті цього тексту.

# Огляд деяких ключових переваг платформи .NET

Фреймворк .NET — це програмна платформа для створення веб-додатків та сервісів для операційних систем Windows, iOS та Linux, а також додатків WinForms та WPF в операційних системах Windows. Щоб підготувати основу, ось короткий огляд деяких основних функцій, що надаються завдяки .NET:


    Підтримка численних мов програмування: .NET-додатки можна створювати за допомогою мов програмування C#, F# та VB.NET (причому C# та F# є основними мовами для ASP.NET Core).
    
    Спільний середовище виконання, що використовується всіма мовами .NET: одним із аспектів цього механізму є чітко визначений набір типів, які розуміє кожна мова .NET.

    Комплексна бібліотека базових класів: ця бібліотека надає тисячі попередньо визначених типів, які дозволяють створювати бібліотеки коду, прості термінальні програми, графічні настільні програми та веб-сайти корпоративного рівня.

    Спрощена модель розгортання: бібліотеки .NET не реєструються в системному реєстрі. Крім того, платформа .NET дозволяє кільком версіям фреймворку, а також додаткам існувати гармонійно на одній машині.

    Розширена підтримка командного рядка: Інтерфейс командного рядка (CLI) .NET — це кросплатформний ланцюжок інструментів для розробки та пакування .NET-застосунків. Додаткові інструменти можна встановити (глобально або локально) окрім стандартних інструментів, що постачаються з .NET SDK.

Ви побачите кожну з цих тем (та багато інших) розглянутими в наступних главах. Але спочатку мені потрібно пояснити життєвий цикл підтримки для .NET.

# Розуміння життєвого циклу підтримки .NET

Версії .NET випускаються набагато частіше, ніж попередні версії .NET Framework. З огляду на наявність усіх цих випусків, може бути важко встигати за всім, особливо в середовищі корпоративної розробки. Щоб краще визначити життєвий цикл підтримки релізів, Microsoft запровадила варіацію Моделі довгострокової підтримки(Long-Term Support Model), яка зазвичай використовується сучасними фреймворками з відкритим кодом.
Релізи з довгостроковою підтримкою (LTS) – це основні релізи, які підтримуватимуться протягом тривалого періоду часу. Протягом усього терміну служби вони отримуватимуть лише критичні та/або непорушні виправлення. До завершення терміну служби версії LTS будуть змінені на такі, що потребують обслуговування. Релізи LTS з .NET підтримуватимуться протягом наступних періодів часу, залежно від того, який з них довший:

    Через три роки після першого випуску

    Один рік технічної підтримки після наступного випуску LTS

Корпорація Майкрософт вирішила назвати випуски короткострокової підтримки Standard Term Support, тобто інтервальні випуски між основними випусками LTS. Вони підтримуються протягом шести місяців після наступного випуску Current або LTS.

Важливо перевіряти політику підтримки для кожної нової версії .NET, яка випускається. Наявність лише більшого числа не обов’язково означає, що воно буде підтримуватися довгостроково. Це можна знайти за запитом ".NET Support Policy"

# Огляд структурних елементів платформи .NET

Тепер, коли ви знаєте деякі основні переваги .NET, давайте розглянемо ключові (та взаємопов'язані) теми, які роблять все це можливим: середовище виконання .NET(.NET Runtime), CTS та CLS. З точки зору програміста, .NET можна розуміти як середовище виконання та комплексну бібліотеку базових класів. Рівень середовища виконання містить набір мінімальних реалізацій, що безпосередньо пов'язані з платформою (Windows, iOS, Linux) та архітектурою (x86, x64, ARM), а також усі базові типи для .NET.
Ще одним структурним блоком платформи .NET є Загальна система типів (Common Type System, CTS). Специфікація CTS повністю описує всі можливі типи даних та всі програмні конструкції, що підтримуються середовищем виконання, визначає, як ці сутності можуть взаємодіяти одна з одною, та детально описує, як вони представлені у форматі метаданих .NET.
Загальномовна специфікація, або CLS, – це пов'язана специфікація, яка визначає підмножину загальних типів та програмних конструкцій, з якими можуть узгоджуватися всі мови програмування .NET. Таким чином, якщо ви створюєте типи .NET, які надають лише функції, сумісні з CLS, ви можете бути впевнені, що всі мови .NET можуть їх використовувати. І навпаки, якщо ви використовуєте тип даних або програмну конструкцію, що знаходиться поза межами CLS, ви не можете гарантувати, що кожна мова програмування .NET зможе взаємодіяти з вашою бібліотекою коду .NET. На щастя, як ви побачите далі в цьому розділі, легко наказати компілятору C# перевірити весь ваш код на відповідність CLS.

## Роль бібліотек базових класів

Платформа .NET також надає набір бібліотек базових класів (BCL), доступних для всіх мов програмування .NET. Ця бібліотека базових класів не лише інкапсулює різні примітиви, такі як потоки, введення/виведення файлів (I/O), системи графічного рендерингу та взаємодія з різними зовнішніми апаратними пристроями, але й забезпечує підтримку низки сервісів, необхідних для більшості реальних програм.
Бібліотеки базових класів визначають типи, які можна використовувати для створення будь-якого типу програмного застосунку та для взаємодії компонентів застосунку один з одним.

## Роль .NET Standard

Кількість бібліотек базових класів у .NET Framework значно перевищує їх кількість у .NET. Це зрозуміло, оскільки .NET Framework мав 14-річну перевагу над .NET. Ця невідповідність створювала проблеми під час спроби використання коду .NET Framework з кодом .NET. Рішенням (і вимогою) для взаємодії .NET Framework/.NET Core 3.1 є .NET Standard.
Стандарт .NET – це специфікація, яка визначає доступність API .NET та бібліотек базових класів, які мають бути доступні в кожній реалізації. Стандарт дозволяє реалізувати такі сценарії:

    Визначає єдиний набір BCL API для всіх реалізацій .NET, незалежно від робочого навантаження

    Дозволяє розробникам створювати портативні бібліотеки, які можна використовувати в різних реалізаціях .NET, використовуючи той самий набір API.

    Зменшує або навіть усуває умовну компіляцію спільного вихідного коду через .NET API, лише для ОС API

C# 9+ працюватиме лише на .NET 5+ або .NET Standard 2.1, а .NET Standard 2.1 недоступний для .NET Framework.

## Що пропонує C#

C# — це мова програмування, основний синтаксис якої дуже схожий на синтаксис Java. Однак називати C# клоном Java неточно. Насправді, і C#, і Java є членами сімейства мов програмування C (наприклад, C, Objective-C, C++) і, отже, мають схожий синтаксис. 
Правда полягає в тому, що багато синтаксичних конструкцій C# змодельовані за різними аспектами Visual Basic (VB) та C++. Наприклад, як і VB, C# підтримує поняття властивостей класу (на відміну від традиційних методів отримання та встановлення) та необов'язкових параметрів. Як і C++, C# дозволяє перевантажувати оператори, а також створювати структури, перелічення та функції зворотного виклику (через делегати).
Більше того, опрацьовуючи цей текст, ви швидко побачите, що C# підтримує низку функцій, таких як лямбда-вирази та анонімні типи, які традиційно зустрічаються в різних функціональних мовах (наприклад, LISP або Haskell). Крім того, з появою інтегрованих запитів (LINQ), C# підтримує низку конструкцій, що робить його досить унікальним у ландшафті програмування. Тим не менш, основна частина C# справді знаходиться під впливом мов на основі C.
Оскільки C# є гібридом багатьох мов програмування, результатом є продукт, який є таким же синтаксично чистим, як (якщо не чистішим), як Java, що забезпечує майже стільки ж потужності та гнучкості, скільки й C++. Ось частковий список основних функцій C#, які є у всіх версіях мови:

    Вказівники не потрібні! Програми на C# зазвичай не потребують прямої маніпуляції вказівниками (хоча ви можете опуститися до цього рівня, якщо це абсолютно необхідно).

    Автоматичне керування пам'яттю за допомогою збирання сміття. З огляду на це, C# не підтримує ключове слово delete.

    Формальні синтаксичні конструкції для класів, інтерфейсів, структур, перерахувань та делегатів.

    Можливість перевантажувати оператори для власного типу, подібна до C++, без складнощів.

    Підтримка програмування на основі атрибутів. Цей вид розробки дозволяє анотувати типи та їхні члени, щоб додатково уточнити їхню поведінку. Наприклад, якщо ви позначите метод атрибутом [Obsolete], програмісти побачать ваше власне попередження, яке виведеться, якщо вони спробують використати декорований член.

C# — це вже потужна мова програмування, яка в поєднанні з .NET дозволяє створювати широкий спектр типів застосунків.

## Керований та некерований код

Важливо зазначити, що мову C# можна використовувати лише для створення програмного забезпечення, яке розміщено в середовищі виконання .NET (ви ніколи не зможете використовувати C# для створення власного COM-сервера або некерованої програми в стилі C/C++). Офіційно кажучи, термін, який використовується для опису коду, орієнтованого на середовище виконання .NET, називається керованим кодом. Бінарний блок, що містить керований код, називається збіркою (докладніше про збірки трохи пізніше). І навпаки, код, який не може бути безпосередньо розміщений середовищем виконання .NET, називається некерованим кодом.
Як згадувалося раніше, платформа .NET може працювати на різних операційних системах. Таким чином, цілком можливо створити програму C# на комп'ютері з Windows та запустити її на комп'ютері з iOS, використовуючи середовище виконання .NET. Також ви можете створити програму на C# у Linux за допомогою Visual Studio Code та запустити програму у Windows.
За допомогою Visual Studio для Mac ви також можете створювати .NET-додатки на Mac для запуску на Windows, macOS або Linux.
До некерованого коду все ще можна отримати доступ з програми на C#, але це прив'язує вас до певної цільової області розробки та розгортання.

# Огляд збірок .NET

Незважаючи на те, що бінарні файли .NET мають те саме розширення файлу, що й некеровані бінарні файли Windows (*.dll), вони не мають абсолютно жодної внутрішньої подібності. Зокрема, бінарні файли .NET не містять специфічних для платформи інструкцій, а містять платформо-незалежну проміжну мову Intermediate Language (IL) та метадані типу.

    IL також відомий як проміжна мова Microsoft (MSIL) або Common Intermediate Language (CIL). Таким чином, читаючи літературу з .NET, розумійте, що IL, MSIL та CIL описують по суті одну й ту саму концепцію. У цій книзі я використовуватиму скорочення CIL для позначення цього низькорівневого набору інструкцій.

Коли *.dll створюється за допомогою компілятора .NET, бінарний blob-об'єкт називається збіркою. Щоб полегшити поточне обговорення, вам потрібно зрозуміти чотири основні властивості цього нового формату файлів.

По-перше, на відміну від збірок .NET Framework, які можуть бути як *.dll, так і *.exe, проекти .NET завжди компілюються у файл із розширенням .dll, навіть якщо проект є виконуваним файлом. Виконувані збірки .NET виконуються за допомогою команди dotnet <назва збірки>.dll. Команда dotnet.exe копіюється до каталогу збірки та перейменовується на <назва збірки>.exe. Виконання цієї команди автоматично викликає файл dotnet <назва збірки>.dll, виконуючи еквівалент dotnet <назва збірки>.dll. Файл *.exe з назвою вашого проєкту насправді не є кодом вашого проєкту; це зручний спосіб запуску вашої програми.
Вашу програму можна скоротити до одного файлу, який виконується безпосередньо. Хоча цей єдиний файл виглядає та поводиться як виконуваний файл у стилі C++, він зручний для пакування. Він містить усі файли, необхідні для запуску вашої програми, можливо, навіть саме середовище виконання .NET! Але пам’ятайте, що ваш код все ще виконується в керованому контейнері, так само, як якщо б він був опублікований як кілька файлів.

По-друге, збірка містить CIL-код, який концептуально схожий на байт-код Java тим, що він не компілюється в інструкції, специфічні для платформи, доки це не стане абсолютно необхідним. Зазвичай, «абсолютно необхідним» є момент, коли середовище виконання .NET посилається на блок інструкцій CIL (наприклад, реалізацію методу) для використання.

По-третє, збірки також містять метадані, які детально описують характеристики кожного «типу» в двійковому файлі. Наприклад, якщо у вас є клас з назвою SportsCar, метадані типу описують такі деталі, як базовий клас SportsCar, вказують, які інтерфейси реалізовані SportsCar (якщо такі є), та надають повний опис кожного члена, що підтримується типом SportsCar. Метадані .NET завжди присутні в збірці та автоматично генеруються компілятором мови.

Зрештою, окрім CIL та метаданих типів, самі збірки також описуються за допомогою метаданих, які офіційно називаються маніфестом. Маніфест містить інформацію про поточну версію збірки, інформацію про культуру (використовується для локалізації рядкових та образних ресурсів) та список усіх зовнішніх збірок, необхідних для належного виконання. Протягом наступних кількох розділів ви розглянете різні інструменти, які можна використовувати для перевірки типів, метаданих та інформації маніфесту збірки.

## Роль спільної проміжної мови програмування (Common Intermediate Language)

Давайте детальніше розглянемо код CIL, метадані типів та маніфест збірки. CIL — це мова програмування, яка розташована над будь-яким набором інструкцій, специфічним для певної платформи. Наприклад, наступний код на C# моделює тривіальний калькулятор. Не переймайтеся зараз точним синтаксисом, але зверніть увагу на формат методу Add() у класі Calc.

Calc.cs
```cs
class Calc
{
  public int Add(int addend1, int addend2)
  {
    return addend1 + addend2;
  }
}
```

Program.cs
```cs
using Calculator;

Calc c = new Calc();
int ans = c.Add(10, 84);
Console.WriteLine("10 + 84 is {0}.", ans);
//Wait for user to press the Enter key
Console.ReadLine();
```
Компіляція цього коду створює файл збірки *.dll, який містить маніфест, інструкції CIL та метадані, що описують кожен аспект класів Calc та Program. 

Наприклад, якщо ви виведете IL з цієї збірки за допомогою ildasm.exe (розглянуто далі в цьому розділі), ви побачите, що метод Add() представлений за допомогою CIL, ось так:

```
  .method public hidebysig instance int32 Add(int32 addend1,
              int32 addend2) cil managed
  {
    // Method begins at RVA 0x2090
    // Code size       9 (0x9)
    .maxstack  2
    .locals /*11000002*/ init (int32 V_0)
    IL_0000:  /* 00   |                  */ nop
    IL_0001:  /* 03   |                  */ ldarg.1
    IL_0002:  /* 04   |                  */ ldarg.2
    IL_0003:  /* 58   |                  */ add
    IL_0004:  /* 0A   |                  */ stloc.0
    IL_0005:  /* 2B   | 00               */ br.s       IL_0007
    IL_0007:  /* 06   |                  */ ldloc.0
    IL_0008:  /* 2A   |                  */ ret
  } // end of method Calc::Add
```
Не хвилюйтеся, якщо ви не можете зрозуміти логіку отриманого CIL для цього методу. Слід зосередитися на тому, що компілятор C# генерує CIL, а не інструкції, специфічні для платформи.

Тепер нагадаємо, що це стосується всіх компіляторів .NET. Для ілюстрації припустимо, що ви створили цю саму програму за допомогою F#, а не C#.

```fs
// Learn more about F# at http://fsharp.org
// Calc.fs
open System
module Calc =
    let add addend1 addend2 =
        addend1 + addend2
[<EntryPoint>]
let main argv =
    let ans = Calc.add 10 84
    printfn '10 + 84 is %d' ans
    Console.ReadLine()
    0
```
Якщо ви переглянете CIL для методу Add(), то знову знайдете схожі інструкції (трохи змінені компілятором F#).

```
  .method public instance int32  Add(int32 addend1,
                                     int32 addend2) cil managed
  {
    // Code size       9 (0x9)
    .maxstack  2
    .locals init (int32 V_0)
    IL_0000:  nop
    IL_0001:  ldarg.1
    IL_0002:  ldarg.2
    IL_0003:  add.ovf
    IL_0004:  stloc.0
    IL_0005:  br.s       IL_0007
    IL_0007:  ldloc.0
    IL_0008:  ret
  } // end of method Calc::Add
```

## Переваги CIL

На цьому етапі ви можете задатися питанням, що саме отримується від компіляції вихідного коду в CIL, а не безпосередньо в певний набір інструкцій. Однією з переваг є інтеграція мов. Як ви вже бачили, кожен компілятор .NET створює майже ідентичні CIL-інструкції. Таким чином, усі мови можуть взаємодіяти в межах чітко визначеної двійкової області.
Враховуючи, що CIL не залежить від платформи, сам .NET також є платформо-агностичним, надаючи ті ж переваги, до яких звикли розробники Java (наприклад, єдину базу коду, що працює на численних операційних системах). Фактично, для мови C# існує міжнародний стандарт.

## Компіляція CIL у платформно-специфічні інструкції

Оскільки збірки містять інструкції CIL, а не платформно-специфічні інструкції, код CIL має бути компілований на льоту перед використанням. Сутність, яка компілює CIL-код у змістовні інструкції процесора, — це JIT-компілятор, який іноді називають дружньою назвою jitter. Середовище виконання .NET використовує JIT-компілятор для кожного процесора, орієнтованого на середовище виконання, кожен з яких оптимізований для базової платформи.
Наприклад, якщо ви створюєте .NET-застосунок для розгортання на портативному пристрої (наприклад, телефоні iOS або Android), відповідний jitter добре підійде для роботи в середовищі з низьким обсягом пам'яті. З іншого боку, якщо ви розгортаєте свою збірку на сервері компанії (де пам'ять рідко є проблемою), jitter буде оптимізовано для функціонування в середовищі з великим обсягом пам'яті. Таким чином, розробники можуть написати єдиний тіло коду, який можна ефективно JIT-компілювати та виконувати на машинах з різною архітектурою.
Крім того, коли jitter компілює інструкції CIL у відповідний машинний код, результати кешуються в пам'яті у спосіб, що підходить для цільової операційної системи. Таким чином, якщо викликається метод з іменем PrintDocument(), інструкції CIL компілюються в інструкції, специфічні для платформи, під час першого виклику та зберігаються в пам'яті для подальшого використання. Тому наступного разу, коли викликається PrintDocument(), немає потреби перекомпілювати CIL.

## Роль метаданих типів .NET

Окрім інструкцій CIL, збірка .NET містить повні, вичерпні та точні метадані, які описують кожен тип (наприклад, клас, структуру, перерахування), визначений у двійковому файлі, а також членів кожного типу (наприклад, властивості, методи, події). На щастя, завданням компілятора (а не програміста) завжди є створення найновіших та найкращих метаданих типів. Оскільки метадані .NET настільки ретельно продумані, збірки є повністю самоописуючими сутностями. 
Щоб проілюструвати формат метаданих типу .NET, давайте розглянемо метадані, які були згенеровані для методу Add() класу C# Calc, який ви розглядали раніше.

```
// TypeDef #2 (02000003)
// -------------------------------------------------------
//   TypDefName: Calc  (02000003)
//   Flags     : [NotPublic] [AutoLayout] [Class] [AnsiClass] [BeforeFieldInit]  (00100000)
//   Extends   : 0100000D [TypeRef] System.Object
//   Method #1 (06000003)
//   -------------------------------------------------------
//     MethodName: Add (06000003)
//     Flags     : [Public] [HideBySig] [ReuseSlot]  (00000086)
//     RVA       : 0x00002090
//     ImplFlags : [IL] [Managed]  (00000000)
//     CallCnvntn: [DEFAULT]
//     hasThis
//     ReturnType: I4
//     2 Arguments
//       Argument #1:  I4
//       Argument #2:  I4
//     2 Parameters
//       (1) ParamToken : (08000002) Name : addend1 flags: [none] (00000000)
//       (2) ParamToken : (08000003) Name : addend2 flags: [none] (00000000)
```
Метадані використовуються численними аспектами середовища виконання .NET, а також різними інструментами розробки. Наприклад, функція IntelliSense, що надається такими інструментами, як Visual Studio, стає можливою завдяки зчитуванню метаданих збірки під час проектування. Метадані також використовуються різними утилітами перегляду об'єктів, інструментами налагодження та самим компілятором C#. Безперечно, метадані є основою численних технологій .NET, включаючи рефлексію, пізнє зв'язування та серіалізацію об'єктів.

## Роль маніфесту збірки

І останнє, але не менш важливе: пам’ятайте, що збірка .NET також містить метадані, які описують саму збірку (технічно називаються маніфестом). Серед інших деталей, маніфест документує всі зовнішні збірки, необхідні поточній збірці для правильного функціонування, номер версії збірки, інформацію про авторські права тощо. Як і у випадку з метаданими типу, компілятор завжди відповідає за генерацію маніфесту збірки. Ось деякі відповідні деталі маніфесту, що генерується під час компіляції файлу коду Calc.cs, показаного раніше в цьому розділі:

```
.assembly extern /*23000001*/ System.Runtime
{
  .publickeytoken = (B0 3F 5F 7F 11 D5 0A 3A )                         // .?_....:
  .ver 6:0:0:0
}
.assembly extern /*23000002*/ System.Console
{
  .publickeytoken = (B0 3F 5F 7F 11 D5 0A 3A )                         // .?_....:
  .ver 6:0:0:0
}
.assembly /*20000001*/ Calc.Cs
{
  .hash algorithm 0x00008004
  .ver 1:0:0:0
}
.module Calc.Cs.dll
.imagebase 0x00400000
.file alignment 0x00000200
.stackreserve 0x00100000
.subsystem 0x0003       // WINDOWS_CUI
.corflags 0x00000001    //  ILONLY
```
Коротко кажучи, маніфест документує набір зовнішніх збірок, необхідних для Calc.dll (через директиву .assembly extern), а також різні характеристики самої збірки (наприклад, номер версії, назва модуля).

# Розуміння системи загальних типів Common Type System (CTS)

Збірка може містити будь-яку кількість різних типів. У світі .NET тип – це просто загальний термін, що використовується для позначення члена з множини {клас, інтерфейс, структура, перерахування, делегат}. Під час створення рішень за допомогою мови .NET ви, найімовірніше, взаємодіятимете з багатьма з цих типів. Наприклад, ваша збірка може визначати один клас, який реалізує певну кількість інтерфейсів. Можливо, один із методів інтерфейсу приймає тип перерахування як вхідний параметр і повертає структуру викликаючій функції.
Нагадаємо, що CTS – це формальна специфікація, яка документує, як типи мають бути визначені для розміщення в середовищі виконання .NET. Зазвичай, єдиними людьми, які глибоко стурбовані внутрішньою роботою CTS, є ті, хто розробляє інструменти та/або компілятори, орієнтовані на платформу .NET. Однак, для всіх програмістів .NET важливо навчитися працювати з п'ятьма типами, визначеними CTS, у вибраній ними мові. Нижче наведено короткий огляд.

## Тип CTS class

.NET підтримує поняття типу класу, яке є основою об'єктно-орієнтованого програмування (ООП). Клас може складатися з будь-якої кількості членів (таких як конструктори, властивості, методи та події) та точок даних (полів). У C# класи оголошуються за допомогою ключового слова class, ось так:

```cs
// A C# class type with 1 method.
class Calc
{
  public int Add(int addend1, int addend2)
  {
    return addend1 + addend2;
  }
}
```
В окремомій секції розпочнеться ваше формальне розгляд створення типів класів за допомогою C#; проте в таблиці документовано низку характеристик, що стосуються типів класів.

Характеристики класу CTS

|Характеристика класу|Опис|
|--------------------|----|
|Клас sealed(запечатаний)?|Запечатані класи не можуть функціонувати як базовий клас для інших класів.|
|Чи реалізує клас якісь інтерфейси?|Інтерфейс — це набір абстрактних членів, що забезпечує контракт між об'єктом та користувачем об'єкта. CTS дозволяє класу реалізувати будь-яку кількість інтерфейсів.|
|Клас абстрактний чи конкретний?|Екземпляр абстрактні класи не можна створювати безпосередньо, але вони призначені для визначення загальної поведінки похідних типів. Екземпляр конкретні класи можна створювати безпосередньо. |
|Яка видимість цього класу?|Кожен клас має бути налаштований за допомогою ключового слова видимості, такого як public або internal. По суті, це визначає, чи може клас використовуватися зовнішніми збірками, чи лише зсередини збірки, що його визначає.|

## Тип CTS interface 

Інтерфейси — це не що інше, як іменована колекція абстрактних визначень членів та/або реалізацій за замовчуванням, які реалізуються (необов'язково у випадку реалізацій за замовчуванням) заданим класом або структурою. У C# типи інтерфейсів визначаються за допомогою ключового слова interface. За домовленістю, всі інтерфейси .NET починаються з великої літери I, як у наступному прикладі:

```cs
// A C# interface type is usually
// declared as public, to allow types in other
// assemblies to implement their behavior.
public interface IDraw
{
  void Draw();
}
```

Самі по собі інтерфейси мало корисні. Однак, коли клас або структура реалізує заданий інтерфейс своїм унікальним способом, ви можете запитувати доступ до наданої функціональності, використовуючи посилання на інтерфейс поліморфним чином. Програмування на основі інтерфейсів буде повністю розглянуто окремій главі.

## Тип CTS struct

Концепція структури також формалізована в рамках CTS. Структуру можна розглядати як легкий тип класу, що має семантику, що базується на значеннях. Зазвичай структури найкраще підходять для моделювання геометричних та математичних даних і створюються в C# за допомогою ключового слова struct наступним чином:

```cs
// A C# structure type.
struct Point
{
  // Structures can contain fields.
  public int xPos, yPos;
  // Structures can contain parameterized constructors.
  public Point(int x, int y)
  { xPos = x; yPos = y;}
  // Structures may define methods.
  public void PrintPosition()
  {
    Console.WriteLine('({0}, {1})', xPos, yPos);
  }
}
```

## Тип CTS enum

Перерахування – це зручна програмна конструкція, яка дозволяє групувати пари «ім'я-значення». Наприклад, припустимо, що ви створюєте відеогру, яка дозволяє гравцеві вибирати з трьох категорій персонажів (Чарівник, Боєць або Злодій). Замість того, щоб відстежувати прості числові значення для представлення кожної можливості, ви можете створити строго типізований перелік за допомогою ключового слова enum.

```cs
// A C# enumeration type.
enum CharacterTypeEnum
{
  Wizard = 100,
  Fighter = 200,
  Thief = 300
}
```
За замовчуванням сховище, яке використовується для зберігання кожного елемента, є 32-бітовим цілим числом; однак, за потреби можна змінити цей слот сховища (наприклад, під час програмування для пристрою з низьким обсягом пам'яті, такого як мобільний пристрій). Також CTS вимагає, щоб перелічувані типи походили від спільного базового класу System.Enum. Як ви побачите, цей базовий клас визначає низку цікавих членів, які дозволяють вам програмно витягувати, маніпулювати та трансформувати базові пари ім'я-значення.

## Тип CTS делегат

Делегати є .NET еквівалентом типобезпечного вказівника функції в стилі C. Ключова відмінність полягає в тому, що делегат .NET — це клас, що походить від System.MulticastDelegate, а не простий вказівник на необроблену адресу пам'яті. У C# делегати оголошуються за допомогою ключового слова delegate.

```cs
// This C# delegate type can 'point to' any method
// returning an int and taking two ints as input.
delegate int BinaryOp(int x, int y);
```
Делегати є критично важливими, коли ви хочете надати спосіб для одного об'єкта переадресовувати виклик до іншого об'єкта та забезпечити основу для архітектури подій .NET. Як ви побачите, делегати мають вбудовану підтримку багатоадресної розсилки (тобто пересилання запиту кільком одержувачам) та асинхронних викликів методів (тобто виклику методу у вторинному потоці).

## Члени типу CTS

Тепер, коли ви попередньо ознайомилися з кожним із типів, формалізованих CTS, зрозумійте, що більшість типів приймають будь-яку кількість членів. Формально кажучи, член типу обмежений множиною {конструктор, фіналізатор, статичний конструктор, вкладений тип, оператор, метод, властивість, індексатор, поле, поле лише для читання, константа, подія}.
CTS визначає різні додатки, які можуть бути пов'язані з певним членом. Наприклад, кожен член має задану ознаку видимості (наприклад, публічний, приватний, захищений). Деякі члени можуть бути оголошені як абстрактні (для забезпечення поліморфної поведінки похідних типів), а також віртуальні (для визначення шаблонної, але перевизначуваної реалізації). Також більшість членів можуть бути налаштовані як статичні (зв'язані на рівні класу) або екземпляри (зв'язані на рівні об'єкта). Створення членів типу розглядається протягом наступних кількох розділів. Мова C# також підтримує створення узагальнених типів та узагальнених членів.

## Внутрішні типи даних CTS

Останній аспект CTS, про який слід знати на даний момент, полягає в тому, що він встановлює чітко визначений набір фундаментальних типів даних. Усі ключові слова мови .NET зрештою призводять до одного й того ж типу CTS, визначеного в збірці з назвою mscorlib.dll. Розглянемо таблицю , яка документує, як ключові типи даних CTS виражаються в C#.

|Тип даних CTS|Ключове слово C#|
|-------------|----------------|
|System.Byte|byte|
|System.SByte|sbyte|
|System.Int16|short|
|System.Int32|int|
|System.Int64|long|
|System.UInt16|ushort|
|System.UInt32|uint|
|System.UInt64|ulong|
|System.Single|float|
|System.Double|double|
|System.Object|object|
|System.Char|char|
|System.String|string|
|System.Decimal|decimal|
|System.Boolean|bool|

Розгляньте наступні фрагменти коду, які визначають 32-бітні числові змінні в C#  використовуючи ключові слова мови, а також формальний тип даних CTS:

```cs
// Define some 'ints' in C#.
int i = 0;
System.Int32 j = 0;
```

# Розуміння специфікації загальної мови Common Language Specification (CLS)

Як ви знаєте, різні мови виражають однакові програмні конструкції унікальними, специфічними для кожної мови термінами. Наприклад, у C# конкатенація рядків позначається оператором плюс (+), тоді як у VB зазвичай використовується амперсанд (&). Навіть коли дві різні мови виражають одну й ту саму програмну ідіому (наприклад, функцію без повертаного значення), є велика ймовірність, що синтаксис на перший погляд виглядатиме зовсім інакше.

```cs
// C# method returning nothing.
public void MyMethod()
{
  // Some interesting code...
}
```
```vb
' VB method returning nothing.
Public Sub MyMethod()
  ' Some interesting code...
End Sub
```
Як ви вже бачили, ці незначні синтаксичні варіації несуттєві з точки зору середовища виконання .NET, враховуючи, що відповідні компілятори (у цьому випадку csc.exe або vbc.exe) генерують подібний набір інструкцій CIL. Однак, мови також можуть відрізнятися загальним рівнем функціональності. Наприклад, мова .NET може мати або не мати ключового слова для представлення беззнакових даних, а також може підтримувати або не підтримувати типи вказівників. З огляду на ці можливі варіації, ідеальним було б мати базовий рівень, якому мають відповідати всі мови .NET.
CLS – це набір правил, що детально описують мінімальний та повний набір функцій, які повинен підтримувати певний компілятор .NET для створення коду, який може розміщуватися середовищем виконання .NET, і водночас бути доступним однаково всіма мовами програмування, орієнтованими на платформу .NET. У багатьох відношеннях CLS можна розглядати як підмножину повної функціональності, визначеної CTS. CLS — це, зрештою, набір правил, яких повинні дотримуватися розробники компіляторів, якщо вони хочуть, щоб їхні продукти безперебійно функціонували у всесвіті .NET. Кожному правилу присвоюється проста назва (наприклад, Правило 6 CLS) і описується, як це правило впливає на тих, хто створює компілятори, а також на тих, хто (певним чином) взаємодіє з ними. Найкращим правилом CLS є Правило 1.

    Правило 1: Правила CLS застосовуються лише до тих частин типу, які надаються за межами визначальної збірки.

Враховуючи це правило, можна (правильно) зробити висновок, що решта правил CLS не застосовуються до логіки, яка використовується для побудови внутрішньої роботи типу .NET. Єдиними аспектами типу, які повинні відповідати CLS, є самі визначення членів (тобто правила іменування, параметри та типи повернення). Логіка реалізації для члена може використовувати будь-яку кількість методів, відмінних від CLS, оскільки зовнішній світ не помітить різниці.
Для ілюстрації, наступний метод Add() у C# не сумісний зі стандартом CLS, оскільки параметри та значення, що повертаються, використовують беззнакові дані (що не є вимогою CLS):

```cs
class Calc
{
  // Exposed unsigned data is not CLS compliant!
  public ulong Add(ulong addend1, ulong addend2)
  {
    return addend1 + addend2;
  }
}
```
Однак, розглянемо наступний код, який використовує беззнакові дані внутрішньо в методі:

```cs
class Calc
{
  public int Add(int addend1, int addend2)
  {
    // As this ulong variable is only used internally,
    // we are still CLS compliant.
    ulong temp = 0;
    ...
    return addend1 + addend2;
  }
}
```
Клас все ще відповідає правилам CLS і може бути впевненим, що всі мови .NET можуть викликати метод Add().

Звичайно, окрім Правила 1, CLS визначає численні інші правила. Наприклад, CLS описує, як дана мова повинна представляти текстові рядки, як перерахування повинні бути представлені внутрішньо (базовий тип, що використовується для зберігання), як визначати статичні члени тощо. На щастя, вам не потрібно запам'ятовувати ці правила, щоб стати досвідченим розробником .NET. Знову ж таки, загалом, глибоке розуміння специфікацій CTS та CLS зазвичай цікавить лише розробників інструментів/компіляторів.

## Забезпечення відповідності CLS

Як ви побачите в цій книзі, C# визначає низку програмних конструкцій, які не сумісні з CLS. Гарна новина, однак, полягає в тому, що ви можете доручити компілятору C# перевірити ваш код на відповідність CLS за допомогою одного атрибута .NET.

```cs
// Tell the C# compiler to check for CLS compliance.
[assembly: CLSCompliant(true)]
```
Просто зрозумійте, що атрибут [CLSCompliant] накаже компілятору C# перевірити кожен рядок коду на відповідність правилам CLS. Якщо виявлено будь-які порушення CLS, ви отримаєте попередження компілятора та опис коду, що порушує правила.

# Розуміння середовища виконання .NET

Окрім специфікацій CTS та CLS, останнім елементом пазлу, з яким потрібно розібратися, є середовище виконання .NET. З програмної точки зору, термін «середовище виконання» можна розуміти як набір сервісів, необхідних для виконання заданого скомпільованого блоку коду. Наприклад, коли розробники Java розгортають програмне забезпечення на новому комп'ютері, їм потрібно переконатися, що на ньому встановлено віртуальну машину Java (JVM), щоб запустити їхнє програмне забезпечення.
Платформа .NET пропонує ще одну систему виконання. Ключова відмінність між середовищем виконання .NET та різними іншими середовищами виконання, які я щойно згадав, полягає в тому, що середовище виконання .NET надає єдиний, чітко визначений рівень середовища виконання, який спільно використовується всіма мовами та платформами, що використовують .NET.

# Розрізнення між збіркою, простором імен та типом

Кожен з нас розуміє важливість бібліотек коду. Мета бібліотек фреймворків полягає в тому, щоб надати розробникам чітко визначений набір існуючого коду для використання у своїх застосунках. Однак мова C# не постачається з окремою бібліотекою коду для певної мови. Натомість розробники C# використовують мовно-нейтральні бібліотеки .NET. Щоб усі типи в бібліотеках базових класів були добре організовані, платформа .NET широко використовує концепцію простору імен.
Простір імен — це група семантично пов'язаних типів, що містяться в збірці або, можливо, розподілені по кількох пов'язаних збірках. Наприклад, простір імен System.IO містить типи, пов'язані з файловим вводом/виводом, простір імен System.Data визначає основні типи баз даних тощо. Важливо зазначити, що одна збірка може містити будь-яку кількість просторів імен, кожен з яких може містити будь-яку кількість типів.
Ключова відмінність між цим підходом та бібліотекою, орієнтованою на певну мову, полягає в тому, що будь-яка мова, орієнтована на середовище виконання .NET, використовує ті самі простори імен та ті самі типи. Наприклад, наступні дві програми ілюструють повсюдно поширений додаток Hello World, написаний на C# та VB:

```cs
// Hello World in C#.
using System;
public class MyApp
{
  static void Main()
  {
    Console.WriteLine("Hi from C#");
  }
}
```
```vb
' Hello World in VB.
Imports System
Public Module MyApp
  Sub Main()
    Console.WriteLine("Hi from VB")
  End Sub
End Module
```
Зверніть увагу, що кожна мова використовує клас Console, визначений у просторі імен System. Окрім деяких очевидних синтаксичних відмінностей, ці програми виглядають і працюють дуже схоже, як фізично, так і логічно.
Зрозуміло, щойно ви освоїтеся з обраною вами мовою програмування .NET, вашою наступною метою як розробника .NET є ознайомлення з багатством типів, визначених у (численних) просторах імен .NET. Найфундаментальніший простір імен, з яким варто спочатку розібратися, називається System. Цей простір імен надає основний корпус типів, які вам як .NET-розробнику знадобляться знову і знову. Фактично, неможливо створити жодного функціонального застосунку на C#, хоча б не зробивши посилання на простір імен System, оскільки основні типи даних (наприклад, System.Int32, System.String) визначені тут.
У таблиці наведено короткий огляд деяких (але точно не всіх) просторів імен .NET, згрупованих за пов'язаною функціональністю.

|Простір імен .NET|Сенс в використані|
|-----------------|------------------|
|System|У System ви знайдете численні корисні типи, що стосуються внутрішніх даних, математичних обчислень, генерації випадкових чисел, змінних середовища та збирання сміття, а також низку поширених винятків та атрибутів.|
|System.Collections System.Collections.Generic|Ці простори імен визначають низку типів контейнерів запасів, а також базові типи та інтерфейси, які дозволяють створювати налаштовані колекції.|
|System.Data System.Data.Common System.Data.SqlClient|Ці простори імен використовуються для взаємодії з реляційними базами даних за допомогою ADO.NET.|
|System.IO System.IO.Compression System.IO.Ports|Ці простори імен визначають численні типи, що використовуються для роботи з файловим вводом/виводом, стисненням даних та маніпулюванням портами.|
|System.Reflection System.Reflection.Emit|Ці простори імен визначають типи, що підтримують виявлення типів під час виконання, а також динамічне створення типів.|
|System.Runtime.InteropServices|Цей простір імен надає можливості, що дозволяють типам .NET взаємодіяти з некерованим кодом (наприклад, DLL-файлами на основі C та COM-серверами) і навпаки.|
|System.Drawing System.Windows.Forms|Ці простори імен визначають типи, що використовуються для створення настільних застосунків за допомогою оригінального набору інструментів інтерфейсу користувача .NET (Windows Forms).|
|System.Windows System.Windows.Controls System.Windows.Shapes|Простір імен System.Windows є коренем для кількох просторів імен, що використовуються в застосунках Windows Presentation Foundation.|
|System.Windows.FormsSystem.Drawing|Простір імен System.Windows.Forms є коренем для кількох просторів імен, що використовуються в застосунках Windows Forms.|
|System.Linq System.Linq.Expressions|Ці простори імен визначають типи, що використовуються під час програмування з використанням LINQ API.|
|System.AspNetCore|Це один із багатьох просторів імен, що дозволяє створювати веб-застосунки ASP.NET Core та RESTful-сервіси.|
|System.Threading System.Threading.Tasks|Ці простори імен визначають численні типи для створення багатопотокових застосунків, які можуть розподіляти робочі навантаження між кількома процесорами.|
|System.Security|Безпека є інтегрованим аспектом всесвіту .NET. У просторах імен, орієнтованих на безпеку, ви знайдете численні типи, що стосуються дозволів, криптографії тощо.|
|System.Xml|Простори імен, орієнтовані на XML, містять численні типи, що використовуються для взаємодії з даними XML.|

## Програмний доступ до простору імен

Варто ще раз наголосити, що простір імен – це не що інше, як зручний спосіб для нас, простих людей, логічно розуміти та впорядковувати пов'язані типи. Розглянемо ще раз простір імен System. З вашої точки зору, можна припустити, що System.Console представляє клас з назвою Console, який міститься в просторі імен під назвою System. Однак, з точки зору середовища виконання .NET, це не так. Механізм виконання бачить лише один клас з назвою System.Console. 
У C# ключове слово using спрощує процес посилання на типи, визначені в певному просторі імен. Ось як це працює. Повертаючись до прикладу програми Calc, наведеного раніше в цьому розділі, на початку файлу є один оператор using.

```cs
using System;
```
Цей оператор є скороченням для активації цього рядка коду:

```cs
Console.WriteLine('10 + 84 is {0}.', ans);
```
Без оператора using код потрібно було б написати так:

```cs
System.Console.WriteLine('10 + 84 is {0}.', ans);
```
Хоча визначення типу за допомогою повного імені забезпечує кращу читабельність, я думаю, ви погодитеся, що ключове слово using у C# зменшує кількість натискань клавіш. У цьому тексті ми уникатимемо використання повних імен (якщо немає чіткої неоднозначності, яку потрібно вирішити) та оберемо спрощений підхід C# з використанням ключового слова using. Однак, завжди пам'ятайте, що ключове слово using — це просто скорочений запис для визначення повного імені типу, і будь-який підхід призводить до того самого базового CIL (враховуючи, що CIL-код завжди використовує повні імена) і не впливає на продуктивність чи розмір збірки.

## Глобальні оператори using

Під час створення складніших програм на C#, найімовірніше, простори імен повторюватимуться в кількох файлах. На простори імен можна посилатися глобально, і тоді вони будуть автоматично доступні в кожному файлі проєкту. Просто додайте ключове слово global перед вашими операторами using, ось так:

```cs
global using System;
```

    Усі глобальні оператори using повинні йти перед будь-якими неглобальними операторами using.

Рекомендується розміщувати глобальні оператори using разом з операторами верхнього рівня або в окремому файлі (наприклад, GlobalUsings.cs) для кращої видимості. Ви побачите багато прикладів цього в цьому тексті. Окрім розміщення глобальних операторів using у Program.cs (або окремому файлі), їх можна розмістити у файлі проекту для програми, використовуючи такий формат:

```xml
<ItemGroup>
  <Using Include=”System.Text” />
  <Using Include=”System.Text.Encodings.Web” />
  <Using Include=”System.Text.Json” />
  <Using Include=”System.Text.Json.Serialization” />
</ItemGroup>
```

## Неявні глобальні оператори using

В нових проектах вже є неявні глобальні оператори using. Неявні глобальні оператори using, що надаються , залежать від типу програми, яку ви створюєте. У таблиці перелічено типи програм та включені простори імен.

|Тип застосунку .NET|Простори імен, що охоплюються неявними глобальними операторами using|
|-------------------|---|
|Client (Microsoft.NET.Sdk)|System System.Collections.Generic System.IO System.Linq System.Net.Http System.Threading System.Threading.Tasks|
|Web (Microsoft.NET.Sdk.Web)|All from Microsoft.NET.Sdk plus: System.Net.Http.Json Microsoft.AspNetCore.Builder Microsoft.AspNetCore.Hosting Microsoft.AspNetCore.Http Microsoft.AspNetCore.Routing Microsoft.Extensions.Configuration Microsoft.Extensions.DependencyInjection Microsoft.Extensions.Hosting Microsoft.Extensions.Logging|
|Worker Service (Microsoft.NET.Sdk.Worker)|All from Microsoft.NET.Sdk plus: Microsoft.Extensions.Configuration Microsoft.Extensions.DependencyInjection Microsoft.Extensions.Hosting Microsoft.Extensions.Logging|

Переважна більшість шаблонів проектів за замовчуванням увімкнули глобальні неявні оператори using за допомогою елемента ImplicitUsings у головній групі властивостей проекту. Щоб вимкнути цей параметр, оновіть файл проекту до наступного:

```xml
<PropertyGroup>
  <TargetFramework>net6.0</TargetFramework>
  <Nullable>enable</Nullable>
  <ImplicitUsings>disable</ImplicitUsings>
</PropertyGroup>
```
Щоб переглянути глобальні оператори using у вашому проєкті, знайдіть файл <ProjectName>.GlobalUsings.g.cs у папці \obj\Debug\netX.0.

## Простори імен у файловій області видимості 

Простори імен у файловій області видимості усувають необхідність обгортати код фігурними дужками під час розміщення його у власному просторі імен. Візьмемо наступний приклад класу Calc, що міститься в просторі імен Calculator.

```cs
namespace Calculator
{
    class Calc
    {
        public int Add(int addend1, int addend2)
        {
            return addend1 + addend2;
        }
    }
}
```
У міру того, як ваш код стає складнішим, це може додавати багато додаткового коду та відступів. З просторами імен, обмеженими файловою областю видимості, наступний код досягає того ж ефекту:

```cs
namespace Calculator;

class Calc
{
    public int Add(int addend1, int addend2)
    {
        return addend1 + addend2;
    }
}
```

## Посилання на зовнішні збірки

Кожна версія бібліотек фреймворку (включно з другорядними випусками) інсталюється у власному місці (за версією) на комп'ютері. У Windows кожна версія середовища виконання та SDK інсталюється в c:\Program Files\dotnet. Додавання збірок до більшості проектів .NET здійснюється шляхом додавання пакетів NuGet (про які буде розказано далі в цьому тексті). Однак, .NET-програми, орієнтовані на Windows (і розробляються на ній), все ще мають доступ до бібліотек COM.
Щоб збірка мала доступ до іншої збірки, яку ви створюєте (або яку хтось створив для вас), вам потрібно додати посилання зі своєї збірки до іншої збірки та мати фізичний доступ до іншої збірки. Залежно від засобу розробки, який ви використовуєте для створення своїх .NET-застосунків, у вас будуть різні способи повідомити компілятору, які збірки ви хочете включити під час циклу компіляції.

## Дослідження збірки за допомогою ildasm.exe

Якщо ви починаєте відчувати певну невпевненість від думки про опанування кожного простору імен на платформі .NET, пам’ятайте, що простір імен унікальним робить те, що він містить типи, які певним чином семантично пов’язані. Тому, якщо вам не потрібен інтерфейс користувача, окрім простого консольного застосунку, ви можете забути про простори імен для робочого столу та веб-застосунку (серед інших). Якщо ви створюєте застосунок для малювання, простори імен бази даних, швидше за все, вас не цікавлять. З часом ви дізнаєтеся, які простори імен найбільше відповідають вашим потребам програмування.
Утиліта Intermediate Language Disassembler (ildasm.exe) дозволяє створювати текстовий документ, що представляє збірку .NET, та досліджувати її вміст, включаючи пов'язаний маніфест, CIL-код та метадані типів. Цей інструмент дозволяє вам глибоко зануритися в те, як код C# відповідає CIL, і зрештою допомагає зрозуміти внутрішню роботу платформи .NET. Хоча вам ніколи не потрібно використовувати ildasm.exe, щоб стати досвідченим програмістом .NET, я наполегливо рекомендую вам час від часу запускати цей інструмент, щоб краще зрозуміти, як ваш код C# відповідає концепціям середовища виконання.

  Програма ildasm.exe більше не постачається з середовищем виконання .NET 6. Існує два варіанти отримання цього інструменту у вашому робочому просторі. Перший – це компіляція з вихідного коду .NET 6 Runtime, розташованого за адресою https://github.com/dotnet/runtime. Другий, і простіший спосіб – це отримати потрібну версію з www.nuget.org. ILDasm на NuGet знаходиться за адресою https://www.nuget.org/packages/Microsoft.NETCore.ILDAsm/. Переконайтеся, що ви вибрали правильну версію (для цієї книги вам знадобиться версія 6.0.0 або вище). Додайте пакет ILDasm NuGet до вашого проекту за допомогою такої команди: dotnet add package Microsoft.NETCore.ILDAsm --version 6.0.0. Насправді це не завантажує ILDasm.exe у ваш проект, а розміщує його у папці вашого пакета (у Windows): %userprofile%\.nuget\packages\microsoft.netcore.ildasm\6.0.0\runtimes\native\. Я також включив версію 6.0.0 ILDasm.exe до репозиторію GitHub цієї книги в кореневій папці для зразків коду.

Після завантаження ildasm.exe на ваш комп'ютер ви можете запустити програму з командного рядка без будь-яких аргументів, щоб переглянути коментарі довідки. Як мінімум, вам потрібно вказати збірку для вилучення CIL.
Приклад командного рядка виглядає наступним чином:

```console
ildasm /all /METADATA /out=csharp.il Calculator.cs.dll
```
Це створить файл з назвою csharp.il, у який експортуватиметься вся доступна інформація. Це файл, звідки взяті попередні приклади IL.


# Підсумки

Метою цього розділу було викласти концептуальну основу, необхідну для решти глав. Я почав з розгляду низки обмежень та складнощів, що існували в технологіях до появи .NET, а потім оглянув, як .NET та C# намагаються спростити поточний стан справ.
.NET, по суті, зводиться до механізму виконання програм під час виконання (середовище виконання .NET) та бібліотек базових класів. Середовище виконання може розміщувати будь-який бінарний файл .NET (також відомий як збірка), який дотримується правил керованого коду. Як ви бачили, збірки містять інструкції CIL (на додаток до метаданих типів та маніфесту збірки), які компілюються в інструкції, специфічні для платформи, за допомогою компілятора just-in-time. Крім того, ви дослідили роль Специфікації спільної мови та Системи спільних типів.
У наступному розділі ви ознайомитеся із поширеними інтегрованими середовищами розробки, які можна використовувати під час створення проектів програмування на C#. Вам буде приємно дізнатися, що в цій книзі ви використовуватимете повністю безкоштовні (і багатофункціональні) IDE, тож зможете почати досліджувати всесвіт .NET без початкових вкладень.
