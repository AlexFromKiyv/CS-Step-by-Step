# Взаємовідносини між Process,AppDomain,Context,Thread

Потік це шлях виконання у виконуваній програмі. Багато прогам можуть виконуватися продуктивно в одному потоці. Основний потік збірки (створений середовищем виконання, коли виконується точка входу програми) може створювати вторинні потоки виконання в будь-який час для виконання додаткових одиниць роботи. Так можна ствоювати біль чутливі програми для користувача. 
Простір імен System.Threading  пропонує один підхід для створення багатопоточних програм. 
Важливим класом є Thread, оскільки представляє даний потік. Якщо ви хочете програмно отримати посилання на потік, який зараз виконує певний член, просто викличте статичну властивість Thread.CurrentThread, наприклад:

ThreadingNamespace\Program.cs
```cs
static void ExtractExecutingThread()
{
    Thread thread = Thread.CurrentThread;
    Console.WriteLine(thread.ManagedThreadId);
    
}
ExtractExecutingThread();
```
В .Net Core існує лише один AppDomain, який може мати численні потоки, що виконуються в ньому в будь який момент часу. Можна отримати посилання на AppDomain на якому розміщена програма поток якої виконується.
```cs
static void ExtractAppDomainHostingThread()
{
    // Obtain the AppDomain hosting the current thread.
    AppDomain appDomain = Thread.GetDomain();
    Console.WriteLine(appDomain.FriendlyName);
}
ExtractAppDomainHostingThread();
```
```
ClassThreading
```
Один потік також може бути переміщений у контекст виконання в будь-який момент часу і він може бути переміщений у новому контексті виконання за примхою .Net Core Runtime. Можна отримати поточний контекст виконання, у якому виконуєтьься потік.

```cs
static void ExtractCurrentThreadExecutionContext()
{
    ExecutionContext executionContext = Thread.CurrentThread.ExecutionContext;
    Console.WriteLine(executionContext);
}
ExtractCurrentThreadExecutionContext();
```
```
System.Threading.ExecutionContext
```
Знову ж таки, .NET Core Runtime контролює переміщення потоків у (і з) контексти виконання. Як розробник .NET Core, ви зазвичай можете не знати, куди закінчується певний потік. Тим не менш, ви повинні знати про різні способи отримання базових примітивів.

## Проблема паралельності.

Один із неприємних аспектів в багатопотоковому програмувані полягає в тому що ви мало контролюєте, як базова ОС або runtime використовує свої потоки. Наприклад коли ви створюєте блок коду, який створює новий потік виконання, ви не можете гарантувати, що потік буде виконано негайно. Швидше такий код лише наказує ОС/Runtime виконати потік якнайшвидше(що зазвичай відбувається коли планувальник потоків доходить до цього). Крім того, враховуючи те, що потоки можна переміщувати між програмою та контекстними межами відповідно до вимог середовища виконання, ви повинні пам’ятати, які аспекти вашої програми є потоково-незалежними (наприклад, підлягають багатопоточному доступу), а які операції є атомарними (потоково-незалежними операції небезпечні!).
Щоб проілюструвати проблему, припустимо, що потік викликає метод певного об'єкта. Тепер припустимо, припустимо що цей потік отримав інструкцію від планувальника потоків призупинити свою діяльність, щоб дозволити іншому потоку отримати доступ до того мамого методу того самого об'єкту. Якшо перший потік не закінчив виконання методу повністю, другій приходячий потік може отримати і працювати з об'єктом у частково зміненому стані. Зчитучи фальшиві дані другий потік приведе до дуже дивних поммилок які важко відтворити і налагодити.
З іншого боку атомарні операції завжди безпечні в багатопотоковому середовищі. На жаль, у бібіліотеках базових класів .Net Core є кілька операцій, які гарантовано є атомарними. Навіть акт присвоєння значення змінній-члену не є атомарним! Якщо в документації .Net конкретно не вказано, що операція є атомарною, ви повині вважати, що вона нестійка до потоку, і вжити заходів обережності.   

## Роль синхронізації потоків.
Багатопотокові програми досить мінливі(мають місце постіцно змінюватись), оскільки числені потоки можуть працювати на спільних ресурсах (більш менш) одночасно. Щоб захістити ресурси програми від можливого пошкодження, розродники .Net повинні використовувати будь-яку кількість потокових примітивів (таких як блокуання, монітори та атрібут [Synchronization] або підтримка ключових слів мови), щоб контролювати доступ між потоками що виконуються.
Хоча платформа .NET Core не може повністю усунути труднощі зі створення надійних багатопоточних програм, процес значно спрощено.Використовуючи типи, визначені в просторі імен System.Threading, паралельній бібліотеці завдань і ключових словах мови C# async і await, ви можете працювати з кількома потоками з мінімальною суєтою та турботою.


# Простір імен System.Threading.

На платформі .Net простір імен System.Threading надає типи, які дозволяють безпосередне створення багатопоточних програм. Ці типи дозаоляють взаємодіяти з потоком .Net Core Runtime. Також цей простір імен визначає типи які дають доступ до пулу потоків, що підтримується .Net Core Runtime, простого класу Timer та багатьох типів, що використовуються для забезпечення синхронізованого доступу до спільних ресурсів. Нижче наведені деякі з важливих типів цього простору імен.

    Interlocked : Цей тип забеспечує атомарні операції для змінних, які спільно використовуються кількома потоками.

    Monitor : Цей тип забезпечує сінхронізацію потокових об'єктів за допомогою блокувані і очінування/сигналів. Ключеве слово lock використовує тип під капотом.

    Mutex : Цей примітив синхронізаціх можна використовувати жля сінхронізації між межами домену програми.

    ParameterizedThreadStart : Цей делегат дозволяє потоку викликати методи, які приймають будь-яку кількість аргументів.

    Semaphore : Цей тип дозволяє обмежити кількість потоків, які можуть одночасно отримувати доступ до ресурсу.

    Thread : Цей тип представляє потік, який виконується в середовищі виконання .Net.
    Використовуючи цей тип, ви можете створювати додадкові потоки в поточному AppDomain.

    ThreadPool : Цей тип дозволяє взаємодіяти з пулом потоків, шо підтримуються .Net Core Runtime, у певному процесі.

    ThreadPriority : Це enum представляє рівні пріорітетів потоку (Highest, Normal, etc.).

    ThreadStart : Цей делегат використовується для визначення методу виклику для данного потоку.На відміну від делегату ParameterizedThreadStart, цільовий метод ThreadStart завжди повинні мати однаковий прототип.

    ThreadState : Це enum представляє дійсні стани, які може приймати поток (Running, Aborted, etc.).

    Timer : Цей тип забеспечує механізм для виконання методу через заданий проміжок часу.

    TimerCallback : Цей тип делегату авикористовується в поєднанні з типами Timer.










