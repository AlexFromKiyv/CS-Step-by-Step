# Багатопотокове, паралельне та асинхронне програмування

Нікому не подобається працювати з програмою, яка виконується повільно. Більше того, нікому не подобається запускати завдання в програмі (можливо, ініційоване клацанням елемента панелі інструментів), яке заважає іншим частинам програми бути максимально чутливими. До виходу .NET (і .NET Core) створення програм, які могли виконувати кілька завдань одночасно, зазвичай вимагало написання складного коду C++, який використовував API потоків Windows. На щастя, платформа .NET/.NET Core надає кілька способів створення програмного забезпечення, яке може виконувати складні операції за унікальними шляхами виконання з набагато меншою кількістю проблемних моментів.
Ця глава починається з визначення загальної природи «багатопотокової програми». Далі ви ознайомитеся з оригінальним простором імен потоків, що з'явився з часів .NET 1.0, зокрема System.Threading. Тут ви розглянете численні типи (Thread, ThreadStart тощо), які дозволяють вам явно створювати додаткові потоки виконання та синхронізувати спільні ресурси, що допомагає забезпечити правильний обмін даними між кількома потоками.
У наступних частинах цієх глави буде розглянуто три новіші методи, які розробники .NET Core можуть використовувати для створення багатопотокового програмного забезпечення, зокрема бібліотеку Task Parallel Library (TPL), Parallel LINQ (PLINQ) та внутрішні асинхронні ключові слова C# (async та await). Як ви побачите, ці функції можуть значно спростити процес створення адаптивних багатопотокових програмних застосунків.

# Зв'язок Процес/Домен програми/Контекст/Потік

У попередньому розділі потік було визначено як шлях виконання в межах виконуваного застосунку. Хоча багато програм .NET Core можуть жити щасливим та продуктивним життям в однопотоковому режимі, основний потік збірки (породжений середовищем виконання під час виконання точки входу програми) може створювати вторинні потоки виконання в будь-який час для виконання додаткових одиниць роботи. Створюючи додаткові потоки, ви можете створювати більш адаптивні програми.
Простір імен System.Threading було випущено разом із .NET 1.0 і пропонує один із підходів до створення багатопотокових програм. Клас Thread, мабуть, є основним типом, оскільки він представляє заданий потік. Якщо ви хочете програмно отримати посилання на потік, який наразі виконує заданий член, просто викличте статичну властивість Thread.CurrentThread, ось так:

```cs
static void ExtractExecutingThread()
{
    // Get the thread currently
    // executing this method.
    Thread currThread = Thread.CurrentThread;
}
```
Нагадаємо, що в .NET Core існує лише один AppDomain. Домен додатка (AppDomain) застосунку може мати численні потоки, що виконуються одночасно. Щоб отримати посилання на AppDomain, на якому розміщено застосунок, викличте статичний метод Thread.GetDomain() ось так:

```cs
static void ExtractAppDomainHostingThread()
{
  // Obtain the AppDomain hosting the current thread.
  AppDomain ad = Thread.GetDomain();
}
```
Окремий потік також може бути переміщений у контекст виконання в будь-який момент часу, а також може бути переміщений у межах нового контексту виконання за бажанням середовища виконання .NET Core. Коли ви хочете отримати поточний контекст виконання, в якому виконується потік, використовуйте статичну властивість Thread.CurrentThread.ExecutionContext, ось так:

```cs
static void ExtractCurrentThreadExecutionContext()
{
  // Obtain the execution context under which the
  // current thread is operating.
  ExecutionContext ctx = Thread.CurrentThread.ExecutionContext;
}
```
Знову ж таки, середовище виконання .NET Core контролює переміщення потоків у (та з) контексти виконання. Як розробник .NET Core, ви зазвичай можете залишатися в блаженному невіданні, де опиняється певний потік. Тим не менш, ви повинні знати про різні способи отримання базових примітивів.

## Проблема паралельності

Один із болючих аспектів багатопотокового програмування полягає в тому, що ви маєте мало контролю над тим, як базова операційна система або середовище виконання використовують свої потоки. Наприклад, якщо ви створюєте блок коду, який створює новий потік виконання, ви не можете гарантувати, що потік виконається негайно. Швидше, такий код лише наказує ОС/середовищу виконання виконати потік якомога швидше (зазвичай саме тоді планувальник потоків до цього доходить).
Крім того, враховуючи те, що потоки можна переміщувати між програмою та контекстними межами відповідно до вимог середовища виконання, ви повинні пам’ятати про те, які аспекти вашої програми є потоково-нестабільні, а які операції є атомарними.
Щоб проілюструвати проблему, припустимо, що потік викликає метод певного об'єкта. Тепер припустимо, що планувальник потоків наказав цьому потоку призупинити свою діяльність, щоб дозволити іншому потоку отримати доступ до того ж методу того ж об'єкта. Якщо початковий потік не завершив свою роботу, другий вхідний потік може переглядати об'єкт у частково зміненому стані. На даний момент другий потік, по суті, зчитує фальшиві дані, що неодмінно призведе до появи надзвичайно дивних (і важкодоступних) помилок, які ще важче відтворити та налагодити.
Атомарні операції, з іншого боку, завжди безпечні в багатопоточному середовищі. На жаль, у бібліотеках базових класів .NET Core є мало операцій, які гарантовано є атомарними. Навіть сам акт присвоєння значення змінній-члену не є атомарним! Якщо в документації .NET Core прямо не зазначено, що операція є атомарною, слід припускати, що вона залежить від потоків, і вживати запобіжних заходів.

## Роль синхронізації потоків

На цьому етапі має бути зрозуміло, що багатопотокові програми самі по собі є досить нестабільними, оскільки численні потоки можуть працювати на спільних ресурсах одночасно. Щоб захистити ресурси програми від можливого пошкодження, розробники .NET Core повинні використовувати будь-яку кількість примітивів потоків (таких як locks, monitors та атрибут \[Synchronization\] або підтримку ключових слів мови) для керування доступом між виконуваними потоками.
Хоча платформа .NET Core не може повністю позбутися труднощів створення надійних багатопотокових застосунків, цей процес значно спростився. Використовуючи типи, визначені в просторі імен System.Threading, бібліотеці Task Parallel Library та ключових словах мови C# async та await, ви можете працювати з кількома потоками з мінімальними зусиллями та турботами.
Перш ніж заглибитися в простір імен System.Threading, TPL та ключові слова C# async та await, почнемо з розгляду того, як тип делегату .NET Core можна використовувати для виклику методу асинхронним способом. Хоча, безумовно, правда, що починаючи з версії .NET 4.6, нові ключові слова C# async та await пропонують простішу альтернативу асинхронним делегатам, все ж важливо знати, як взаємодіяти з кодом за допомогою цього підходу (повірте, у продакшені є безліч коду, який використовує асинхронні делегати).

# Простір імен System.Threading

На платформах .NET та .NET Core простір імен System.Threading надає типи, що дозволяють безпосередньо створювати багатопотокові програми. Окрім надання типів, що дозволяють взаємодіяти з потоком .NET Core Runtime, цей простір імен визначає типи, що дозволяють доступ до пулу потоків, що підтримується .NET Core Runtime, простий (не на основі графічного інтерфейсу) клас Timer та численні типи, що використовуються для забезпечення синхронізованого доступу до спільних ресурсів.

Основні типи простору імен System.Threading

|Тип|Значення|
|---|--------|
|Interlocked|Цей тип забезпечує атомарні операції для змінних, які спільно використовуються кількома потоками.|
|Monitor|Цей тип забезпечує синхронізацію потокових об'єктів за допомогою блокувань та сигналів очікування. Ключове слово lock у C# використовує об'єкт Monitor "під капотом".|
|Mutex|Цей примітив синхронізації можна використовувати для синхронізації між межами домену застосунку.|
|ParameterizedThreadStart|Цей делегат дозволяє потоку викликати методи, які приймають будь-яку кількість аргументів.|
|Semaphore|Цей тип дозволяє обмежити кількість потоків, які можуть одночасно звертатися до ресурсу.|
|Thread|Цей тип представляє потік, який виконується в середовищі виконання .NET Core. Використовуючи цей тип, можна створювати додаткові потоки в початковому домені програми (AppDomain).|
|ThreadPool|Цей тип дозволяє взаємодіяти з пулом потоків, що підтримується середовищем виконання .NET Core, у межах заданого процесу.|
|ThreadPriority|Цей перелік представляє рівень пріоритету потоку (найвищий, нормальний тощо).|
|ThreadStart|Цей делегат використовується для визначення методу виклику для заданого потоку. На відміну від делегата ParameterizedThreadStart, цільові об'єкти ThreadStart завжди повинні мати однаковий прототип.|
|ThreadState|Цей перелік визначає допустимі стани, які може приймати потік (Running, Aborted,тощо).|
|Timer|Цей тип забезпечує механізм для виконання методу через задані інтервали.|
|TimerCallback |Цей тип делегату використовується разом із типами таймерів.|

## Клас System.Threading.Thread

Найпримітивнішим з усіх типів у просторі імен System.Threading є Thread. Цей клас являє собою об'єктно-орієнтовану обгортку навколо заданого шляху виконання в межах AppDomain. Цей тип також визначає кілька методів (як статичних, так і на рівні екземпляра), які дозволяють створювати нові потоки в поточному AppDomain, а також призупиняти, зупиняти та знищувати потік.

<b>Ключові статичні члени типу Thread</b>
|Член|Значення|
|----|--------|
|ExecutionContext|Ця властивість, доступна лише для читання, повертає інформацію, що стосується логічного потоку виконання, включаючи безпеку, виклики, синхронізацію, локалізацію та контексти транзакцій.|
|CurrentThread|Ця властивість, доступна лише для читання, повертає посилання на поточний запущений потік.|
|Sleep()|Цей метод призупиняє поточний потік на заданий час.|

Ключові члени рівня екземпляра типу  Thread
|Член|Значення|
|----|--------|
|IsAlive|Повертає логічне значення, яке вказує, чи цей потік був розпочатий (і чи ще не завершився або перерваний).|
|IsBackground|Отримує або встановлює значення, яке вказує, чи є цей потік «фоновим потоком»|
|Name|Дозволяє встановити зрозумілу текстову назву потоку.|
|Priority|Отримує або встановлює пріоритет потоку, якому може бути присвоєно значення з перелічення ThreadPriority.|
|ThreadState|Отримує стан цього потоку, якому може бути присвоєно значення з перелічення ThreadState.|
|Abort()|Наказує середовищу виконання .NET Core якомога швидше завершити потік.|
|Interrupt()|Перериває (наприклад, будить) поточний потік після відповідного періоду очікування.|
|Join()|Блокує викликаючий потік, доки не завершиться роботу вказаного потоку (того, в якому викликається Join.|
|Resume()|Відновлює попередньо призупинений потік.|
|Start()|Наказує середовищу виконання .NET Core виконати потік якомога швидше.|
|Suspend()|Призупиняє потік. Якщо потік вже призупинено, виклик Suspend() не має жодного ефекту.|

    Переривання або призупинення активного потоку зазвичай вважається поганою ідеєю.

## Отримання статистики про поточний потік виконання

Нагадаємо, що точка входу виконуваної збірки (тобто оператори верхнього рівня або метод Main()) виконується в основному потоці виконання. Нагадаємо, що точка входу виконуваної збірки (тобто оператори верхнього рівня або метод Main()) виконується в основному потоці виконання. Щоб проілюструвати базове використання типу Thread, припустимо, що у вас є новий проект консольної програми з назвою ThreadStats. Після отримання поточного потоку ви можете вивести різну статистику, наприклад:

```cs
static void PrimaryThread()
{
    // Obtain and name the current thread.
    Thread primaryThread = Thread.CurrentThread;
    primaryThread.Name = "ThePrimaryThread";

    // Print out some stats about this thread.
    Console.WriteLine($"ID of current thread: {primaryThread.ManagedThreadId}");
    Console.WriteLine($"Thread Name: {primaryThread.Name}");
    Console.WriteLine($"Has thread started?: {primaryThread.IsAlive}");
    Console.WriteLine($"Priority Level: {primaryThread.Priority}");
    Console.WriteLine($"Thread State: {primaryThread.ThreadState}");

}
PrimaryThread();
```
```
ID of current thread: 1
Thread Name: ThePrimaryThread
Has thread started?: True
Priority Level: Normal
Thread State: Running
```

### Властивість Name

Зверніть увагу, що клас Thread підтримує властивість під назвою Name. Якщо ви не встановите це значення, Name поверне порожній рядок. Однак, як тільки ви призначите зрозумілий рядковий монікер заданому об'єкту Thread, ви можете значно спростити свої зусилля з налагодження. Якщо ви використовуєте Visual Studio, ви можете отримати доступ до вікна Threads (Потоки) під час сеансу налагодження (виберіть Debug ➤ Windows ➤ Threads ➤ Threads під час роботи програми). Як видно з рисунка, ви можете швидко визначити потік, який потрібно діагностувати.

![Threads](PrimaryThread.png)

### Властивість Priority

Далі зверніть увагу, що тип Thread визначає властивість під назвою Priority. За замовчуванням усі потоки мають рівень пріоритету Normal. Однак, ви можете змінити це в будь-який момент життя потоку, використовуючи властивість Priority та пов'язане з нею перелічення System.Threading.ThreadPriority, ось так:

```cs
public enum ThreadPriority
{
  Lowest,
  BelowNormal,
  Normal, // Default value.
  AboveNormal,
  Highest
}
```
Якщо ви призначите потоку рівень пріоритету значення, відмінне від значення за замовчуванням (ThreadPriority.Normal), майте на увазі, що ви не матимете прямого контролю над тим, коли планувальник потоків перемикається між потоками. Рівень пріоритету потоку надає підказку середовищу виконання .NET Core щодо важливості його активності. Таким чином, потоку зі значенням ThreadPriority.Highest не обов'язково надавати найвищий пріоритет.
Знову ж таки, якщо планувальник потоків зайнятий певним завданням (наприклад, синхронізацією об'єкта, перемиканням потоків або переміщенням потоків), рівень пріоритету, найімовірніше, буде відповідно змінено. Однак, за інших рівних умов, середовище виконання .NET Core зчитує ці значення та вкаже планувальнику потоків, як найкраще розподілити часові інтервали. Потоки з однаковим пріоритетом повинні отримувати однакову кількість часу для виконання своєї роботи.
У більшості випадків вам рідко (якщо взагалі) знадобиться безпосередньо змінювати рівень пріоритету потоку. Теоретично, можливо підвищити рівень пріоритету для набору потоків, тим самим запобігаючи виконанню потоків з нижчим пріоритетом на необхідних рівнях (тому будьте обережні).

## Ручне створення вторинних потоків 

Коли ви хочете програмно створити додаткові потоки для виконання певної одиниці роботи, дотримуйтесь цього передбачуваного процесу під час використання типів простору імен System.Threading:

1. Створіть метод, який буде точкою входу для нового потоку.
2. Створіть новий делегат ParameterizedThreadStart (або ThreadStart), передавши конструктору адресу методу, визначеного на кроці 1.
3. Створіть об'єкт Thread, передавши делегат ParameterizedThreadStart/ThreadStart як аргумент конструктора.
4. Встановіть будь-які початкові характеристики потоку (ім'я, пріоритет тощо).
5. Викличте метод Thread.Start(). Це якомога швидше запустить потік у методі, на який посилається делегат, створений на кроці 2.

Як зазначено в кроці 2, ви можете використовувати два різні типи делегатів, щоб «вказати» на метод, який виконуватиме вторинний потік. Делегат ThreadStart може вказувати на будь-який метод, який не приймає аргументів і нічого не повертає. Цей делегат може бути корисним, коли метод розроблено для простого виконання у фоновому режимі без подальшої взаємодії.
Обмеженням ThreadStart є те, що ви не можете передавати параметри для обробки. Однак, тип делегату ParameterizedThreadStart дозволяє один параметр типу System.Object. Оскільки будь-що може бути представлене як System.Object, ви можете передавати будь-яку кількість параметрів через власний клас або структуру. Однак зауважте, що делегати ThreadStart та ParameterizedThreadStart можуть вказувати лише на методи, які повертають void.

## Робота з делегатом ThreadStart

Щоб проілюструвати процес створення багатопотокової програми (а також продемонструвати корисність цього), додайте  проект консольної програми з назвою SimpleMultiThreadApp, який дозволяє кінцевому користувачеві вибрати, чи буде програма виконувати свої обов'язки, використовуючи один основний потік, чи вона розділить своє робоче навантаження, використовуючи два окремі потоки виконання.
Припускаючи, що ви імпортували простір імен System.Threading, вашим першим кроком є ​​визначення методу для виконання роботи (можливого) вторинного потоку. Щоб зосередитися на механіці створення багатопотокових програм, цей метод просто виведе послідовність чисел у вікно консолі, зупиняючись приблизно на дві секунди з кожним проходом. Ось повне визначення класу Printer:

```cs

public class Printer
{
    public int Counter { get; set; }
    public void PrintNumbers()
    {
        // Display Thread info.
        string threadInfo = $"{Thread.CurrentThread.Name}(id:{Thread.CurrentThread.ManagedThreadId})";
        Console.WriteLine($"{threadInfo} is executing PrintNumbers()");
        
        // Print out numbers.
        Console.Write("Your numbers: ");
        for (int i = 0; i < 10; i++)
        {
            Console.Write($"{Counter} ");
            Thread.Sleep(2000);
            Counter++;
        }
        Console.WriteLine();
    }
}
```
Тепер у Program.cs ви додасте оператори верхнього рівня, щоб спочатку запропонувати користувачеві визначити, один чи два потоки будуть використані для виконання роботи програми. Якщо користувач запитує один потік, вам просто потрібно викликати метод PrintNumbers() в основному потоці. Однак, якщо користувач вказує два потоки, ви створите делегат ThreadStart, який вказує на PrintNumbers(), передасте цей об'єкт делегату в конструктор нового об'єкта Thread та викличете Start(), щоб повідомити середовище виконання .NET Core, що цей потік готовий до обробки. Ось повна реалізація:

```cs
static void Run()
{
    // Name the current thread.
    Thread primaryThread = Thread.CurrentThread;
    primaryThread.Name = "Primary";
    // Display Thread info.
    string threadInfo = $"{Thread.CurrentThread.Name}(id:{primaryThread.ManagedThreadId})";
    Console.WriteLine($"{threadInfo} is executing");

    Console.Write("Do you want 1 or 2 threads? Enter (1/2) : ");
    string? threadCount = Console.ReadLine();

    // Make worker class.
    Printer p = new Printer();

    switch (threadCount)
    {
        case "1":
            p.PrintNumbers();
            break;
        case "2":
            // Now make the thread.
            Thread backgroundThread = new Thread(new ThreadStart(p.PrintNumbers));
            backgroundThread.Name = "Secondary";
            backgroundThread.Start();
            break;
        default:
            Console.WriteLine("I don't know what you want...you get 1 thread.");
            goto case "1";
    }
    // Do some additional work.
    Console.WriteLine("\tThis is on the main thread, and we are finished.");
    Console.ReadLine();
}
Run();
```
```
Primary(id:1) is executing
Do you want 1 or 2 threads? Enter (1/2) : 1
Primary(id:1) is executing PrintNumbers()
Your numbers: 0 1 2 3 4 5 6 7 8 9
        This is on the main thread, and we are finished.
```
```
Primary(id:1) is executing
Do you want 1 or 2 threads? Enter (1/2) : 2
        This is on the main thread, and we are finished.
Secondary(id:9) is executing PrintNumbers()
Your numbers: 0 I'm1 doing2 something3 else.4 5 6 7 8 9
```
Тепер, якщо ви запустите цю програму з одним потоком, ви побачите, що кінцевий вивід консолі не відобразить повідомлення, доки вся послідовність чисел не буде виведена на консоль. Оскільки ви явно зупиняєтеся приблизно на дві секунди після виведення кожного числа, це призведе до не дуже вдалого досвіду для кінцевого користувача. Однак, якщо вибрати два потоки, вікно повідомлення відображається миттєво, враховуючи, що унікальний об'єкт Thread відповідає за виведення чисел у консоль. Обох випадках домен програми чекає покі вториний потік закінчить свою роботу.


## Робота з делегатом ParameterizedThreadStart

В попередьному прикладі вториний потік створювався наступним чином:
```cs
            Thread backgroundThread = new Thread(new ThreadStart(p.PrintNumbers));
            backgroundThread.Name = "Secondary";
            backgroundThread.Start();
```
Делегат ThreadStart може вказувати лише на методи, які повертають значення void та не приймають аргументів. Хоча в деяких випадках це може бути доречним, якщо ви хочете передавати дані методу, який виконується у вторинному потоці, вам потрібно буде використовувати тип делегату ParameterizedThreadStart.
Для ілюстрації додайте новий проект консольної програми з назвою AddWithThreads. Тепер, враховуючи, що ParameterizedThreadStart може вказувати на будь-який метод, що приймає параметр System.Object, ви створите власний тип, що містить числа, які потрібно додати, ось так:

```cs
class AddParams
{
    public int a, b;
    public AddParams(int a, int b)
    {
        this.a = a;
        this.b = b;
    }
}
```
Далі створіть метод, який буде виконуватися в вторинному потоці, у файлі Program.cs. Він прийматиме параметр AddParams та виводитиме суму двох чисел, наступним чином:

```cs
    void Add(object? data)
    {
        if (data is AddParams ap)
        {
            Console.WriteLine($"Id of thread in Add(): {Environment.CurrentManagedThreadId}");

            Console.WriteLine($"{ap.a} + {ap.b} is {ap.a + ap.b}");
        }
    }
```
Цей метод відповідає сігнатурі ParameterizedThreadStart.

Код для виклику цього методу в Program.cs є простим. Просто використовуйте ParameterizedThreadStart замість ThreadStart, ось так:

```cs
void SimpleUseParameterizedThreadStart()
{
    Console.WriteLine($"Id of thread in top-lavel: {Environment.CurrentManagedThreadId}");

    // Make an AddParams object to pass to the secondary thread.
    AddParams ap = new AddParams(10, 10);
    Thread t = new Thread(new ParameterizedThreadStart(Add));
    t.Start(ap);
    // Force a wait to let other thread finish.
    Thread.Sleep(5);
    Console.WriteLine(t.ThreadState);
}
SimpleUseParameterizedThreadStart();
```
```
Id of thread in top-lavel: 1
Id of thread in Add(): 8
10 + 10 is 20
Stopped
```

## Клас AutoResetEvent

У цих перших кількох прикладах немає чіткого способу дізнатися, коли вторинний потік завершив свою роботу. В останньому прикладі Sleep було викликано з довільним часом, щоб дозволити іншому потоку завершитися. Якшо цю стоку закоментувати основний потік закінчиться раніше вторинного.

```
Id of thread in top-lavel: 1
Running // вторинний потік працює
Id of thread in Add(): 7
10 + 10 is 20
```

Один простий та потокобезпечний спосіб змусити потік чекати, поки не завершиться інший, – це використовувати клас AutoResetEvent. У потоці, який має чекати, створіть екземпляр цього класу та передайте конструктору значення false, щоб позначити, що вас ще не сповістили. Потім, коли ви захочете чекати, викличте метод WaitOne(). Коли вториний потік завершить своє робоче навантаження, він викличе метод Set() для того самого екземпляра типу AutoResetEvent. Ось оновлення класу Program.cs, яке виконає саме це, використовуючи змінну-член AutoResetEvent статичного рівня:

```cs
void UseParameterizedThreadStartWithAutoResetEvent()
{
    Console.WriteLine($"Id of thread in top-lavel: {Environment.CurrentManagedThreadId}");

    AutoResetEvent _waitHandle = new AutoResetEvent(false);
    
    AddParams ap = new AddParams(10, 10);
    Thread thread = new Thread(new ParameterizedThreadStart(AddWithAutoResetEvent));
    thread.Start(ap);

    //Wait for the wait handle to complete
    _waitHandle.WaitOne();
    Console.WriteLine(thread.ThreadState);


    // New version Add
    void AddWithAutoResetEvent(object? data)
    {
        if (data is AddParams ap)
        {
            //Add in sleep to show the background thread getting terminated
            Thread.Sleep(2000);

            Console.WriteLine($"Id of thread in AddWithAutoResetEvent(): {Environment.CurrentManagedThreadId}");
            Console.WriteLine($"{ap.a} + {ap.b} is {ap.a + ap.b}");

            // Tell other thread we are done.
            _waitHandle.Set();
        }
    }
}
UseParameterizedThreadStartWithAutoResetEvent();

```
```
Id of thread in top-lavel: 1
Id of thread in AddWithAutoResetEvent(): 7
10 + 10 is 20
Stopped
```
Закоментуйте рядок   _waitHandle.WaitOne();

```
Id of thread in top-lavel: 1
Running
Id of thread in AddWithAutoResetEvent(): 7
10 + 10 is 20
```

## Потоки переднього плану(foreground) та фонові(background) потоки

Тепер, коли ви побачили, як програмно створювати нові потоки виконання за допомогою простору імен System.Threading, давайте формалізуємо різницю між потоками переднього плану та фоновими потоками:

Потоки переднього плану можуть запобігти завершенню поточної програми. Середовище виконання .NET Core не завершить роботу програми (тобто не вивантажить домен програми, що знаходиться на її базі), доки не завершаться всі потоки переднього плану.

Фонові потоки розглядаються середовищем виконання .NET Core як вільні шляхи виконання, які можна ігнорувати в будь-який момент часу (навіть якщо вони наразі працюють над певною одиницею роботи). Таким чином, якщо всі потоки переднього плану завершилися, всі фонові потоки автоматично завершуються під час вивантаження домену застосунку.

Важливо зазначити, що потоки переднього плану та фонові потоки не є синонімами основних та робочих потоків. За замовчуванням кожен потік, який ви створюєте за допомогою методу Thread.Start(), автоматично є потоком переднього плану. Знову ж таки, це означає, що AppDomain не вивантажиться, доки всі потоки виконання не завершать свої одиниці роботи. У більшості випадків це саме та поведінка, яка вам потрібна. 
Однак, для пояснень, припустимо, що ви хочете викликати Printer.PrintNumbers() у вторинному потоці, який має поводитися як фоновий потік. Знову ж таки, це означає, що метод, на який вказує тип Thread (через делегат ThreadStart або ParameterizedThreadStart), повинен мати можливість безпечно зупинитися, щойно всі потоки переднього плану завершать свою роботу. Налаштування такого потоку просте, як встановлення властивості IsBackground значення true.
Створіть нову консольну програму з назвою BackgroundThreads. Додайте клас Printer.cs у новий проект.

```cs
public class Printer
{
    public int Counter { get; set; }
    public void PrintNumbers()
    {
        // Display Thread info.
        Console.WriteLine($"Thread id:{Thread.CurrentThread.ManagedThreadId} is executing PrintNumbers()");
        
        // Print out numbers.
        Console.Write("Your numbers: ");
        for (int i = 0; i < 10; i++)
        {
            Console.Write($"{Counter} ");
            Thread.Sleep(2000);
            Counter++;
        }
        Console.WriteLine();
    }
}
```
Оновіть файл Program.cs, щоб він відповідав наступному:

```cs
Printer p = new Printer();

Thread bgroundThread = new Thread(new ThreadStart(p.PrintNumbers));
// This is now a background thread.
bgroundThread.IsBackground = true;
bgroundThread.Start();
```
Зауважте, що цей код не здійснює виклик Console.ReadLine(), щоб змусити консоль залишатися видимою, доки ви не натиснете клавішу Enter. Таким чином, коли ви запускаєте програму, вона негайно завершить роботу, оскільки об'єкт Thread налаштовано як фоновий потік. Враховуючи, що точка входу в програму (або оператори верхнього рівня, як показано тут, або метод Main()) ініціює створення основного потоку переднього плану, щойно логіка в точці входу завершується, AppDomain вивантажується до того, як вторинний потік зможе завершити свою роботу.
Однак, якщо закоментувати рядок, який встановлює властивість IsBackground, то побачите, що кожне число виводиться в консоль, оскільки всі потоки переднього плану повинні завершити свою роботу, перш ніж AppDomain буде вивантажено з процесу розміщення.
Зробимо деякі зміни:

```cs
Printer p = new Printer();

Thread bgroundThread = new Thread(new ThreadStart(p.PrintNumbers));
// This is now a background thread.
bgroundThread.IsBackground = true;
bgroundThread.Start();

Thread.Sleep(7000);
```
```
Thread id:6 is executing PrintNumbers()
Your numbers: 0 1 2 3
```
Тут видно шо вториний потік обривається коли ми натискаєио Enter і закінчує роботу первинний потік.

Здебільшого, налаштування потоку для роботи у фоновому режимі може бути корисним, коли відповідний робочий потік виконує некритичне завдання, яке більше не потрібне після завершення основного завдання програми. Наприклад, ви можете створити застосунок, який кожні кілька хвилин надсилає запити на нові електронні листи на поштовий сервер, оновлює поточні погодні умови або виконує якесь інше некритичне завдання.

## Проблема паралельності

Під час створення багатопотокових додатків ваша програма повинна забезпечити захист будь-якого фрагмента спільних даних від можливості зміни їх значення численними потоками. Враховуючи, що всі потоки в домені програми мають одночасний доступ до спільних даних програми, уявіть, що може статися, якщо кілька потоків звертатимуться до однієї й тієї ж точки даних. Оскільки планувальник потоків змушуватиме потоки призупиняти свою роботу випадковим чином, що робити, якщо потік A буде виключено з шляху, перш ніж він повністю завершить свою роботу? Потік B тепер зчитує нестабільні дані.
Щоб проілюструвати проблему паралельності, давайте створимо ще один проект консольної програми під назвою MultiThreadedPrinting. Ця програма знову використовуватиме клас Printer, створений раніше, але цього разу метод PrintNumbers() змусить поточний потік призупинити роботу на випадково згенерований проміжок часу.

```cs
public class Printer
{
    public void PrintNumbers()
    {
        // Display Thread info.
        Console.WriteLine($"\t{Thread.CurrentThread.Name} is executing PrintNumbers()");

        // Print out numbers.
        for (int i = 0; i < 10; i++)
        {
            // Put thread to sleep for a random amount of time.
            Random r = new Random();
            Thread.Sleep(1000*r.Next(5));
            Console.Write($"{i}, ");
        }
        Console.WriteLine();
    }
}
```
Викликаючий код відповідає за створення масиву з десяти (унікально іменованих) об'єктів Thread, кожен з яких здійснює виклики до одного й того ж екземпляра об'єкта Printer наступним чином:

```cs
void Run()
{
    Printer p = new Printer();
    // Make 10 threads that are all pointing to the same
    // method on the same object.
    Thread[] threads = new Thread[10];
    for (int i = 0; i < 10; i++)
    {
        threads[i] = new Thread(new ThreadStart(p.PrintNumbers))
        {
            Name = $"Worker thread #{i}"
        };
    }
    // Now start each one.
    foreach (Thread t in threads)
    {
        t.Start();
    }
    Console.ReadLine();
}
Run();
```
Перш ніж розглядати деякі тестові запуску, давайте підсумуємо проблему. Первинний потік у цьому AppDomain починає своє існування, породжуючи десять вторинних робочих потоків. Кожному робочому потоку наказано викликати метод PrintNumbers() на тому самому екземплярі Printer. Враховуючи, що ви не вжили жодних запобіжних заходів для блокування спільних ресурсів цього об'єкта (консолі виводу), існує велика ймовірність того, що поточний потік буде вилучено до того, як метод PrintNumbers() зможе вивести повні результати. Оскільки ви точно не знаєте, коли це може статися, ви неминуче отримаєте непередбачувані результати. Наприклад, ви можете побачити результат, показаний тут:

```
        Worker thread #1 is executing PrintNumbers()
        Worker thread #4 is executing PrintNumbers()
        Worker thread #3 is executing PrintNumbers()
        Worker thread #2 is executing PrintNumbers()
        Worker thread #0 is executing PrintNumbers()
        Worker thread #5 is executing PrintNumbers()
        Worker thread #6 is executing PrintNumbers()
        Worker thread #7 is executing PrintNumbers()
0,      Worker thread #8 is executing PrintNumbers()
0,      Worker thread #9 is executing PrintNumbers()
1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 1, 0, 1, 1, 2, 3, 2, 2, 2, 1, 1, 2, 3, 1, 3, 3, 4, 4, 5, 5, 3, 2, 2, 2, 4, 6, 5, 4, 3, 5, 6, 7, 6, 2, 3, 3, 7, 3, 6, 3, 4, 4, 4, 4, 7, 8, 9,
8, 9,
7, 5, 4, 5, 5, 4, 5, 8, 5, 6, 7, 6, 8, 6, 6, 7, 8, 5, 6, 7, 9,
9,
9,
6, 8, 8, 7, 7, 7, 9,
9,
8, 8, 9,
9,
8, 9,
```
Тепер запустіть програму ще кілька разів і перевірте результат. Швидше за все, щоразу він буде відрізнятися.

    Якщо ви не можете генерувати непередбачувані результати, збільште кількість потоків з 10 до 100 (наприклад) або введіть ще один виклик Thread.Sleep() у вашій програмі. Зрештою, ви зіткнетеся з проблемою паралельності.

Тут явно є деякі проблеми. Коли кожен потік повідомляє Printer про необхідність друку числових даних, планувальник потоків у фоновому режимі щасливо міняє місцями потоки. Вам потрібен спосіб програмно забезпечити синхронізований доступ до спільних ресурсів. Як ви могли здогадатися, простір імен System.Threading надає кілька типів, орієнтованих на синхронізацію. Мова програмування C# також надає ключове слово для самого завдання синхронізації спільних даних у багатопотокових додатках.

## Синхронізація за допомогою ключового слова C# lock

Перший метод, який можна використовувати для синхронізації доступу до спільних ресурсів, – це ключове слово C# lock. Це ключове слово дозволяє визначити область дії операторів, які мають бути синхронізовані між потоками. Таким чином, вхідні потоки не можуть переривати поточний потік, тим самим заважаючи йому завершити свою роботу. Ключове слово lock вимагає вказати токен (посилання на об'єкт), який має отримати потік, щоб потрапити в область блокування. Коли ви намагаєтеся заблокувати приватний метод на рівні екземпляра, ви можете просто передати посилання на поточний тип наступним чином:

```cs
private void SomePrivateMethod()
{
  // Use the current object as the thread token.
  lock(this)
  {
    // All code within this scope is thread safe.
  }
}
```
Однак, якщо ви блокуєте область коду всередині публічного члена, безпечніше (і є найкращою практикою) оголосити приватну змінну-член об'єкта, яка слугуватиме токеном блокування, ось так:

```cs
public class Printer
{
  // Lock token.
  private object threadLock = new object();
  public void PrintNumbers()
  {
    // Use the lock token.
    lock (threadLock)
    {
      ...
    }
  }
}
```
У будь-якому разі, якщо ви перевірите метод PrintNumbers(), то побачите, що спільним ресурсом, до якого потоки конкурують за доступ, є вікно консолі. Область видимості всіх взаємодій з типом Console знаходиться в межах області видимості блокування, наступним чином:

```cs
public class Printer
{
    // Lock token.
    private object threadLock = new();
    public void PrintNumbers()
    {
        lock (threadLock)
        {
            // Display Thread info.
            Console.WriteLine($"\t{Thread.CurrentThread.Name} is executing PrintNumbers()");

            // Print out numbers.
            for (int i = 0; i < 10; i++)
            {
                // Put thread to sleep for a random amount of time.
                Random r = new Random();
                Thread.Sleep(100 * r.Next(5));
                Console.Write($"{i}, ");
            }
            Console.WriteLine();
        }
    }
}
```
Роблячи це, ви фактично розробили метод, який дозволить поточному потоку виконати своє завдання. Як тільки потік потрапляє в область блокування, токен блокування (у цьому випадку посилання на поточний об'єкт) стає недоступним для інших потоків, доки блокування не буде знято після виходу з області блокування. Таким чином, якщо потік A отримав токен блокування, інші потоки не зможуть увійти в будь-яку область, яка використовує той самий токен блокування, доки потік A не відмовиться від токена блокування.
    
    Якщо ви намагаєтеся заблокувати код у статичному методі, просто оголосіть приватну змінну-член статичного об'єкта, яка слугуватиме токеном блокування.

Якщо ви тепер запустите програму, то побачите, що кожен потік має достатньо можливостей для завершення своєї роботи.

```cs
        Worker thread #0 is executing PrintNumbers()
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
        Worker thread #1 is executing PrintNumbers()
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
        Worker thread #2 is executing PrintNumbers()
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
        Worker thread #3 is executing PrintNumbers()
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
        Worker thread #5 is executing PrintNumbers()
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
        Worker thread #4 is executing PrintNumbers()
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
        Worker thread #6 is executing PrintNumbers()
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
        Worker thread #7 is executing PrintNumbers()
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
        Worker thread #8 is executing PrintNumbers()
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
        Worker thread #9 is executing PrintNumbers()
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,

```

## Синхронізація за допомогою типу System.Threading.Monitor

Оператор lock C# - це скорочення позначення для роботи з класом System.Threading.Monitor. Після обробки компілятором C#, область блокування приймає наступне значення (що можна перевірити за допомогою ildasm.exe): 

```cs
public void PrintNumbers()
{
  Monitor.Enter(threadLock);
  try
  {
    // Display Thread info.
    Console.WriteLine($"\t{Thread.CurrentThread.Name} is executing PrintNumbers()");

    // Print out numbers.
    Console.Write('Your numbers: ');
    for (int i = 0; i < 10; i++)
    {
      Random r = new Random();
      Thread.Sleep(1000 * r.Next(5));
      Console.Write('{0}, ', i);
    }
    Console.WriteLine();
  }
  finally
  {
    Monitor.Exit(threadLock);
  }
}
```
Спочатку зверніть увагу, що метод Monitor.Enter() є кінцевим одержувачем токена потоку, який ви вказали як аргумент ключового слова lock. Далі, весь код в області блокування обгортається блоком try. Відповідний блок finally гарантує, що токен потоку буде звільнено (через метод Monitor.Exit()), незалежно від будь-яких можливих винятків під час виконання. Якщо ви зміните програму MultiThreadPrinting для безпосереднього використання типу Monitor (як щойно показано), ви отримаєте ідентичний результат.
Тепер, враховуючи, що ключове слово lock, здається, вимагає менше коду, ніж явне використання типу System.Threading.Monitor, ви можете замислитися про переваги безпосереднього використання типу Monitor. Коротка відповідь – контроль. Якщо ви використовуєте тип Monitor, ви можете вказати активному потоку чекати певний проміжок часу (через статичний метод Monitor.Wait()), повідомити потоки, що очікують, коли поточний потік завершено (через статичні методи Monitor.Pulse() та Monitor.PulseAll()) тощо.
Як і слід було очікувати, у багатьох випадках ключове слово C# lock підійде. Однак, якщо ви зацікавлені в ознайомленні з додатковими членами класу Monitor, зверніться до документації .NET Core.

## Синхронізація з використанням типу System.Threading.Interlocked

Хоча в це завжди важко повірити, доки ви не подивитеся на базовий CIL-код, призначення та прості арифметичні операції не є атомарними. З цієї причини простір імен System.Threading надає тип, який дозволяє атомарно оперувати з однією точкою даних з меншими накладними витратами, ніж з типом Monitor.

Ключові статичні члени типу System.Threading.Interlocked

|Член|Значення|
|----|--------|
|CompareExchange()|Безпечно перевіряє два значення на рівність і, якщо вони рівні, обмінює одне зі значень на третє|
|Decrement()|Безпечно зменшує значення на 1|
|Exchange()|Безпечно міняє місцями два значення|
|Increment()|Безпечно збільшує значення на 1|

Хоча спочатку це може здаватися не так, процес атомарної зміни одного значення є досить поширеним у багатопотоковому середовищі. Припустимо, у вас є код, який збільшує цілочисельну змінну-член з назвою intVal. Замість того, щоб писати код синхронізації, такий як наступний:

```cs
int intVal = 5;
object myLockToken = new();
lock(myLockToken)
{
  intVal++;
}
```
Ви можете спростити свій код за допомогою статичного методу Interlocked.Increment(). Просто передайте змінну для збільшення за посиланням. Зверніть увагу, що метод Increment() не лише коригує значення вхідного параметра, але й повертає нове значення.

```cs
intVal = Interlocked.Increment(ref intVal);
```
Окрім Increment() та Decrement(), тип Interlocked дозволяє атомарно присвоювати числові та об'єктні дані. Наприклад, якщо ви хочете присвоїти значення змінної-члена значенню, ви можете уникнути необхідності використовувати явний оператор блокування (або явну логіку Monitor) та використовувати метод Interlocked.Exchange() ось так:

```cs
var myInt = 27;
Interlocked.Exchange(ref myInt, 83);
Console.WriteLine(myInt);
```
Зрештою, якщо ви хочете перевірити два значення на рівність та змінити точку порівняння потокобезпечним способом, ви можете скористатися методом Interlocked.CompareExchange() наступним чином:
```cs
// If the value of i is currently 83, change myInt  to 99.
Interlocked.CompareExchange(ref myInt, 99, 83);
```

## Програмування з використанням Timer Callbacks

Багато програм потребують викликати певний метод протягом регулярних проміжків часу. Наприклад, у вас може бути програма, якій потрібно відображати сповіщеня після часу з початку роботи у рядку стану за допомогою певної допоміжної функції. Як інший приклад, ви можете захотіти, щоб ваша програма час від часу викликала допоміжну функцію для виконання некритичних фонових завдань, таких як перевірка нових повідомлень електронної пошти. У таких ситуаціях можна використовувати тип System.Threading.Timer разом із пов'язаним делегатом з іменем TimerCallback.
Для ілюстрації, припустимо, що у вас є проект консольного застосунку TimerApp, який виводитиме поточний час щосекунди, доки користувач не натисне клавішу для завершення роботи застосунку. Першим очевидним кроком є ​​написання методу, який буде викликатися типом Timer.

```cs
static void PrintTime(object? state)
{
    Thread thread = Thread.CurrentThread;

    string message =
        $"Time is: {DateTime.Now.ToLongTimeString()}\t" +
        $"Param is {state}\t" +
        $"ManagedThreadId: {thread.ManagedThreadId}\t" +
        $"IsBackground: {thread.IsBackground}";

    Console.WriteLine(message);
}
```
Зверніть увагу, що метод PrintTime() має один параметр типу System.Object і повертає значення void. Це є обов'язковим, враховуючи, що делегат TimerCallback може викликати лише методи, що відповідають цьому підпису. Значення, що передається в ціль вашого делегата TimerCallback, може бути об'єктом будь-якого типу (у випадку з прикладом електронної пошти цей параметр може представляти назву сервера, з яким потрібно взаємодіяти під час процесу). Також зверніть увагу, що враховуючи, що цей параметр дійсно є System.Object, ви можете передавати кілька аргументів, використовуючи System.Array або власний клас/структуру.
Наступний крок – налаштувати екземпляр делегата TimerCallback та передати його об'єкту Timer. Окрім налаштування делегату TimerCallback, конструктор Timer дозволяє вказати необов'язкову інформацію про параметр, яку потрібно передати цільовому об'єкту делегата (визначеному як System.Object), інтервал опитування методу та час очікування (у мілісекундах) перед першим викликом.

```cs
void Run()
{
    Console.WriteLine($"Primary thread id: {Thread.CurrentThread.ManagedThreadId}");

    // Create the delegate for the Timer type.
    TimerCallback timerCallback = new TimerCallback(PrintTime);

    // Establish timer settings.
    Timer t = new Timer(
      timerCallback,     // The TimerCallback delegate object.
      "It's noon",       // Any info to pass into the called method (null for no info).
      0,          // Amount of time to wait before starting (in milliseconds).
      1000);      // Interval of time between calls (in milliseconds).

    Console.WriteLine("Hit Enter key to terminate...");
    Console.ReadLine();
}
Run();
```
У цьому випадку метод PrintTime() буде викликатися приблизно щосекунди та не передаватиме жодної додаткової інформації до цього методу. Ось результат:

```
Primary thread id: 1
Hit Enter key to terminate...
Time is: 12:35:53       Param is It's noon      ManagedThreadId: 4      IsBackground: True
Time is: 12:35:54       Param is It's noon      ManagedThreadId: 6      IsBackground: True
Time is: 12:35:55       Param is It's noon      ManagedThreadId: 6      IsBackground: True
Time is: 12:35:56       Param is It's noon      ManagedThreadId: 6      IsBackground: True
Time is: 12:35:57       Param is It's noon      ManagedThreadId: 6      IsBackground: True
Time is: 12:35:58       Param is It's noon      ManagedThreadId: 6      IsBackground: True
Time is: 12:35:59       Param is It's noon      ManagedThreadId: 6      IsBackground: True

```
Змінна Timer не використовується в жодному шляху виконання, тому її можна замінити на відкидання, наступним чином:

```cs
// Establish timer settings.
_ = new Timer(timerCallback, "It's evening ", 0, 1000);
```

## Розуміння пулу потоків

Наступна тема, орієнтована на потоки, яку ви розглянете в цьому розділі, — це роль пулу потоків середовища виконання. Запуск нового потоку має свої витрати, тому з метою ефективності пул потоків зберігає створені (але неактивні) потоки, доки вони не знадобляться. Щоб дозволити вам взаємодіяти з цим пулом потоків, що очікують, простір імен System.Threading надає тип класу ThreadPool.
Якщо ви хочете поставити виклик методу в чергу для обробки робочим потоком у пулі, ви можете скористатися методом ThreadPool.QueueUserWorkItem(). Цей метод перевантажено, щоб дозволити вам вказати необов'язковий System.Object для даних про стан користувача, окрім екземпляра делегата WaitCallback.

```cs
public static class ThreadPool
{
  ...
  public static bool QueueUserWorkItem(WaitCallback callBack);
  public static bool QueueUserWorkItem(WaitCallback callBack, object state);
}
```
Делегат WaitCallback може вказувати на будь-який метод, який приймає System.Object як єдиний параметр (який представляє необов'язкові дані стану) і нічого не повертає. Зверніть увагу, що якщо ви не надаєте System.Object під час виклику QueueUserWorkItem(), середовище виконання .NET Core автоматично передає значення null. Щоб проілюструвати методи черг, що використовуються пулом потоків .NET Core Runtime, розглянемо наступну програму ThreadPoolApp, яка знову використовує тип Printer.

```cs
public class Printer
{
    // Lock token.
    private object threadLock = new();
    public void PrintNumbers()
    {
        lock (threadLock)
        {
            // Display Thread info.
            Console.WriteLine($"Thread id:{Thread.CurrentThread.ManagedThreadId} is executing PrintNumbers()");

            // Print out numbers.
            for (int i = 0; i < 10; i++)
            {
                Console.Write($"{i}, ");
                Thread.Sleep(50);
            }
            Console.WriteLine();
        }
    }
}
```
Однак у цьому випадку ви не створюєте вручну масив об'єктів Thread; радше ви призначаєте члени пулу методу PrintNumbers().

```cs

using ThreadPoolApp;

static void PrintTheNumbers(object? obj)
{
    if (obj == null) return;
    Printer printer = (Printer)obj;
    printer.PrintNumbers();
}

Console.WriteLine($"Main thread id:{Environment.CurrentManagedThreadId} started.");
Printer p = new Printer();

WaitCallback workItem = new(PrintTheNumbers);

// Queue the method 10 times
for (int i = 0; i < 10; i++)
{
    ThreadPool.QueueUserWorkItem(workItem, p);
}
Console.WriteLine("All tasks queued");
Console.ReadLine();
```
```
Main thread id:1 started.
All tasks queued
Thread id:6 is executing PrintNumbers()
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
Thread id:8 is executing PrintNumbers()
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
Thread id:7 is executing PrintNumbers()
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
Thread id:10 is executing PrintNumbers()
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
Thread id:11 is executing PrintNumbers()
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
Thread id:6 is executing PrintNumbers()
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
Thread id:8 is executing PrintNumbers()
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
Thread id:12 is executing PrintNumbers()
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
Thread id:4 is executing PrintNumbers()
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
Thread id:7 is executing PrintNumbers()
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
```
Крім того ми можемо побачити що ці потоки фонові і їх можно прирвати в будь який момент.

```
Main thread id:1 started.
All tasks queued
Thread id:7 is executing PrintNumbers()
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
Thread id:8 is executing PrintNumbers()
0, 1, 2, 3, 4, 5, 6, 7, 8,
```


На цьому етапі ви можете задатися питанням, чи не було б вигідно використовувати пул потоків, що підтримується середовищем виконання .NET Core, замість явного створення об'єктів Thread. Розглянемо ці переваги використання пулу потоків:

1. Пул потоків ефективно керує потоками, мінімізуючи кількість потоків, які необхідно створювати, запускати та зупиняти.
2. Використовуючи пул потоків, ви можете зосередитися на своїй бізнес-проблемі, а не на інфраструктурі потоків застосунку.

Однак у деяких випадках перевагу надається ручному управлінню потоками. Ось приклад:

1. Якщо вам потрібні потоки переднього плану або потрібно встановити пріоритет потоків, потоки в пулі завжди є фоновими потоками з пріоритетом за замовчуванням (ThreadPriority.Normal).

2. Якщо вам потрібен потік з фіксованою ідентифікатором, перервіть його, призупиніть або знайдіть його за назвою.

## Підсумки розділу.

В цьому розділі ми розлянули як створювати одниицю роботи в вторинному потоці. Підсумуємо найважливіше в проекті SummaryThread.

Маемо одиницю роботи яка потребуєчас на виконання.

```cs
void DoWork(int delay) 
{ 
    Thread.Sleep(delay);
}
```
Створюємо метод який відповідає делегату ThreadStart або ParameterizedThreadStart

```cs
void MethodForWork()
{
    // Display Thread info.
    string threadInfo = $"{Thread.CurrentThread.Name} (id:{Thread.CurrentThread.ManagedThreadId})";
    Console.WriteLine($"{threadInfo} is executing DoWork 3000 ms.");
    DoWork(3000);
}
```
Створюємо потік і запускаєм.

```cs
void Run()
{
    // Display Thread info.
    string threadInfo = $"Primary (id:{Thread.CurrentThread.ManagedThreadId})";
    Console.WriteLine(threadInfo);

    Thread thread = new Thread(new ThreadStart(MethodForWork));
    thread.Name = "Secondary";
    thread.IsBackground = true;
    thread.Start();

    Console.ReadLine();
}
Run();
```
```
Primary (id:1)
Secondary (id:7) is executing DoWork 5000 ms.


```
Якшо в потоці властивість IsBackground = true він преривається разом з первиним потоком.

Звісно, ​​розуміння тем, представлених у цому розділі (особливо під час розгляду питань паралельності), буде надзвичайно цінним під час створення багатопотокової програми. З огляду на цю основу, тепер ви звернете свою увагу на кілька нових тем, орієнтованих на потоки. Для початку ви розглянете роль альтернативної моделі потоків – бібліотеки паралельного виконання завдань (Task Parallel Library).