# Цикл житя об'екта.

В цьому розділі розглдаеться як середа виконання керує виделиним для об'єкта ресурасми, виконує збирання мусору і як ми можево програмно на це впливати. Для цого існує System.GC. Бішість роботи середа виконання та ці знання можуть допомогти коли мова іде про некеровані ресурси.

## Класи, об'єкти, посилання та процеси в пам'яті .

Розлянемо клас.
ObjectLifetime\Types_v1.cs
```cs
    class Car
    {
        public string Name { get; set; } = "";
        public int MaxSpeed { get; }
        public int CurrentSpeed { get; set; }

        public override string? ToString() => $"{Name} is going {CurrentSpeed}";
        
    }
```
Клас це ні шо інще як план того як його єкземпляри будуть створюватися та поводитись. Від складовіх залежить як він використовує пам'ять. 
```cs
ExplorationClassObjectReference();
void ExplorationClassObjectReference()
{
    CreateOldCar();

    void CreateOldCar()
    {

        int max = 250;

        Car myCar = new Car("Volkswagen Käfer", 115, 30);

        Console.WriteLine(myCar.ToString());
        Console.WriteLine(max/ myCar.MaxSpeed);

    }
}
```
![Reference to object](Reference.png "Посилання на обект")

Ключове слово new повертае посилання на об'єкт в керованій купі. Посилання використовуеться для доступу до членів об'єкту за допомогою опрератора (.)dot.
Зміна в якій знаходиться посилання так само як і структури медоту зберігаються в стеку. Розмішеня в купі відбуваеться коли створюються єкземпляри класу.

При розробці слід притримуватися досить простого правила створіть єкземляр класу за допомогою new (тим самим розмістите в managed heap) і забудьте про нього. Збирать сміття сам знищить його коли він не потрібен. Як збирач визначає що об'єкт не потрібен? Коротка відповідь збирач сміття видаляе об'єкт із купи тоді коли об'єкт недоступний з будь якої частини коду.
В прикладі посилання myCar було створено беспосередьно в методі і не предавалось зовні через значеня шо повертає метод чи іншими способами(параметрами ref/out). Таким чином після виконання методу посилання вилучаеться з стеку і об'єкт в купі претендент на знишеня збиральником смітя. Але ви не можете гарантувати шо це відбудиться одразу як виконаеться метод. Все шо можна передбачити шо при наступній роботі збиральника сміття об'єкт може бути безпечно видалений з купи. 
Середовише виконання виконує управління пам'яті в керовапій купі і це набагато лолегшує розробку (порівнюючи з C++).

Керована купа це більше ніж шматки вільної пам'яті які бера середовище виконання. Збирач сміття досить економно відноситься до пам'яті роблячи оптімізацію і ущімлення.Щоб робити це керована купа підтримує вказівник, якій вказує нанаступний об'єкт. При створенні об'єкту сердовишу вказуеться зробити наступне наступне:
- Обчислити загальний обсяг пам'яті, необхідної для об'єкта(включаючи членів класу та базових класів)
- Перевірити керовану купу чи справді достатьно пам'яті для розміщення. Якшо так викликаеться конструктор і повертаеться вказівник на новий об'єкт чия позиція просто змігаеться з останньою позицією наступного об'єкта.
- Перед відсиланням посилання перемістити вказівник купи нового об'єкту на кінець створенного.

```cs
void AllocateInMemory()
{
    Car car1 = new();
    Car car2 = new();
}
```
![Next object](NextObject.png "Посилання на наступний об'єкт")


Простір в керованій купі з часом може заповнитись. Якшо середовище виконання виявило шо обсягу для нового об'єкта недостатньо, вона виконує збір сміття намагаючись звільнити пам'ять. Таким чином збирач сміття починає видаляти непотрібні об'єкти коли недостатьно пам'яті в купі.

Коли змінній призначаеться null (myCar = null) це не змушує збирача сміття запуститися і видалити з пам'яті. Це лише розриває зв'язок посилання з об'єктом керованої купи. Тобто така операція не має великої користі.

## Визначення необхідності об'єкта в купі.

Аби визначити чи ше потрібен об'єкт для вимкористання збирач сміття використовує данні про змінні стека та дескріптори збирача смітя які вказують на керовані об'єкти на які можна посилатись з коду або середовища виконання.
Під час збирання сміття середовище виконнання досліджує об'єкти в керованій купі шоб визначити доступні вони програмі. Для цього вона будує граф об'єктів який представляє кожен доступний об'єкт в купі. Граф документує всі доступні об'екти. В графі об'єкти не повторюються.
Припустимо керована купа містить об'єкти A,B,C,D,E,F,G.

![Need object](IsNeed.png "Необхідність об'єкта")

Під час збирання сміття всі об'єкти а також внутрішні посилання між ними перевіряються. Післа побудови графа недосяжні об'єкти помічаються як сміття. В цьому випадку C, F. Після помітки об'єктів на видалення вони видаляються з пам'яті. У цей момент простір в купі ущільнюеться. Покажчики на об'єкти змінюються і змінюеться покажчик на останній об'єкт.

![After swept](AfterSwept.png "Після чистки")

Строго кажучи, збирач сміття використовує дві різні купи, одна з яких спеціально використовується для зберігання великих об’єктів.До цієї купи звертаються рідше під час циклу збору, враховуючи можливі втрати продуктивності, пов’язані з переміщенням великих об’єктів.

## Покоління об'єктів.

Коли середовище виконання намагається знайти недоступні об'єкти воа не перевіряє кожен об'єкт в купі. Ця опреація може займати багато часу. Для оптимізації процесу об'єкт призначаеться до первого "покоління". Ідея поколінь досить проста : чим довше об'єкт існував в купі тим більша ймовірність шо він там залишиться. Наприклад клас який відповидае за основні єлемент управління програмою будє в пам'яті пока програма не закінчить роботу. В тойже час об'єкт методу який не виходив за його межи буде недоступний досить швидко. Кожний об'єкт в купі може належити до коллекції в одному з наступних поколінь:
 - Покоління 0 : Це щойно розташований невеликий об'єкт якій ніколи не позначався в коллекціях. Більшисть об'єктів які обробляються збирачем сміття з поклоіння 0 і деякі виживають до покоління 1.

 - Покоління 1 : Це об'єкти які пережили збирання сміття. Це поколіня є буфером між короткоживучими і довго живучими. 

 - Покоління 2 : Це об'єкти які витримав більше одного циклу сбирання сміття, або значно великий об'єкт якій почав свое існування з покоління 2.

Покоління 0 і 1 називаються ефемерними поколіннями. 

![Generations](Generations.png "Generations")

Збирач сміття спочатку досліджуе всі об'єкти покоління 0. Якщо позначення і очищеня приведе до появи необхідної пам'яті будь-які вцілілі об'єкти перходять до покоління 1. Якшо при прегляді покління 0 і збиранні сміття виявится що потрібна додадкова пам'ять досліджуються об'єкти покоління 1 і відбуваеться збирання сміття серед них. Уцілілі після цього об'єкти поколіня 1 підвищуються до покоління 2. Якщо збиральник ще потребує місця розглядаються об'єкти покоління 2. На цьому єтапі якшо об'єкт виживає він залишаеться в поколінні 2.
Суть полягає в тому, що, призначаючи об'єктам покоління, нові об'єкти(схожі на змінні в стеку) будуть швидко видялятись а біль старі об'єкти не будуть "чіпатись" так часто.  
Збирач сміття запускаеться коли не вистачає фізичної пам'яті, коли зайнята пам'ять в керованій купі первищує порог. Також збирач смітя може запусrfnbcm програмно GC.Collect().
Процесс збирання сміття не без певних витрат. Під час збирання використовуєтьс цикли процессора і це може повпливати на продуктивність додадку.

## Ефемерні покоління і сегменти.

Поколіня 0 та 1 короткострокові. Ці покоління розміщуються в сегменті пам'яті який називають ефемерний сегмент. Коли відбуваеться збір сміття, нові сегменти які здобуті стають новими ефемерними сегментами. А сегменти які переживають покоління 1 стають сегментами покоління 2. Розмір ефемерних сегментів залежить від ряду факторів. До них відносяться розрядність системи та тип збирача сміття.


| Garbage Collection Type | 32-bit | 64-bit |
| ----------------------- |------- | ------ |
| Workstation             | 16 MB  | 256 MB |
| Server                  | 64 MB  | 4 GB   |
| Server with > 4 log.CPUs| 32 MB  | 2 GB   |
| Server with > 8 log.CPUs| 16 MB  | 1 GB   |



