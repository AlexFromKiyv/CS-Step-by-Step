# Цикл житя об'екта.

В цьому розділі розглдаеться як середа виконання керує виделиним для об'єкта ресурасми, виконує збирання мусору і як ми можево програмно на це впливати. Для цого існує System.GC. Бішість роботи середа виконання та ці знання можуть допомогти коли мова іде про некеровані ресурси.

## Класи, об'єкти, посилання та процеси в пам'яті .

Розлянемо клас.
ObjectLifetime\Types_v1.cs
```cs
    class Car
    {
        public string Name { get; set; } = "";
        public int MaxSpeed { get; }
        public int CurrentSpeed { get; set; }

        public override string? ToString() => $"{Name} is going {CurrentSpeed}";
        
    }
```
Клас це ні шо інще як план того як його єкземпляри будуть створюватися та поводитись. Від складовіх залежить як він використовує пам'ять. 
```cs
ExplorationClassObjectReference();
void ExplorationClassObjectReference()
{
    CreateOldCar();

    void CreateOldCar()
    {

        int max = 250;

        Car myCar = new Car("Volkswagen Käfer", 115, 30);

        Console.WriteLine(myCar.ToString());
        Console.WriteLine(max/ myCar.MaxSpeed);

    }
}
```
![Reference to object](Reference.png "Посилання на обект")

Ключове слово new повертае посилання на об'єкт в керованій купі. Посилання використовуеться для доступу до членів об'єкту за допомогою опрератора (.)dot.
Зміна в якій знаходиться посилання так само як і структури медоту зберігаються в стеку. Розмішеня в купі відбуваеться коли створюються єкземпляри класу.

При розробці слід притримуватися досить простого правила створіть єкземляр класу за допомогою new (тим самим розмістите в managed heap) і забудьте про нього. Збирать сміття сам знищить його коли він не потрібен. Як збирач визначає що об'єкт не потрібен? Коротка відповідь збирач сміття видаляе об'єкт із купи тоді коли об'єкт недоступний з будь якої частини коду.
В прикладі посилання myCar було створено беспосередьно в методі і не предавалось зовні через значеня шо повертає метод чи іншими способами(параметрами ref/out). Таким чином після виконання методу посилання вилучаеться з стеку і об'єкт в купі претендент на знишеня збиральником смітя. Але ви не можете гарантувати шо це відбудиться одразу як виконаеться метод. Все шо можна передбачити шо при наступній роботі збиральника сміття об'єкт може бути безпечно видалений з купи. 
Середовише виконання виконує управління пам'яті в керовапій купі і це набагато лолегшує розробку (порівнюючи з C++).

Керована купа це більше ніж шматки вільної пам'яті які бера середовище виконання. Збирач сміття досить економно відноситься до пам'яті роблячи оптімізацію і ущімлення.Щоб робити це керована купа підтримує вказівник, якій вказує нанаступний об'єкт. При створенні об'єкту сердовишу вказуеться зробити наступне наступне:
- Обчислити загальний обсяг пам'яті, необхідної для об'єкта(включаючи членів класу та базових класів)
- Перевірити керовану купу чи справді достатьно пам'яті для розміщення. Якшо так викликаеться конструктор і повертаеться вказівник на новий об'єкт чия позиція просто змігаеться з останньою позицією наступного об'єкта.
- Перед відсиланням посилання перемістити вказівник купи нового об'єкту на кінець створенного.

```cs
void AllocateInMemory()
{
    Car car1 = new();
    Car car2 = new();
}
```
![Next object](NextObject.png "Посилання на наступний об'єкт")


Простір в керованій купі з часом може заповнитись. Якшо середовище виконання виявило шо обсягу для нового об'єкта недостатньо, вона виконує збір сміття намагаючись звільнити пам'ять. Таким чином збирач сміття починає видаляти непотрібні об'єкти коли недостатьно пам'яті в купі.

Коли змінній призначаеться null (myCar = null) це не змушує збирача сміття запуститися і видалити з пам'яті. Це лише розриває зв'язок посилання з об'єктом керованої купи. Тобто така операція не має великої користі.

## Визначення необхідності об'єкта в купі.

Аби визначити чи ше потрібен об'єкт для вимкористання збирач сміття використовує данні про змінні стека та дескріптори збирача смітя які вказують на керовані об'єкти на які можна посилатись з коду або середовища виконання.
Під час збирання сміття середовище виконнання досліджує об'єкти в керованій купі шоб визначити доступні вони програмі. Для цього вона будує граф об'єктів який представляє кожен доступний об'єкт в купі. Граф документує всі доступні об'екти. В графі об'єкти не повторюються.
Припустимо керована купа містить об'єкти A,B,C,D,E,F,G.

![Need object](IsNeed.png "Необхідність об'єкта")

Під час збирання сміття всі об'єкти а також внутрішні посилання між ними перевіряються. Післа побудови графа недосяжні об'єкти помічаються як сміття. В цьому випадку C, F. Після помітки об'єктів на видалення вони видаляються з пам'яті. У цей момент простір в купі ущільнюеться. Покажчики на об'єкти змінюються і змінюеться покажчик на останній об'єкт.

![After swept](AfterSwept.png "Після чистки")

Строго кажучи, збирач сміття використовує дві різні купи, одна з яких спеціально використовується для зберігання великих об’єктів.

## 



