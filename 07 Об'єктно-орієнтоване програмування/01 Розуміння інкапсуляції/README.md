# Розуміння інкапсуляції

# Знайомство з типом C# class

Що стосується платформи .NET, однією з найбільш фундаментальних програмних конструкцій є тип класу. Формально клас — це визначений користувачем тип, який складається з даних поля (часто їх називають змінними-членами) і членів, які працюють з цими даними (таких як конструктори, властивості, методи, події тощо). У сукупності набір даних поля представляє «стан» екземпляра класу (інакше відомого як об’єкт). Потужність об’єктно-орієнтованих мов, таких як C#, полягає в тому, що, групуючи дані та пов’язані функції в уніфікованому визначенні класу, ви можете моделювати своє програмне забезпечення за об’єктами в реальному світі.

Створіть новий проект консольної програми C# під назвою SimpleClassExample. Далі вставте новий файл класу (з назвою Car.cs) у свій проект. Клас визначається в C# за допомогою ключового слова class. Ось найпростіша можлива декларація :

```cs
namespace SimpleClassExample;

class Car
{
}
```
Після того як ви визначили тип класу, вам потрібно буде додати набір змінних-членів, які використовуватимуться для представлення його стану. Наприклад, ви можете вирішити, що автомобілі мають тип даних int для представлення поточної швидкості та тип даних string для представлення дружнього назву автомобіля (наприклад "ластівка"). Враховуючи ці початкові примітки щодо дизайну, оновіть свій клас автомобіля наступним чином:

```cs
class Car
{
    // The 'state' of the Car.
    public string petName;
    public int currSpeed;
}
```
Зауважте, що ці змінні-члени оголошено за допомогою модифікатора доступу public. Загальнодоступні члени класу доступні безпосередньо після створення об’єкта цього типу. Термін об’єкт використовується для опису екземпляра даного типу класу, створеного за допомогою ключового слова new. 

Дані поля класу рідко (якщо взагалі взагалі) слід визначати як публічні. Щоб зберегти цілісність ваших даних про стан, набагато краще буде визначити дані як приватні (або, можливо, захищені) і дозволити контрольований доступ до даних через властивості (як показано далі в цьому розділі). Однак, щоб зробити цей перший приклад максимально простим, загальнодоступні дані відповідають вимогам.

Після того як ви визначили набір змінних-членів, що представляють стан класу, наступним кроком проектування є встановлення членів, які моделюють його поведінку. У цьому прикладі клас Car визначатиме один метод під назвою SpeedUp() та інший під назвою PrintState(). Оновіть свій клас так:

```cs
class Car
{
    // The 'state' of the Car.
    public string petName;
    public int currSpeed;

    // The functionality of the Car.
    public void PrintState()
    {
        Console.WriteLine($"{petName} is going {currSpeed} MPH.");
    }
    public void SpeedUp(int delta)
    {
        currSpeed += delta;
    }
}
```
PrintState() — це функція, яка просто виводить поточний стан певного об’єкта Car у вікно команд. SpeedUp() збільшить швидкість об’єкта Car на величину, визначену вхідним параметром int. Тепер оновіть у файлі Program.cs такий код:

```cs

using SimpleClassExample;

static void SimpleUsingObject1()
{
    // Allocate and configure a Car object.
    Car car = new Car();
    car.petName = "Henry";
    car.currSpeed = 10;

    // Speed up the car a few times and print out the
    // new state.
    for (int i = 0; i <= 10; i++)
    {
        car.SpeedUp(5);
        car.PrintState();
    }
}
SimpleUsingObject1();
```
Після запуску програми ви побачите, що змінна Car (myCar) зберігає свій поточний стан протягом усього терміну служби програми, як показано в наведених нижче результатах.

```console
Henry is going 15 MPH.
Henry is going 20 MPH.
Henry is going 25 MPH.
Henry is going 30 MPH.
Henry is going 35 MPH.
Henry is going 40 MPH.
Henry is going 45 MPH.
Henry is going 50 MPH.
Henry is going 55 MPH.
Henry is going 60 MPH.
Henry is going 65 MPH.
```

## Розміщення об’єктів за допомогою ключового слова new

Як показано в попередньому прикладі коду, об’єкти повинні бути виділені в пам’ять за допомогою ключового слова new. Якщо ви не використаєте ключове слово new і спробуєте використати свою змінну класу в наступному операторі коду, ви отримаєте помилку компілятора.

```cs
static void WithoutNew()
{
    // Compiler error! Forgot to use 'new' to create object!
    Car myCar;
    myCar.petName = 'Fred';
}
```
Щоб правильно створити об’єкт за допомогою ключового слова new, ви можете визначити та розмістити об’єкт Car в одному рядку коду. 

```cs
static void AboutNew()
{
    // Compiler error! Forgot to use 'new' to create object!
    //Car myCar;
    //myCar.petName = 'Fred';

    Car myCar = new();
    myCar.petName = "Lastivka";
}
```
Як альтернатива, якщо ви хочете визначити та виділити екземпляр класу в окремих рядках коду, ви можете зробити це наступним чином:

```cs
    Car yourCar;
    yourCar = new();
```
Тут перший оператор коду просто оголошує посилання на ще не визначений об'єкт. Лише після того, як ви призначите посилання на об’єкт, це посилання вказує на дійсний об’єкт у пам’яті. 
У будь-якому випадку, на даний момент у вас є тривіальний клас, який визначає кілька полів даних і деякі основні операції. Щоб підвищити функціональність нинішнього класу Car, потрібно розуміти роль конструкторів.

## Розуміння конструкторів

З огляду на те, що об’єкти мають стан (представлений значеннями змінних-членів об’єкта), програміст зазвичай бажає призначити відповідні значення даним поля об’єкта перед використанням. Наразі клас Car потребує, щоб поля petName і currSpeed ​​призначалися окремо для кожного поля. Для поточного прикладу це не надто проблематично, враховуючи, що у вас є лише дві публічні точки даних. Однак нерідко клас має десятки полів, з якими потрібно боротися. Зрозуміло, що було б небажано створювати 20 операторів ініціалізації для встановлення 20 точок даних!
C# підтримує використання конструкторів, які дозволяють встановити стан об’єкта під час створення. Конструктор — це спеціальний метод класу, який викликається опосередковано під час створення об’єкта за допомогою ключового слова new. Однак, на відміну від «звичайних» методів, конструктори ніколи не повертають значення (навіть void) і завжди мають імена, ідентичні класу, який вони створюють.

### Розуміння ролі конструктора за замовчуванням

Кожний клас C# забезпечено «халявний» конструктором за замовчуванням, який ви можете перевизначити, якщо буде потрібно. За визначенням, конструктор за замовчуванням ніколи не приймає аргументів. Після розміщення нового об’єкта в пам’яті конструктор за замовчуванням гарантує, що для всіх даних полів класу встановлено відповідне значення за замовчуванням.
Якщо ви не задоволені цими призначеннями за замовчуванням, ви можете перевизначити конструктор за замовчуванням відповідно до ваших потреб. Для ілюстрації оновіть свій клас C# Car наступним чином:

```cs
class Car
{
    // The 'state' of the Car.
    public string petName;
    public int currSpeed;
  
    // A custom default constructor.
    public Car()
    {
        petName = "No name";
    }
    //...
}
```
У цьому випадку ви змушуєте всі об’єкти Car почати життя на ім’я "No name"  зі швидкістю 0 миль на годину. Завдяки цьому ви можете створити об’єкт Car із такими значеннями за замовчуванням:

```cs
static void DefaultConstructor()
{
    // Invoking the default constructor.
    Car car = new();
    car.PrintState();
}
DefaultConstructor();
```
```
No name is going 0 MPH.
```

### Визначення настроюваних конструкторів

Як правило, класи визначають додаткові конструктори крім типових. Роблячи це, ви надаєте користувачеві об’єкта простий і послідовний спосіб ініціалізації стану об’єкта безпосередньо під час створення. Зверніть увагу на наступне оновлення класу Car, який тепер підтримує загалом три конструктори:

```cs
class Car
{
    // The 'state' of the Car.
    public string petName;
    public int currSpeed;
  
    // A custom default constructor.
    public Car()
    {
        petName = "No name";
    }

    public Car(string name)
    {
        petName = name;
    }

    public Car(string name, int speed)
    {
        petName = name;
        currSpeed = speed;
    }
}
```
Майте на увазі, що один конструктор відрізняється від іншого (в очах компілятора C#) кількістю та/або типом аргументів конструктора. Коли ви визначаєте метод з такою ж назвою, який відрізняється кількістю або типом аргументів, ви перевантажили метод. Таким чином, клас Car перевантажив конструктор, щоб надати кілька способів створення об’єкта під час оголошення. У будь-якому випадку, тепер ви можете створювати об’єкти Car за допомогою будь-якого загальнодоступного конструктора.

```cs
static void UsingConstructors()
{
    // Make a Car called No name going 0 MPH.
    Car chuck = new Car();
    chuck.PrintState();
    // Make a Car called Mary going 0 MPH.
    Car mary = new Car("Mary");
    mary.PrintState();
    // Make a Car called Daisy going 75 MPH.
    Car daisy = new Car("Daisy", 75);
    daisy.PrintState();
}
UsingConstructors();
```
```
No name is going 0 MPH.
Mary is going 0 MPH.
Daisy is going 75 MPH.

```

### Конструктори з out параметрами 

Конструктори (а також ініціалізатори полів і властивостей, розглянуті пізніше) можуть використовувати out параметри.

```cs
    public Car(string name, int speed, out bool inDanger)
    {
        petName = name;
        currSpeed = speed;
        inDanger = (speed > 100) ? true : false;
    }
```
```cs
    Car fastic = new Car("Fastic", 120, out bool danger);
    Console.WriteLine(danger);
```
```
True
```
Необхідно дотримуватися всіх правил вихідних параметрів. У цьому прикладі параметру inDanger необхідно присвоїти значення перед завершенням роботи конструктора.

### Розуміння конструктора за замовчуванням

Як ви щойно дізналися, усі класи забезпечені конструктором за замовчуванням. Вставте новий файл у свій проект під назвою Motorcycle.cs і додайте наступне:

```cs
namespace SimpleClassExample;

public class Motorcycle
{
    public void Drieve()
    {
        Console.WriteLine("I diving");
    }
}
```
Тепер ви можете створити екземпляр типу Motorcycle за допомогою конструктора за замовчуванням який надає середовище виконання.

```cs
    // Default constructor
    Motorcycle motorcycle = new();
    motorcycle.Drive();
```
```
I diving
```
Однак, як тільки ви визначаєте спеціальний конструктор з будь-якою кількістю параметрів, конструктор за замовчуванням мовчки видаляється з класу та стає недоступним. Подумайте про це так: якщо ви не визначите спеціальний конструктор, компілятор C# надає вам значення за замовчуванням, щоб дозволити користувачеві об’єкта розмістити екземпляр вашого типу з даними поля, встановленими на правильні значення за замовчуванням. Однак, коли ви визначаєте унікальний конструктор, компілятор припускає, що ви взяли справу у свої руки.

Таким чином, якщо ви хочете дозволити користувачеві об’єкта створити екземпляр вашого типу з конструктором за замовчуванням, а також ваш власний конструктор, ви повинні явно перевизначити конструктор за замовчуванням який без параметрів. З цією метою слід розуміти, що в переважній більшості випадків реалізація конструктора за замовчуванням класу навмисно порожня, оскільки все, що вам потрібно, це можливість створити об’єкт із значеннями за замовчуванням. Розглянемо таке оновлення класу :

```cs
public class Motorcycle
{
    public int speed;
    public void Drive()
    {
        Console.WriteLine($"I diving {speed}");
    }
    public Motorcycle()
    {
    }
    public Motorcycle(int speed)
    {
        this.speed = speed;
    }
}
```
Тепер, коли ви краще розумієте роль конструкторів класів, ось зручне скорочення. І Visual Studio, і Visual Studio Code надають фрагмент коду ctor. Коли ви вводите ctor і натискаєте клавішу Tab, IDE автоматично визначить настроюваний конструктор за замовчуванням. Потім ви можете додати спеціальні параметри та логіку впровадження. Або коли натисните Ctrl+. > Generete constructor. Спробуйте.

```cs
    Motorcycle motorcycle1 = new(100);
    motorcycle1.Drive();
```
```
I diving 100
```

### Розуміння ролі ключового слова this

C# надає ключове слово this, яке забезпечує доступ до поточного екземпляра класу. Одним із можливих способів використання ключового слова this є вирішення неоднозначності області видимості, яка може виникнути, коли вхідний параметр має назву, ідентичну до поля даних класу. Однак ви можете просто прийняти угоду про найменування, яка не призведе до такої неоднозначності; щоб проілюструвати це використання ключового слова this, оновіть свій клас Motorcycle новим рядковим полем (ім’я), яке представлятиме ім’я водія. Далі додайте метод під назвою SetDriverName(), реалізований наступним чином:

```cs
public class Motorcycle
{
    //...

    public string name;

    //...

    public void SetName(string name)
    {
        name = name;
    }
}
```
Незважаючи на те, що цей код компілюється, компілятор C# відобразить попереджувальне повідомлення, яке інформує вас про те, що ви призначили змінну саму собі! Для ілюстрації оновіть свій код, щоб викликати SetDriverName(), а потім роздрукуйте значення поля імені.

```cs
static void AboutThis()
{
    Motorcycle motorcycle = new();
    motorcycle.SetName("Julia");
    Console.WriteLine($"Biker:{motorcycle.name}");
}
AboutThis();
```
```
Biker:
```
Проблема полягає в тому, що реалізація SetDriverName() призначає вхідний параметр назад собі, враховуючи, що компілятор припускає, що name посилається на змінну, яка зараз знаходиться в області методу, а не на поле імені в області класу. Щоб повідомити компілятору, що ви хочете встановити поле даних імені поточного об’єкта на вхідний параметр імені, просто скористайтеся this, щоб вирішити неоднозначність.

```cs
    public void SetName(string name)
    {
        //name = name;
        this.name = name;
    }
```
Якщо двозначності немає, вам не потрібно використовувати ключове слово this під час доступу до полів даних або членів. Наприклад, якщо ви перейменуєте елемент рядкових даних з name на driverName (що також вимагатиме від вас оновлення операторів верхнього рівня), використання цього є необов’язковим, оскільки більше немає неоднозначності області видимості.

```cs
public class Motorcycle
{
    //...

    public string driverName;

    //...

    public void SetName(string name)
    {
        //name = name;
        //this.name = name;
        driverName = name;
    }
}
```
```cs
static void AboutThis()
{
    Motorcycle motorcycle = new();
    motorcycle.SetName("Julia");
    Console.WriteLine($"Biker:{motorcycle.driverName}");
}
AboutThis();
```
Незважаючи на те, що використання цього в однозначних ситуаціях мало що виграє, ви все одно можете знайти це ключове слово корисним під час реалізації членів класу, оскільки такі IDE, як Visual Studio та Visual Studio Code, увімкнуть IntelliSense, якщо це вказано. Це може бути корисним, якщо ви забули ім’я члена класу і хочете швидко пригадати визначення. Також this використовується при генерації конструеторів.

Загальна домовленість про іменування полягає в тому, щоб приватні (або внутрішні) імена змінних на рівні класу починалися з підкреслення (наприклад, _driverName), щоб IntelliSense показував усі ваші змінні у верхній частині списку. У нашому тривіальному прикладі всі поля є відкритими, тому ця угода про найменування не застосовуватиметься.

### З’єднання викликів конструктора за допомогою this

Інше використання ключового слова this полягає в створенні класу за допомогою техніки, яка називається ланцюгом конструктора. Цей шаблон проектування корисний, якщо у вас є клас, який визначає кілька конструкторів. З огляду на те, що конструктори часто перевіряють вхідні аргументи для виконання різних бізнес-правил, у наборі конструктора класу може бути досить часто знайти надлишкову логіку перевірки. Розглянемо наступний оновлений класс:

```cs
public class Motorcycle1
{
    public int driverIntensity;
    public string driverName;

    public Motorcycle1() { }
    // Redundant constructor logic!
    public Motorcycle1(int intensity)
    {
        if (intensity > 10)
        {
            intensity = 10;
        }
        driverIntensity = intensity;
    }
    public Motorcycle1(int intensity, string name)
    {
        if (intensity > 10)
        {
            intensity = 10;
        }
        driverIntensity = intensity;
        driverName = name;
    }
}
```
Тут (можливо, намагаючись забезпечити безпеку водія) кожен конструктор гарантує, що рівень інтенсивності ніколи не перевищує 10. Ми маємо надлишкові оператори коду в двох конструкторах. Це далеко не ідеально, оскільки тепер вам потрібно оновлювати код у кількох місцях, якщо ваші правила змінюються (наприклад, якщо інтенсивність не повинна перевищувати 5, а не 10). 

Одним із способів покращити поточну ситуацію є визначення методу в класі Motorcycle, який перевірятиме вхідні аргументи. Якби ви це зробили, кожен конструктор міг би викликати цей метод перед призначенням полів. Хоча цей підхід дозволяє виділити код, який потрібно оновити, коли змінюються бізнес-правила, тепер ви маєте справу з такою надмірністю:

```cs
public class Motorcycle2
{
    public int driverIntensity;
    public string driverName;

    // Constructors.
    public Motorcycle2() { }
    public Motorcycle2(int intensity)
    {
        SetIntensity(intensity);
    }
    public Motorcycle2(int intensity, string name)
    {
        SetIntensity(intensity);
        driverName = name;
    }
    public void SetIntensity(int intensity)
    {
        if (intensity > 10)
        {
            intensity = 10;
        }
        driverIntensity = intensity;
    }
}
```

Чистіший підхід полягає в тому, щоб призначити конструктор, який приймає найбільшу кількість аргументів, як «головний конструктор», а його реалізація виконувати необхідну логіку перевірки. Інші конструктори можуть використовувати ключове слово this для пересилання вхідних аргументів головному конструктору та надання будь-яких додаткових параметрів за потреби. Інші конструктори можуть використовувати ключове слово this для пересилання вхідних аргументів головному конструктору та надання будь-яких додаткових параметрів за потреби. Таким чином, вам потрібно турбуватися лише про підтримку одного конструктора для всього класу, тоді як інші конструктори в основному порожні.

```cs
public class Motorcycle3
{
    public int driverIntensity;
    public string driverName = null!;
    public Motorcycle3()
    {
    }
    public Motorcycle3(int driverIntensity) : this(driverIntensity,"")
    {
    }
    public Motorcycle3(string driverName) :this(0,driverName) 
    {
    }
    public Motorcycle3(int driverIntensity, string driverName)
    {
        if (driverIntensity > 10)
        {
            driverIntensity = 10;
        }
        this.driverIntensity = driverIntensity;
        this.driverName = driverName;
    }
}
```

Використання ключового слова this для ланцюжкових викликів конструктора ніколи не є обов’язковим. Однак, коли ви використовуєте цю техніку, ви, як правило, отримуєте більш зручне та стисле визначення класу. Знову ж таки, використовуючи цю техніку, ви можете спростити свої завдання програмування, оскільки реальна робота делегується одному конструктору (зазвичай конструктору, який має найбільше параметрів), тоді як інші конструктори просто «перекладають відповідальність».

### Спостереження за потоком конструктора

Після того, як конструктор передає аргументи призначеному головному конструктору (і цей конструктор обробив дані), конструктор, викликаний спочатку викликачем, завершить виконання будь-яких інструкцій коду, що залишилися.

```cs
public class Motorcycle4
{
    public int driverIntensity;
    public string? driverName;

    // Constructor chaining.
    public Motorcycle4()
    {
        Console.WriteLine("In default constructor");
    }
    public Motorcycle4(int driverIntensity) : this(driverIntensity,null)
    {
        Console.WriteLine("In constructor taking an int");
    }
    public Motorcycle4(string driverName) : this(default,driverName) 
    {
        Console.WriteLine("In constructor taking a string");
    }
    // This is the 'main' constructor that does all the real work.
    public Motorcycle4(int driverIntensity, string? driverName)
    {
        Console.WriteLine("In main constructor");
        if (driverIntensity > 10)
        {
            driverIntensity = 10;
        }
        this.driverIntensity = driverIntensity;
        this.driverName = driverName;
    }
    public void Drive()
    {
        Console.WriteLine($"I am {driverName}");
        for (int i = 0; i < driverIntensity; i++)
        {
            Console.WriteLine($"Yeeeeeee Haaaaaeewww!");
        }        
    }
    public void SetName(string driverName)
    {
        this.driverName = driverName;
    }
}
```
Створемо і використаємо екземпляр класу.

```cs
static void ObservingConstructorFlow()
{
    Motorcycle4 motorcycle = new(7);
    motorcycle.SetName("John");
    motorcycle.Drive();
}
ObservingConstructorFlow();
```
```
In main constructor
In constructor taking an int
I am John
Yeeeeeee Haaaaaeewww!
Yeeeeeee Haaaaaeewww!
Yeeeeeee Haaaaaeewww!
Yeeeeeee Haaaaaeewww!
Yeeeeeee Haaaaaeewww!
Yeeeeeee Haaaaaeewww!
Yeeeeeee Haaaaaeewww!
```
Як ви можете бачити, потік логіки конструктора такий:

    Ви створюєте свій об’єкт, викликаючи конструктор, який вимагає один int.

    Цей конструктор пересилає надані дані головному конструктору та надає будь-які додаткові аргументи запуску, не вказані викликачем.

    Головний конструктор призначає вхідні дані даним поля об’єкта.

    Управління повертається до конструктора, який був спочатку викликаний, і виконує будь-які залишкові оператори коду.

Приємно у використанні ланцюжка конструкторів те, що цей шаблон програмування працюватиме з будь-якою версією мови C# і платформи .NET.

### Необов’язкові аргументи в конструкторах

Необов’язкові аргументи дозволяють визначати надані значення за замовчуванням для вхідних аргументів метода або конструктора. Якщо абонента влаштовують ці значення за замовчуванням, йому не потрібно вказувати унікальне значення; однак вони можуть зробити це, щоб надати об’єкту спеціальні дані. Розглянемо наступну версію Motorcycle, яка тепер надає декілька способів створення об’єктів за допомогою єдиного визначення конструктора:

```cs
public class Motorcycle5
{
    public int driverIntensity;
    public string? driverName;

    public Motorcycle5(int driverIntensity = 0, string? driverName = null)
    {
        if (driverIntensity > 10)
        {
            driverIntensity = 10;
        }
        this.driverIntensity = driverIntensity;
        this.driverName = driverName;
    }
    public void Drive()
    {
        Console.WriteLine($"\tI am {driverName}");
        for (int i = 0; i < driverIntensity; i++)
        {
            Console.WriteLine($"Yeeeeeee Haaaaaeewww!");
        }
        Console.WriteLine();
    }
}
```
За допомогою цього єдиного конструктора тепер ви можете створити новий об’єкт Motorcycle, використовуючи нуль, один або два аргументи. Пам’ятайте, що синтаксис іменованого аргументу дозволяє вам фактично пропустити прийнятні параметри за замовчуванням

```cs
static void ConstructorWithOptionalArguments()
{
    Motorcycle5 motorcycle1 = new();
    motorcycle1.Drive();

    Motorcycle5 motorcycle2 = new(3);
    motorcycle2.Drive();

    Motorcycle5 motorcycle3 = new(driverName:"Jack");
    motorcycle3.Drive();

    Motorcycle5 motorcycle4 = new(7,"Max");
    motorcycle4.Drive();

}
ConstructorWithOptionalArguments();
```

```
        I am

        I am
Yeeeeeee Haaaaaeewww!
Yeeeeeee Haaaaaeewww!
Yeeeeeee Haaaaaeewww!

        I am Jack

        I am Max
Yeeeeeee Haaaaaeewww!
Yeeeeeee Haaaaaeewww!
Yeeeeeee Haaaaaeewww!
Yeeeeeee Haaaaaeewww!
Yeeeeeee Haaaaaeewww!
Yeeeeeee Haaaaaeewww!
Yeeeeeee Haaaaaeewww!
```
У будь-якому випадку, на цьому етапі ви можете визначити клас із даними полів (такими як змінні-члени) і різними операціями, такими як методи та конструктори.


## Розуміння ключового слова static

Клас C# може визначати будь-яку кількість статичних членів, які оголошуються за допомогою ключового слова static. Коли ви це робите, відповідний член має бути викликаний безпосередньо з рівня класу, а не з посилання на змінну об’єкта. Щоб проілюструвати відмінність, розглянемо System.Console. Як ви бачили, ви не викликаєте метод WriteLine() на рівні об’єкта:

```cs
// Compiler error! WriteLine() is not an object level method!
Console c = new Console();
c.WriteLine("I can't be printed...");
```
Замість цього просто додайте префікс імені класу до статичного члена WriteLine().

```cs
// Correct! WriteLine() is a static method.
Console.WriteLine('Much better! Thanks...');
```
Простіше кажучи, статичні члени - це елементи, які вважаються (розробником класу) настільки звичайними, що немає необхідності створювати екземпляр класу перед викликом члена. Хоча будь-який клас може визначати статичні члени, вони досить часто зустрічаються в службових класах. За визначенням, службовий клас — це клас, який не підтримує жодного стану на рівні об’єкта та не створюється за допомогою ключового слова new. Швидше, службовий клас розкриває всю функціональність за домоиогою членів рівня класу.
Наприклад, якщо ви використаєте Visual Studio Object Browser (через пункт меню View ➤ Object Browser) для перегляду системного простору імен, ви побачите, що всі члени класів Console, Math, Environment та GC відображають усі свої функції через статичні члени.
Знову ж таки, майте на увазі, що статичні члени зустрічаються не лише в класах утиліт; вони можуть бути частиною будь-якого визначення класу взагалі. Просто пам’ятайте, що статичні члени просувають даний елемент на рівень класу, а не на рівень об’єкта. Як ви побачите в наступних кількох розділах, ключове слово static можна застосувати до наступного:

    Дані класу

    Методи класу

    Властивості класу

    Конструктор

    Повне визначення класу

    У поєднанні з ключовим словом C# using

Давайте розглянемо кожен із наших варіантів, починаючи з концепції статичних даних. Ви дослідите роль статичних властивостей пізніше в цій главі, вивчаючи самі властивості.

### Визначення статичного поля даних

У більшості випадків, розробляючи клас, ви визначаєте дані як дані рівня екземпляра або, іншими словами, як нестатичні дані. Визначаючи дані на рівні екземпляра, ви знаєте, що кожного разу, коли ви створюєте новий об'єкт, об'єкт підтримує власну незалежну копію даних. Навпаки, коли ви визначаєте статичні дані класу, пам’ять використовується спільно для всіх об’єктів створених на базі класу.

Щоб побачити різницю, створіть новий проект консольної програми під назвою StaticDataAndMembers. Тепер вставте файл у свій проект під назвою SavingsAccount.cs і створіть у цьому файлі новий клас під назвою SavingsAccount. Почніть із визначення змінної рівня екземпляра (для моделювання поточного балансу) та спеціального конструктора для встановлення початкового балансу.

```cs
namespace StaticDataAndMembers;

class SavingsAccount
{
    // Instance-level data.
    public decimal currentBalance;
    public SavingsAccount(decimal currentBalance)
    {
        this.currentBalance = currentBalance;
    }
}

```
Коли ви створюєте об’єкти SavingsAccount, для кожного об’єкта виділяється пам’ять в якому є поле currentBalance. Таким чином, ви можете створити п’ять різних об’єктів SavingsAccount, кожен зі своїм унікальним балансом. Крім того, зміна балансу на одному рахунку не впливає на інші об’єкти.

Статичні дані, з іншого боку, виділяються один раз і спільно використовуються для всіх об’єктів однієї категорії класу. Додайте статичну змінну з назвою currInterestRate до класу SavingsAccount, для якого встановлено значення за замовчуванням 0,04.

```cs
class SavingsAccount
{
    // A static point of data.
    public static double currеntInterestRate = 0.04;
    // Instance-level data.
    //...
}
```
Створіть три екземпляри SavingsAccount у Program.cs:

```cs
using StaticDataAndMembers;

static void DefiningStaticFieldData()
{
    SavingsAccount s1 = new SavingsAccount(50);
    SavingsAccount s2 = new SavingsAccount(100);
    SavingsAccount s3 = new SavingsAccount(10000.75M);

}
DefiningStaticFieldData();
```
Розподіл даних у пам’яті виглядатиме приблизно так

![static data in memory](staticdatamember.jpg)

Тут припускається, що всі ощадні рахунки повинні мати однакову процентну ставку. Оскільки статичні дані є спільними для всіх об’єктів однієї категорії, якщо ви будь-яким чином змінили їх, усі об’єкти «побачать» нове значення під час наступного доступу до статичних даних, оскільки всі вони, по суті, переглядають одне й те саме розташування пам'яті.

Щоб зрозуміти, як змінити (або отримати) статичні дані, потрібно розглянути роль статичних методів.

### Визначення статичних методів

Давайте оновимо клас SavingsAccount, щоб визначити два статичні методи. Перший статичний метод (GetInterestRate()) поверне поточну процентну ставку, тоді як другий статичний метод (SetInterestRate()) дозволить вам змінити процентну ставку.

```cs
class SavingsAccount
{
    // A static point of data.
    public static double currеntInterestRate = 0.04;
    // Instance-level data.
    public decimal currentBalance;
    public SavingsAccount(decimal currentBalance)
    {
        this.currentBalance = currentBalance;
    }

    public static void SetInterestRate(double newRate)
    {
       currеntInterestRate = newRate;
    }

    public double GetInterestRate() => currеntInterestRate;
}
```
Тепер зверніть увагу на таке використання:

```cs
static void UsingStaticMethods()
{
    SavingsAccount s1 = new SavingsAccount(50);
    SavingsAccount s2 = new SavingsAccount(100);

    // Print the current interest rate.
    Console.WriteLine($"Interest Rate is:{SavingsAccount.GetInterestRate()}");
    
    // Make new object, this does NOT 'reset' the interest rate.
    SavingsAccount s3 = new SavingsAccount(10000.75M);
    Console.WriteLine($"Interest Rate is:{SavingsAccount.GetInterestRate()}");

    SavingsAccount.SetInterestRate(0.05);
    Console.WriteLine($"Interest Rate is:{SavingsAccount.GetInterestRate()}");

    SavingsAccount s4 = new SavingsAccount(20000);
    Console.WriteLine($"Interest Rate is:{SavingsAccount.GetInterestRate()}");
}
UsingStaticMethods();
```
```
Interest Rate is:0,04
Interest Rate is:0,04
Interest Rate is:0,05
Interest Rate is:0,05
```
Як ви бачите, коли ви створюєте нові екземпляри класу SavingsAccount, значення статичних даних не скидається, оскільки CoreCLR розміщуватиме статичні дані в пам’яті рівно один раз. Після цього всі об’єкти типу SavingsAccount працюють з тим самим значенням для статичного поля currentInterestRate.

Під час проектування будь-якого класу C# одним із завдань проектування є визначення того, які фрагменти даних слід визначати як статичні члени, а які ні. Хоча жорстких правил немає, пам’ятайте, що статичне поле даних є спільним для всіх об’єктів цього типу. Таким чином, якщо ви визначаєте точку даних, яку мають спільно використовувати всі об’єкти, статика є способ як іти.

Поміркуйте, що сталося б, якби змінну відсоткової ставки не було визначено за допомогою ключового слова static. Це означає, що кожен об’єкт SavingsAccount матиме власну копію поля currentInterestRate. Тепер припустімо, що ви створили 100 об’єктів SavingsAccount і вам потрібно змінити процентну ставку. Для цього потрібно було б викликати метод SetInterestRate() 100 разів! Очевидно, що це не буде корисним способом моделювання «спільних даних». Знову ж таки, статичні дані ідеальні, коли у вас є значення, яке має бути спільним для всіх об’єктів цієї категорії.

### Визначення статичних конструкторів

Типовий конструктор використовується для встановлення значення даних рівня екземпляра об’єкта під час створення. Однак що станеться, якщо ви спробуєте призначити значення статичної точки даних у типовому конструкторі? Ви можете бути здивовані, виявивши, що значення скидається щоразу, коли ви створюєте новий об’єкт.

```cs
class SavingsAccount1
{
    public static double currеntInterestRate;
    public decimal currentBalance;

    public SavingsAccount1(decimal currentBalance)
    {
        this.currentBalance = currentBalance;
        currеntInterestRate = 0.04; // This is static data!
    }
    public static double GetInterestRate() => currеntInterestRate;

    public static void SetInterestRate(double newRate)
    {
        currеntInterestRate = newRate;
    }
}
```
Тепер припустімо, що ви створили такий код:

```cs
static void StaticDataInConstructor()
{
    SavingsAccount1 s1 = new(50);
    Console.WriteLine($"Interest Rate is: {SavingsAccount1.GetInterestRate()}");

    // Try to change the interest rate via property.
    SavingsAccount1.SetInterestRate(0.08);

    SavingsAccount1 s2 = new(100);
    Console.WriteLine($"Interest Rate is: {SavingsAccount1.GetInterestRate()}");

}
StaticDataInConstructor();
```
```
Interest Rate is: 0,04
Interest Rate is: 0,04
```
Якщо ви виконали попередній код, ви побачите, що змінна currInterestRate скидається кожного разу, коли ви створюєте новий об’єкт SavingsAccount, і вона завжди має значення 0,04. Зрозуміло, що встановлення значення статичних даних у звичайному конструкторі рівня екземпляра ніби перешкоджає меті. Щоразу, коли ви створюєте новий об’єкт, дані рівня класу скидаються. Одним із підходів до встановлення статичного поля є використання синтаксису ініціалізації члена, як ви робили спочатку.

```cs
class SavingsAccount
{
    public static double currеntInterestRate = 0.04;
    //...
}
```
Цей підхід забезпечить призначення статичного поля лише один раз, незалежно від кількості створених об’єктів. Однак що, якщо значення для ваших статичних даних необхідно отримати під час виконання? Наприклад, у типовій банківській програмі значення змінної відсоткової ставки зчитується з бази даних або зовнішнього файлу. Для виконання таких завдань зазвичай потрібна область дії методу, наприклад конструктор для виконання операторів коду. З цієї причини C# дозволяє вам визначити статичний конструктор, який дозволяє безпечно встановлювати значення ваших статичних даних. Розглянемо таке оновлення для вашого класу:

```cs
class SavingsAccount2
{
    public static double currеntInterestRate;
    public decimal currentBalance;

    // A static constructor!
    static SavingsAccount2()
    {
        Console.WriteLine("In static constructor!");
        currеntInterestRate = 0.04;
    }
    //...
}
```
Простіше кажучи, статичний конструктор — це спеціальний конструктор, який є ідеальним місцем для ініціалізації значень статичних даних, коли значення невідоме під час компіляції (наприклад, вам потрібно прочитати значення із зовнішнього файлу, прочитати значення з бази даних, згенерувати випадкове число або щось інше).

Запустили аналогічний код, ви б побачите очікуваний результат. Зверніть увагу, що повідомлення «In static constructor!» друкує лише один раз, оскільки CoreCLR викликає всі статичні конструктори перед першим використанням (і ніколи не викликає їх знову для цього екземпляра програми).

```cs
class SavingsAccount2
{
    public static double currеntInterestRate;
    public decimal currentBalance;
    // A static constructor!
    static SavingsAccount2()
    {
        Console.WriteLine("In static constructor!");
        currеntInterestRate = 0.04;
    }
    //...
}
```
```
In static constructor!
Interest Rate is: 0,04
Interest Rate is: 0,08
```
Ось кілька цікавих моментів щодо статичних конструкторів:

    Даний клас може визначати лише один статичний конструктор.Іншими словами, статичний конструктор не можна перевантажувати.

    Статичний конструктор не приймає модифікатор доступу та не може приймати жодних параметрів.

    Статичний конструктор виконується рівно один раз, незалежно від кількості створених об’єктів типу.

    Середовище виконання викликає статичний конструктор, коли створює екземпляр класу або перед доступом до першого статичного члена, викликаного абонентом.

    Статичний конструктор виконується перед будь-якими конструкторами рівня екземпляра.

Враховуючи цю модифікацію, коли ви створюєте нові об’єкти SavingsAccount, значення статичних даних зберігається, оскільки статичний член встановлюється лише один раз у статичному конструкторі, незалежно від кількості створених об’єктів.

### Визначення статичних класів

Також можна застосувати ключове слово static безпосередньо до класу. Якщо клас визначено як статичний, його неможливо створити за допомогою ключового слова new і він може містити лише члени або поля даних, позначені ключовим словом static.
Пам'ятайте, що клас (або структура), який надає лише статичну функціональність, часто називають класом корисності(a utility class). При розробці класу корисності до визначення класу рекомендується застосувати ключове слово static.

На перший погляд це може здатися досить дивною функцією, враховуючи те, що клас, який неможливо створити, не виглядає настільки корисним. Однак, якщо ви створюєте клас, який не містить нічого, крім статичних членів та/або постійних даних, класу не потрібно спочатку десь розташовувати в пам'яті. Для ілюстрації створіть новий клас під назвою TimeUtilClass і визначте його так:

```cs
namespace StaticDataAndMembers;

static class TimeUtilClass
{
    public static void PrintTime()
    {
        Console.WriteLine(DateTime.Now.ToShortTimeString());
    }
    public static void PrintDate()
    {
        Console.WriteLine(DateTime.Today.ToShortDateString());
    }
}
```
Оскільки цей клас було визначено за допомогою ключового слова static, ви не можете створити екземпляр TimeUtilClass за допомогою ключового слова new. Навпаки, всі функції доступні на рівні класу. Щоб перевірити цей клас, додайте наступне:

```cs
static void UsingAStaticClass()
{
    // These compile just fine.
    TimeUtilClass.PrintDate();
    TimeUtilClass.PrintTime();
    // Compiler error! Can't create instance of static classes!
    //TimeUtilClass u = new TimeUtilClass();
}
UsingAStaticClass();
```

### Імпорт статичних членів за допомогою ключового слова C# using

C# підтримує імпорту статичних елементів за допомогою ключового слова using. Розглянемо останій визначений класс. Оскільки ви здійснюєте виклики методу WriteLine() класу Console, а також властивостей Now і Today класу DateTime, ви повинні мати оператор using для простору імен System. Оскільки всі члени цих класів є статичними, ви можете змінити свій файл коду за допомогою таких директив static using:

```cs
// Import the static members of Console and DateTime.
using static System.Console;
using static System.DateTime;

namespace StaticDataAndMembers;

static class TimeUtilClass1
{
    public static void PrintTime()
    {
        WriteLine(Now.ToShortTimeString());
    }
    public static void PrintDate()
    {
        WriteLine(Today.ToShortDateString());
    }
}
```
Більш реалістичний приклад спрощення коду з імпортом статичних членів може включати клас C#, який значною мірою використовує клас System.Math (або інший допоміжний клас). Оскільки в цьому класі немає нічого, крім статичних членів, було б дещо простіше мати оператор static using для цього типу, а потім безпосередньо викликати члени класу Math у вашому кодовому файлі.

Однак майте на увазі, що надмірне використання статичних операторів імпорту може призвести до потенційної плутанини. По-перше, що, якщо кілька класів визначають метод WriteLine()? Компілятор заплутався, як і інші, які читають ваш код. По-друге, якщо розробники не знайомі з бібліотеками коду .NET Core, вони можуть не знати, що WriteLine() є членом класу Console. Якщо люди не помітять набір статичних імпортів у верхній частині файлу коду C#, вони можуть бути зовсім не впевнені, де насправді визначено цей метод.
У будь-якому випадку, на цьому етапі глави ви повинні відчувати себе комфортно, визначаючи прості типи класів, що містять конструктори, поля та різні статичні (і нестатичні) члени. Тепер, коли ви розумієте основи побудови класів, ви можете офіційно дослідити три стовпи об’єктно-орієнтованого програмування.

# Визначення основ ООП

Усі об’єктно-орієнтовані мови (C#, Java, C++ тощо) повинні відповідати цим трьом основним принципам, які часто називають стовпами об’єктно-орієнтованого програмування (ООП):

    Інкапсуляція: як ця мова приховує деталі внутрішньої реалізації об’єкта та зберігає цілісність даних?

    Спадкування: як ця мова сприяє повторному використанню коду?

    Поліморфізм: як ця мова дозволяє обробляти пов’язані об’єкти подібним чином?

Перш ніж заглиблюватися в деталі кожного стовпа, важливо зрозуміти їх основні ролі. Ось огляд кожного стовпа, який буде детально розглянуто в решті цього розділу та в наступному.


### Розуміння ролі інкапсуляції

Перший стовп ООП називається інкапсуляцією. Ця властивість зводиться до здатності мови приховувати від користувача об’єкта непотрібні деталі реалізації. Наприклад, припустімо, що ви використовуєте клас DatabaseReader, який має два основні методи Open() і Close().

```cs
// Assume this class encapsulates the details of opening and closing a database.
DatabaseReader dbReader = new DatabaseReader();
dbReader.Open(@"C:\AutoLot.mdf");
// Do something with data file and close the file.
dbReader.Close();
```
Вигаданий клас DatabaseReader інкапсулює внутрішні деталі пошуку, завантаження, обробки та закриття файлу даних. Програмісти люблять інкапсуляцію, оскільки ця основа ООП спрощує завдання кодування. Немає необхідності турбуватися про численні рядки коду, які працюють за лаштунками, щоб виконувати роботу класу DatabaseReader. Все, що вам потрібно зробити, це створити екземпляр і надіслати відповідні повідомлення (наприклад, «Відкрийте базу данних під назвою AutoLot.mdf, розташований на моєму диску C»).
З поняттям інкапсуляції логіки програмування тісно пов’язана ідея захисту даних. В ідеалі дані про стан об’єкта мають бути вказані за допомогою ключового слова private, internal або protected. Таким чином, зовнішній світ повинен ввічливо запитувати, щоб змінити або отримати базові значеня даних. Це добре, оскільки публічно оголошені точки даних можуть бути легко пошкоджені (в ідеалі випадково, а не навмисно!).

### Розуміння ролі успадкування

Наступний стовп ООП, успадкування, зводиться до здатності мови дозволяти створювати нові визначення класів на основі існуючих визначень класів. По суті, успадкування дозволяє вам розширити поведінку базового (або батьківського) класу, успадкувавши основні функції в похідний підклас (також званий дочірнім класом).

Відношення «is-a».
![Inheritance](Inheritance.jpg)

Ви можете прочитати схему на малюнку так: «A Hexagon is-a Shape that is-an Object.». Коли у вас є класи, пов’язані цією формою успадкування, ви встановлюєте зв’язки «is-a» між типами. Відношення «is-a» називають успадкуванням.
Тут можна припустити, що Shape визначає деяку кількість членів, які є спільними для всіх нащадків (можливо, значення для представлення кольору для малювання фігури та інші значення для представлення висоти та ширини). Враховуючи те, що клас Hexagon розширює Shape, він успадковує основні функції, визначені Shape і Object, а також визначає власні додаткові деталі, пов’язані з шестикутниками (якими б вони не були).

На платформах .NET/.NET Core System.Object завжди є найвищим батьківським елементом у будь-якій ієрархії класів, що визначає деякі загальні функції для всіх типів

У світі ООП існує ще одна форма повторного використання коду: модель обмеження/делегування, також відома як зв’язок «has-a» або агрегація.Ця форма повторного використання не використовується для встановлення стосунків батьків і дітей. Швидше, відношення «has-a» дозволяє одному класу визначати змінну-член іншого класу та надавати її функціональні можливості (якщо потрібно) користувачеві об’єкта опосередковано.
Наприклад, припустимо, що ви знову моделюєте автомобіль. Можливо, ви захочете висловити думку про те, що Car «has-a» Radio. Було б нелогічно намагатися вивести клас Car з Radio або навпаки (Car «is-a» Radio? Я думаю, ні!). Натомість у вас є два незалежних класи, які працюють разом, де клас Автомобіль створює та розкриває функціональні можливості Радіо.

Подивимось в проекті OOPExamples

```cs
namespace OOPExamples;

class Radio
{
    bool state;
    public void ChangeState(bool state)
    {
        this.state = state;
    }
    public void GetState()
    {
        string result = state ? "Radio is on" : "Radio is off";
        
        Console.WriteLine(result);
    }
}
```
```cs
class Car
{
    // Car 'has-a' Radio.
    private Radio _radio = new();
    public Car()
    {
        _radio.GetState();
    }
    public void TurnOnRadio()
    {
        // Delegate call to inner object.
        _radio.ChangeState(true);
        _radio.GetState();
    }
}
```

Зауважте, що користувач об’єкта не знає, що клас Car використовує внутрішній об’єкт Radio
```cs
using OOPExamples;

static void HasARelationship()
{
    Car car = new Car();
    car.TurnOnRadio();
}
HasARelationship();
```
```
Radio is off
Radio is on

```

### Розуміння ролі поліморфізму

Останнім стовпом ООП є поліморфізм. Ця риса фіксує здатність мови обробляти пов’язані об’єкти подібним чином. Зокрема, ця можливість об’єктно-орієнтованої мови дозволяє базовому класу визначати набір членів (офіційно названих поліморфним інтерфейсом), які доступні для всіх нащадків. Поліморфний інтерфейс класу створюється з використанням будь-якої кількості віртуальних або абстрактних членів (додаткову інформацію див. наступний розділ).
У двох словах, віртуальний член — це член базового класу, який визначає реалізацію за замовчуванням, яка може бути змінена (або більш формально кажучи, перевизначена) похідним класом. Навпаки, абстрактний метод є членом базового класу, який не забезпечує реалізацію за замовчуванням, але надає сігнатуру(дані шо отримується і шо вертається). Коли клас походить від базового класу, що визначає абстрактний метод, він повинен бути перевизначений похідним типом. У будь-якому випадку, коли похідні типи замінюють члени, визначених базовим класом, вони, по суті, перевизначають те, як вони відповідають на той самий запит.

Щоб переглянути поліморфізм, давайте надамо деякі деталі ієрархії форм, показаної на малюнку.

![polimorphism](Polimophism.jpg)

Припустімо, що клас Shape визначив віртуальний метод під назвою Draw(), який не приймає параметрів. З огляду на те, що кожна форма повинна відтворюватися унікальним чином, підкласи, такі як Hexagon і Circle, можуть вільно змінювати цей метод на власний смак.

Після розробки поліморфного інтерфейсу ви можете почати робити різні припущення у своєму коді. Наприклад, враховуючи, що Hexagon і Circle походять від спільного батька (Shape), масив типів Shape може містити все, що походить від цього базового класу. Крім того, враховуючи, що Shape визначає поліморфний інтерфейс для всіх похідних типів (метод Draw() у цьому прикладі), ви можете припустити, що кожен член масиву має цю функціональність.

```cs
Shape[] myShapes = new Shape[3];
myShapes[0] = new Hexagon();
myShapes[1] = new Circle();
myShapes[2] = new Hexagon();
foreach (Shape s in myShapes)
{
  // Use the polymorphic interface!
  s.Draw();
}
```

# Розуміння модифікаторів доступу C# 

Працюючи з інкапсуляцією, ви завжди повинні враховувати, які аспекти типу видимі для різних частин вашої програми. Зокрема, типи (класи, інтерфейси, структури, перерахування та делегати), а також їхні члени (властивості, методи, конструктори та поля) визначаються за допомогою певного ключового слова, щоб контролювати, наскільки «видимим» елемент є для інших частин вашого додатку. 
Хоча C# визначає численні ключові слова для керування доступом, вони відрізняються тим, де їх можна успішно застосувати (тип чи член). Таблиця документує роль кожного модифікатора доступу та місце його застосування.

Модифікатори доступу C#


|Модифікатор доступу|Може застосовуватися до|Сенс використаня|
|-------------------|-----------------------|------------------|
|public|Типи або члени типу|Загальнодоступні елементи не мають обмежень доступу.Доступ до відкритого члена можна отримати з об’єкта, а також з будь-якого похідного класу.Доступ до відкритого типу можна отримати з інших зовнішніх збірок.|
|private|Члени типу або вкладені типи|Доступ до приватних елементів може отримати лише клас (або структура), який визначає елемент.|
|protected|Члени типу або вкладені типи|Захищені елементи можуть використовуватися класом, який їх визначає, і будь-яким дочірнім класом. До них неможливо отримати доступ поза ланцюжком успадкування.|
|internal|Типи або члени типу|Внутрішні елементи доступні лише в межах поточної збірки.Іншим збіркам можна явно надати дозвіл на перегляд внутрішніх елементів.|
|protected internal|Члени типу або вкладені типи|Коли protected та internal ключові слова поєднуються в елементі, елемент доступний у визначальній збірці, у визначальному класі та похідних класах усередині чи поза визначальною збіркою.|
|private protected|Члени типу або вкладені типи|Коли private та protected ключові слова поєднуються в елементі, елемент доступний у межах визначального класу та похідних класів у тій же збірці.|

У цій главі розлядяються лише public та private ключові слова. У наступних розділах буде розглянуто роль internal і protected internal модифікаторів (корисно, коли ви створюєте бібліотеки коду та модульні тести) і модифікатор protected (корисно, коли ви створюєте ієрархії класів).

### Використання модифікаторів доступу за замовчуванням

За замовчуванням члени типу є неявно private, тоді як типи є неявно internal. Таким чином, наступне визначення класу автоматично встановлюється як internal, тоді як конструктор типу за замовчуванням автоматично встановлюється як private (однак, як ви підозрюєте, є декілька випадків, коли вам потрібен конструктор приватного класу):

```cs
// An internal class with a private default constructor.
class Radio
{
  Radio(){}
}
```
Якщо ви хочете вказати явно, ви можете додати ці ключові слова самостійно без жодних негативних наслідків.

```cs
// An internal class with a private default constructor.
internal class Radio
{
  private Radio(){}
}
```
Щоб дозволити іншим частинам програми викликати членів об’єкта, ви повинні визначити їх за допомогою ключового слова public (або, можливо, за допомогою ключового слова protected, про яке ви дізнаєтесь у наступному розділі). Крім того, якщо ви хочете надати Radio зовнішнім збіркам (знову ж таки, корисно під час створення більших рішень або бібліотек коду), вам потрібно буде додати модифікатор public.

```cs
// A public class with a public default constructor.
public class Radio
{
  public Radio(){}
}
```
### Використання модифікаторів доступу та вкладених типів

Як зазначено в таблиці модифікатори доступу private, protected, protected internal і private protected можна застосовувати до вкладеного типу. Наступний розділ детально розгляне вкладеність. Однак на цьому етапі вам потрібно знати, що вкладений тип — це тип, оголошений безпосередньо в межах класу або структури. Як приклад, ось приватне перерахування (під назвою CarColor), вкладене в публічний клас (під назвою SportsCar):

```cs
namespace OopExamples;
public class SportsCar
{
  // Nested types can be marked private.
  private enum CarColor
  {
    Red, Green, Blue
  }
}
```
Тут допустимо застосовувати модифікатор приватного доступу до вкладеного типу. Однак невкладені типи (такі як SportsCar) можна визначити лише за допомогою public або  internal модифікатора. Таким чином, таке визначення класу не має сенсу:

```cs
// Error! Non-nested types cannot be marked private!
private class SportsCar
{}
```

# Розуміння першого принципу ООП : служби інкапсуляції C#

Концепція інкапсуляції обертається навколо поняття, що дані об’єкта не повинні бути безпосередньо доступними з примірника об’єкта. Швидше, дані класу визначаються як приватні. Якщо користувач об’єкта хоче змінити стан об’єкта, він робить це опосередковано за допомогою публічних членів. 
Щоб проілюструвати потребу в службах інкапсуляції, припустимо, що ви створили таке визначення класу:

```cs
namespace OOPExamples;

class Book
{
    public int numberOfPages;
}
```
Проблема з загальнодоступними даними полягає в тому, що самі дані не здатні «розуміти», чи є поточне значення, якому вони присвоєні, дійсним щодо поточних бізнес-правил системи. Як ви знаєте, верхній діапазон C# int досить великий (2 147 483 647). Таким чином, компілятор дозволяє наступне призначення:

```cs
static void UnderstandingEncapsulation()
{
    // Humm. That is one heck of a mini-novel!
    Book miniNovel = new Book();
    miniNovel.numberOfPages = 30_000_000;
}
```
Хоча ви не вийшли за межі типу даних int, має бути зрозуміло, що міні-роман із кількістю сторінок у 30 000 000 сторінок є трохи нерозумним. Як бачите, загальнодоступні поля не дають можливості перехопити логічні верхні (або нижні) межі. Якщо у вашій поточній системі є бізнес-правило, згідно з яким книга має містити від 1 до 1000 сторінок, ви не можете застосувати це програмним шляхом. Через це загальнодоступним полям зазвичай немає місця у визначенні класу на рівні виробництва.

Точніше кажучи, члени класу, які представляють стан об’єкта, не повинні позначатися як публічні. Як ви побачите далі в цій главі, публічні константи та загальнодоступні поля лише для читання є досить корисними.

Інкапсуляція забезпечує спосіб збереження цілісності даних про стан об’єкта. Замість того, щоб визначати загальнодоступні поля (які можуть легко сприяти пошкодженню даних), ви повинні отримати звичку визначати приватні дані, якими опосередковано маніпулюють за допомогою одного з двох основних методів.

    Ви можете визначити пару публічних методів accessor (get) і mutator (set).

    Ви можете визначити загальнодоступну власність.

Яку б техніку ви не вибрали, суть полягає в тому, що добре інкапсульований клас повинен захищати свої дані та приховувати деталі того, як він працює, від цікавих очей зовнішнього світу. Це часто називають програмуванням чорної скриньки. Принадність цього підходу полягає в тому, що об’єкт може змінювати спосіб реалізації даного методу під капотом. Це робиться без порушення існуючого коду, що використовує його, за умови, що параметри та значення, що повертаються методом, залишаються постійними.

## Інкапсуляція з використанням традиційних Accessors та Mutators.

У цій главі ви створите досить повний клас, який моделює звичайного працівника. Щоб почати, створіть новий проект консольної програми під назвою EmployeeApp і створіть новий файл класу під назвою Employee.cs. Оновіть клас Employee таким простором імен, полями, методами та конструкторами:

```cs
namespace EmployeeApp;

class Employee1
{
    // Field data
    private int _id;
    private string _name = null!;
    private float _currentPay;

    // Constructors
    public Employee1()
    {
    }

    public Employee1(int id, string name, float currentPay)
    {
        _id = id;
        _name = name;
        _currentPay = currentPay;
    }

    //Methods
    public void GiveBonus(float amount)
    {
        _currentPay += amount;
    }

    public void DisplayStatus()
    {
        Console.WriteLine($"{_id}\t{_name}\t{_currentPay}");
    }
}
```
Зверніть увагу, що поля класу Employee наразі визначено за допомогою ключового слова private. Зважаючи на це, поля _empName, _empId і _currPay недоступні безпосередньо зі змінної об’єкта. Таким чином, така логіка у вашому коді призведе до помилок компілятора:

```cs
using EmployeeApp;

static void Attempt1()
{
    Employee1 emp = new();
    // Error! Cannot directly access private members
    // from an object!
    emp._empName = "Marv";
}
```
Якщо ви хочете, щоб зовнішній світ взаємодіяв із повним іменем працівника, традиційним підходом є визначення аксесора (метод get) і мутатора (метод set). Роль методу get полягає в тому, щоб повернути викликаючому поточне значення базових даних про стан. Метод set дозволяє викликаючому змінювати поточне значення базових даних стану, доки виконуються визначені бізнес-правила.
Для ілюстрації давайте інкапсулюємо поле empName. Для цього додайте такі публічні методи до класу Employee. Зверніть увагу, що метод SetName() перевіряє вхідні дані, щоб переконатися, що рядок містить 15 символів або менше. Якщо ні, на консоль виводиться повідомлення про помилку, яке повертається без змін поля _name.

```cs
    // Accessor (get method).
    public string GetName => _name;

    // Mutator (set method).

    public void SetName(string name)
    {
        // Do a check on incoming value
        // before making assignment.
        if (name.Length > 15)
        {
            Console.WriteLine('Error! Name length exceeds 15 characters!');
        }
        else
        {
            _name = name;
        }
    }
```
Ця техніка вимагає двох методів з унікальними назвами для роботи з однією точкою даних. Щоб перевірити ваші нові методи, оновіть метод коду таким чином:

```cs
void UsingAccessorAndMutator()
{
    Employee1 emp1 = new Employee1(1,"Martin",30_000);

    emp1.GiveBonus(1000);
    emp1.DisplayStatus();

    emp1.SetName("Marvin");
    Console.WriteLine(emp1.GetName());
}
UsingAccessorAndMutator();
```
```
1       Martin  31000
Marvin
```
Через код у вашому методі SetName(), якщо ви спробуєте вказати більше 15 символів , ви побачите жорстко закодоване повідомлення про помилку, надруковане на консолі.

```cs

    // Longer than 15 characters! Error will print to console.
    Employee1 emp2 = new();
    emp2.SetName("Big big and very power Max");
```
```
Error! Name length exceeds 15 characters!
```
Поки що все добре. Ви інкапсулювали приватне поле empName за допомогою двох публічних методів GetName() і SetName(). Якщо ви хочете додатково інкапсулювати дані в клас Employee, вам потрібно буде додати різні додаткові методи (такі як GetID(), SetID(), GetCurrentPay(), SetCurrentPay()). Кожен із методів-мутаторів може також мати різні рядки коду для перевірки додаткових бізнес-правил. Хоча це, звичайно, можна зробити, мова C# має корисну альтернативну нотацію для інкапсуляції даних класу.

## Інкапсуляція за допомогою властивостей

Хоча ви можете інкапсулювати частину даних поля за допомогою традиційних методів get і set, мови .NET Core віддають перевагу застосуванню інкапсуляції даних стану даних за допомогою властивостей. По-перше, зрозумійте, що властивості — це лише контейнер для «справжніх» методів доступу та мутатора, які називаються get і set відповідно. Таким чином, як розробник класу, ви все ще можете виконати будь-яку внутрішню логіку, необхідну перед присвоєнням значення (наприклад, увести значення у верхньому регістрі, очистити значення від недозволених символів, перевірити межі числового значення тощо). Ось оновлений клас Employee, який тепер забезпечує інкапсуляцію кожного поля за допомогою синтаксису властивостей, а не традиційних методів get і set:

```cs
class Employee2
{
    // Field data
    private int _id;
    private string _name = null!;
    private float _currentPay;

    // Properties!
    // The 'int' represents the type of data this property encapsulates.
    public int Id // Note lack of parentheses.
    {
        get { return _id; }
        set { _id = value; }
    }
    public string Name
    {
        get {  return _name; }
        set 
        {
            if (value.Length > 15)
            {
                Console.WriteLine("Error! Name length exceeds 15 characters!");
            }
            else
            {
                _name = value;
            }
        }
    }
    public float CurrentPay { get => _currentPay; set => _currentPay = value; }

}
```
Властивість C# складається шляхом визначення області отримання (аксесор) і встановлення області (мутатор) безпосередньо в самій властивості. Зверніть увагу, що властивість визначає тип даних, які вона інкапсулює, за допомогою того, що виглядає як значення, що повертається. Також зверніть увагу, що, на відміну від методу, властивості не використовують дужки (навіть порожні дужки) під час визначення. Розгляньте наступний коментар до вашої поточної властивості ідентифікатора:

```cs
    // The 'int' represents the type of data this property encapsulates.
    public int Id // Note lack of parentheses.
    {
        get { return _id; }
        set { _id = value; }
    }
```
У межах встановленої області властивості ви використовуєте маркер із іменем value, який використовується для представлення вхідного значення, яке використовується для призначення властивості визиваючого. Цей маркер не є справжнім ключовим словом C#, але є те, що відомо як контекстне ключове слово. Коли значення маркера знаходиться в межах встановленої області властивості, воно завжди представляє значення, яке призначає визиваючий код, і воно завжди матиме той самий базовий тип даних, що й сама властивість. Таким чином, зверніть увагу, як властивість Name все ще може перевірити діапазон рядка таким чином:

```cs
public string Name
{
    get {  return _name; }
    set 
    {
        if (value.Length > 15)
        {
            Console.WriteLine("Error! Name length exceeds 15 characters!");
        }
        else
        {
            _name = value;
        }
    }
}
```
Після встановлення цих властивостей абоненту здається, що він отримує та встановлює загальнодоступну точку даних; однак правильний блок get і set викликається за лаштунками, щоб зберегти інкапсуляцію.

```cs
void UsingProperties()
{
    Employee2 employee = new Employee2(1, "Martin", 30_000);

    employee.GiveBonus(1000);
    employee.DisplayStatus();

    // Set and then get the Name property.
    employee.Name = "Marvin";
    Console.WriteLine(employee.Name);
}
UsingProperties();
```
```
1       Martin  31000
Marvin
```
Властивості (на відміну від методів доступу та мутаторів) також полегшують маніпулювання типами, оскільки властивості можуть реагувати на внутрішні оператори C#. Для ілюстрації припустімо, що тип класу Employee має внутрішню приватну змінну-член, яка представляє вік працівника. Ось відповідне оновлення (зверніть увагу на використання ланцюжка конструкторів):

```cs
class Employee3
{
    // Field data
    //...
    private int _age;

    //Properties
    //...
    public int Age
    {
        get { return _age; }
        set { _age = value; }
    }

    //Constructors
    public Employee3()
    {
    }
    public Employee3(int id, string name, float currentPay) 
        : this(id, name, currentPay, 0) { }
    public Employee3(int id, string name, float currentPay, int age)
    {
        _id = id;
        _name = name;
        _currentPay = currentPay;
        _age = age;
    }

    //Methods
    //...
    public void DisplayStatus()
    {
        Console.WriteLine($"{_id}\t{_name}\t{_age}\t{_currentPay}");
    }
}
```
Тепер припустімо, що ви створили об’єкт Employee під назвою joe. У його день народження ви хочете збільшити вік на одиницю. Використовуючи традиційні методи доступу та мутатор, вам потрібно буде написати шось на зразок:

```cs
Employee joe = new Employee();
joe.SetAge(joe.GetAge() + 1);
```
Однак, якщо ви інкапсулюєте _age за допомогою властивості під назвою Age, ви можете просто написати

```cs
void UsingProperties1()
{
    Employee3 joe = new Employee3(1, "Joe", 20_000, 25);
    joe.Age++;
    joe.DisplayStatus();
}
UsingProperties1();
```
```
1       Joe     26      20000
```

### Властивості як члени з тілом виразу 

Як згадувалося раніше, засоби доступу для отримання та встановлення властивостей також можуть бути записані як елементи виразу. Правила та синтаксис ті самі: однорядкові методи можна писати за допомогою нового синтаксису. Отже, властивість Age можна записати так:

```cs
public int Age
{
  get => _age;
  set => _age = value;
}
```
Обидва синтаксиси компілюються до одного IL, тому який синтаксис ви використовуєте, ви вирішуєте повністю.

### Використання властивостей у визначенні класу

Властивості, зокрема set ​​частина властивості, є звичайними місцями для упаковки бізнес-правил вашого класу.
Наразі клас Employee має властивість Name, яка гарантує, що ім’я містить не більше 15 символів. Решта властивостей (ID, Pay і Age) також можна оновити за будь-якою відповідною логікою. Але також розглянемо, що конструктор класу зазвичай робить внутрішньо. Наразі ваш головний конструктор не перевіряє вхідні рядкові дані на дійсний діапазон, тому ви можете оновити цей член таким чином:

```cs
    public Employee3(int id, string name, float currentPay, int age)
    {
        _id = id;
        // Humm, this seems like a problem...
        if (name.Length > 15)
        {
            Console.WriteLine("Error! Name length exceeds 15 characters!");
        }
        else
        {
            _name = name;
        }
        _currentPay = currentPay;
        _age = age;
    }
```
Я впевнений, що ви бачите проблему такого підходу. Властивість Name і ваш головний конструктор виконують однакову перевірку помилок. Якби ви також перевіряли інші точки даних, у вас було б багато повторюваного коду.
Щоб оптимізувати свій код і ізолювати всю перевірку помилок у центральному місці, вам буде добре, якщо ви завжди будете використовувати властивості у своєму класі, коли вам потрібно буде отримати або встановити значення. Розглянемо такий оновлений конструктор:
```cs
    public Employee3(int id, string name, float currentPay, int age)
    {
        Id = id;
        Name = name;
        CurrentPay = currentPay;
        Age = age;
    }
```

Окрім оновлення конструкторів для використання властивостей під час присвоєння значень, корисною практикою є використання властивостей у всій реалізації класу, щоб гарантувати, що ваші бізнес-правила завжди виконуються. У багатьох випадках єдиний час, коли ви безпосередньо посилаєтеся на базову приватну частину даних, є в самій власності. З огляду на це, ось ваш оновлений клас співробітників

```cs
class Employee4
{
    // Field data
    private int _id;
    private string _name = null!;
    private float _pay;
    private int _age;

    //Properties
    public int Id { get => _id; set => _id = value; }
    public string Name
    {
        get => _name; 
        set
        {
            if (value.Length > 15)
            {
                Console.WriteLine("Error! Name length exceeds 15 characters!");
            }
            else
            {
                _name = value;
            }
        }
    }
    public float Pay { get => _pay; set => _pay = value; }
    public int Age { get => _age; set => _age = value; }

    //Constructors
    public Employee4(int id, string name, float pay, int age)
    {
        Id = id;
        Name = name;
        Pay = pay;
        Age = age;
    }
    public Employee4(int id, string name, float pay) : this(id,name,pay,default)
    {}
    public Employee4()
    {}

    // Mathods
    public void GiveBonus(float amount)
    {
        Pay += amount;
    }
    public void DisplayStatus()
    {
        Console.WriteLine($"{Id}\t{Name}\t{Age}\t{Pay}");
    }
}
```

### 