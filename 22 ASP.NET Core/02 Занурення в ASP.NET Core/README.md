# Занурення в ASP.NET Core

У цьому розділі детально розглядаються функції ASP.NET Core. У міру вивчення цих функцій ви додаватимете їх до проектів, створених у попередній главі.

## Що нового в ASP.NET Core

Окрім підтримки базової функціональності ASP.NET MVC та ASP.NET Web API, Microsoft додала безліч нових функцій та покращень порівняно з попередніми фреймворками. Окрім об’єднання фреймворків та контролерів, тепер підтримується новий стиль вебзастосунків за допомогою сторінок Razor. Ось деякі додаткові покращення та нововведення:

    Веб-додатки на основі Razor Page
    Обізнаність щодо середовища
    Мінімальні шаблони з операторами верхнього рівня
    Система конфігурації, готова до хмарних технологій, на основі середовища
    Вбудоване впровадження залежностей
    Шаблон «Опції»
    Фабрика HTTP-клієнтів
    Гнучкі моделі розробки та розгортання
    Легкий, високопродуктивний та модульний конвеєр HTTP-запитів
    Помічники тегів
    Компоненти View
    Значні покращення продуктивності
    Інтегрований журнал(logging)


# Сторінки Razor (Razor Pages)

Іншим варіантом створення вебзастосунків за допомогою ASP.NET Core є використання сторінок Razor. Замість використання шаблону MVC, сторінкові додатки Razor (як випливає з назви) орієнтовані на сторінки. Кожна сторінка Razor складається з двох файлів: файлу сторінки (наприклад, Index.cshtml) – це представлення, а класу C# PageModel (наприклад, Index.cshtml.cs) – це файл коду для файлу сторінки в якому обробляються події.
Веб-застосунки на основі сторінок Razor також підтримують часткові та макетні представлення, які будуть детально розглянуті в наступних розділах.

## Файл предсавлення Razor Pages

Як і у веб-застосунках на основі MVC, файл сторінки Razor відповідає за відображення вмісту сторінки та отримання вхідних даних від користувача. Як і у веб-застосунках на основі MVC, файл сторінки Razor відповідає за відображення вмісту сторінки та отримання вхідних даних від користувача. Файли сторінок Razor будуть детально розглянуті в окремій главі притсвяченій Razor Pages.

## Клас PageModel

Як і клас Controller для застосунків у стилі MVC, клас PageModel надає допоміжні методи для вебзастосунків на основі сторінок Razor. Сторінки Razor походять від класу PageModel і зазвичай іменуються із суфіксом Model, наприклад CreateModel. Суфікс моделі пропускається під час маршрутизації на сторінку. У таблиці наведено найпоширеніші методи.

Деякі допоміжні методи, що надаються класом PageModel.

|Метод|Сенс у використанні|
|-----|-------------------|
|HttpContext|Повертає HttpContext для поточної виконуваної дії.|
|Request|Повертає HttpRequest для дії, що виконується на даний момент.|
|Response|Повертає HttpResponse для дії, що виконується на даний момент.|
|RouteData|Повертає RouteData для поточної виконуваної дії (маршрутизація розглядається далі в цьому розділі).|
|ModelState|Повертає стан моделі щодо зв'язування моделі та перевірки (обидва розглянуто пізніше в цьому розділі).|
|Url|Повертає екземпляр IUrlHelper, що надає доступ до створення URL-адрес для застосунків та сервісів ASP.NET Core MVC.|
|ViewData, TempData|Надає дані до представлення через ViewDataDictionary та TempDataDictionary|
|Page|Повертає PageResult (похідний від ActionResult) як HTTP-відповідь.|
|PartialView|Повертає PartialViewResult до конвеєра відповідей.|
|ViewComponent|Повертає ViewComponentResult до конвеєра відповідей.|
|OnPageHandlerSelected|Виконується, коли вибрано метод обробника сторінки, але перед зв'язуванням моделі.|
|OnPageHandlerSelectionAsync|Асинхронна версія OnPageHandlerSelected.|
|OnPageHandlerExecuting|Виконується перед виконанням методу обробника сторінки.|
|OnPageHandlerExecutionAsync|Асинхронна версія OnPageHandlerExecuting.|
|OnPageHandlerExecuted|Виконується після виконання методу обробника сторінки.|
|User|Повертає користувача ClaimsPrincipal.|
|Content|Повертає ContentResult у відповідь. Перевантаження дозволяють додавати тип контенту та визначення кодування.|
|File|Повертає FileContentResult у відповідь.|
|Redirect|Серія методів, які перенаправляють користувача на іншу URL-адресу, повертаючи RedirectResult.|
|LocalRedirect|Серія методів, які перенаправляють користувача на іншу URL-адресу, лише якщо URL-адреса є локальною. Безпечніший за загальні методи перенаправлення.|
|RedirectToAction, RedirectToPage, RedirectToRoute|Серія методів, які перенаправляють на інший метод дії, Razor Page або іменований маршрут. Маршрутизація розглядається далі в цьому розділі.|
|TryUpdateModelAsync|Використовується для явного зв'язування моделі.|
|TryValidateModel|Використовується для явної перевірки моделі.|

В таблиці – допоміжні засоби коду стану HTTP.

Деякі допоміжні методи коду стану HTTP, що надаються класом PageModelClass

|Метод|Код стану HTTP, дія, результат|Код статуса|
|-----|------------------------------|-----------|
|NotFound|NotFound|404|
|Forbid|ForbidResult|403|
|BadRequest|BadRequestResult|400|
|StatusCode(int)StatusCode(int, object)|StatusCodeResultObjectResult|Визначається параметром int.|

Ви можете бути здивовані, побачивши деякі знайомі методи з класу Controller. Сторінкові програми Razor мають багато спільних функцій із програмами у стилі MVC, як ви вже бачили та бачитимете далі в цих розділах.

## Методи обробника сторінок

Як обговорювалося в розділі маршрутизації, сторінки Razor визначають методи обробника для обробки HTTP-запитів Get та Post. Клас PageModel підтримує як синхронні, так і асинхронні методи обробника. Дієслово, що в назві обробника, залежить від назви методу, причому OnPost()/OnPostAsync() обробляє HTTP-запити post, а OnGet()/OnGetAsync() — HTTP-запити get. Версії асинхронних функцій перелічені тут:

```cs
public class DeleteModel : PageModel
{
  public async Task<IActionResult> OnGetAsync(int? id)
  {
    //handle the get request here
  }
  public async Task<IActionResult> OnPostAsync(int? id)
  {
    //handle the post request here
  }
}
```

Назви методів обробників можна змінювати, і для кожного HTTP-метода може існувати кілька методів обробників, проте перевантажені версії з однаковою назвою не допускаються. Це буде розглянуто в окремій главі.

# Обізнаність про середовище

Обізнаність програм ASP.NET Core про середовище виконання включає змінні середовища хоста та розташування файлів через екземпляр IWebHostEnvironment, який реалізує інтерфейс IHostEnvironment. У таблиці показано властивості, доступні через ці інтерфейси.

Властивості IWebHostEnvironment

|Властивість|Надається функціональність|
|-----------|--------------------------|
|ApplicationName|Видає або встановлює назву програми. За замовчуванням використовується ім'я запису.|
|ContentRootPath|Видає або встановлює абсолютний шлях до каталогу, що містить файли вмісту програми.|
|ContentRootFileProvider|Видає або встановлює IFileProvider, що вказує на ContentRootPath.|
|EnvironmentName|Видає або встановлює назву середовища. Встановлює значення змінної середовища ASPNETCORE_ENVIRONMENT.|
|WebRootPath|Видає або встановлює абсолютний шлях до каталогу, що містить файли вмісту веб-застосунку.|
|WebRootFileProvider|Отримує або встановлює IFileProvider, що вказує на WebRootPath.|

Окрім доступу до відповідних шляхів до файлів, IWebHostEnvironment використовується для визначення середовища виконання.

## Визначення середовища виконання

ASP.NET Core автоматично зчитує значення змінної середовища з назвою ASPNETCORE_ENVIRONMENT, щоб встановити середовище виконання. Якщо змінна ASPNETCORE_ENVIRONMENT не встановлена, ASP.NET Core встановлює значення Production. Набір значень доступний через властивість EnvironmentName в IWebHostEnvironment. 
Під час розробки застосунків ASP.NET Core ця змінна зазвичай встановлюється за допомогою файлу launchSettings.json або командного рядка. Нижчі середовища (staging, production, тощо) зазвичай використовують стандартні змінні середовища операційної системи.
Ви можете використовувати будь-яке ім'я для середовища або три, що надаються статичним класом Environments.

```cs
public static class Environments
{
  public static readonly string Development = "Development";
  public static readonly string Staging = "Staging";
  public static readonly string Production = "Production";
}
```
Клас HostEnvironmentEnvExtensions надає методи розширення для IHostEnvironment для роботи з властивістю EnvironmentName.

Методи HostEnvironmentEnvExtensions

|Метод|Надається функціональність|
|-----|--------------------------|
|IsProduction|Повертає значення true, якщо змінна середовища має значення Production (без урахування регістру)|
|IsStaging|Повертає значення true, якщо змінна середовища має значення Staging (без урахування регістру).|
|IsDevelopment|Повертає значення true, якщо змінна середовища має значення Development (без урахування регістру)|
|IsEnvironment|Повертає значення true, якщо змінна середовища відповідає рядку, переданому в метод (без урахування регістру)|

Ось деякі приклади використання налаштувань середовища:

1. Визначення файлів конфігурації для завантаження
2. Налаштування параметрів налагодження, помилок та ведення журналу
3. Завантаження файлів JavaScript та CSS, специфічних для середовища

Перегляньте файл Program.cs у проекті AutoLot.Mvc. Ближче до кінця файлу перевіряється середовище, щоб визначити, чи слід використовувати стандартний обробник винятків та HSTS (HTTP Strict Transport Security Protocol):

```cs
// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Home/Error");
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}

```

Оновіть цей блок, щоб перевернути його:

```cs
if (!app.Environment.IsDevelopment())
{
}
else
{
    app.UseExceptionHandler("/Home/Error");
    app.UseHsts();
}
```
Далі, під час розробки програми додайте сторінку винятків розробника до конвеєра. Це надає деталі налагодження, такі як трасування стека, детальна інформація про винятки тощо. Стандартний обробник винятків відображає просту сторінку помилки.

```cs
if (!app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}
else
{
    app.UseExceptionHandler("/Home/Error");
    app.UseHsts();
}
```
Оновіть блок проєкту AutoLot.Web до наступного (зверніть увагу на інший маршрут для дескриптора помилки в застосунку на основі сторінок Razor):

```cs
if (!app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}
else
{
    app.UseExceptionHandler("/Error");
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}
```
Проект AutoLot.Api дещо відрізняється. Він перевіряє середовище розробки, і якщо воно працює в процесі розробки, Swagger та SwaggerUI додаються до конвеєра. Для цієї програми ми перемістимо код Swagger з блоку if, щоб він завжди був доступний (залиште блок if там, оскільки він буде використаний пізніше в цьому розділі):

```cs

```
Оскільки немає інтерфейсу користувача, пов'язаного з RESTful-сервісами, немає потреби в сторінці винятків розробника. Swagger буде детально розглянуто в наступному розділі.

## WebAppBuilder та WebApp

На відміну від класичних застосунків ASP.NET MVC або ASP.NET Web API, застосунки ASP.NET Core – це консольні застосунки .NET, які створюють та налаштовують WebApplication, що є екземпляром IHost. Створення конфігурації IHost налаштовує програму на прослуховування та відповідь на HTTP-запити.
Шаблони за замовчуванням для ASP.NET Core MVC, Razor та сервісних застосунків є мінімальними. Ці файли будуть додаватися в міру того, як ви будете проходити розділи ASP.NET Core. До появи версій .NET 6 та C# 10 веб-хостинг створювався в методі Main() файлу Program.cs та налаштовувався для вашої програми у файлі Startup.cs. З виходом .NET 6 та C# 10 шаблон ASP.NET Core використовує оператори верхнього рівня у файлі Program.cs для створення та налаштування та не має файлу Startup.cs.

## Файл Program.cs із RESTful-сервісами

Відкрийте клас Program.cs у застосунку AutoLot.Api та перегляньте його вміст, наведений тут для довідки:
```cs
var builder = WebApplication.CreateBuilder(args);

// Add services to the container.

builder.Services.AddControllers();
// Learn more about configuring OpenAPI at https://aka.ms/aspnet/openapi
builder.Services.AddOpenApi();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.MapOpenApi();
}

app.UseHttpsRedirection();

app.UseAuthorization();

app.MapControllers();

app.Run();
```

Якщо ви використовуєте попередню версію ASP.NET Core, попередній код було розділено між файлами Program.cs та Startup.cs. У ASP.NET Core 6 ці файли об'єднані в оператори верхнього рівня у файлі Program.cs.Код перед викликом builder.Build() містився у файлі Program.cs, а метод ConfigureServices() – у файлі Startup.cs, і відповідає за створення WebApplicationBuilder та реєстрацію служб у контейнері впровадження залежностей. Код, що включає виклик builder.Build() та решту коду у файлі, містився у методі Configure() і відповідає за налаштування HTTP-конвеєра.
Метод CreateBuilder() стискає найтиповіші налаштування програми в один виклик методу. Він налаштовує програму (використовуючи змінні середовища та JSON-файли appsettings), налаштовує постачальника журналювання за замовчуванням та встановлює контейнер для впровадження залежностей. Повернений WebApplicationBuilder використовується для реєстрації сервісів, додавання додаткової інформації про конфігурацію, підтримки ведення журналу тощо. Наступний набір методів додає необхідні базові сервіси до контейнера впровадження залежностей для побудови RESTful сервісів. Метод AddControllers() додає підтримку використання контролерів та методів дій, метод AddEndpointsApiExplorer() надає інформацію про API (і використовується Swagger), а AddSwaggerGen() створює базову підтримку OpenAPI.

    Додаючи сервіси до контейнера Dependency Injection, обов’язково додайте їх до операторів верхнього рівня за допомогою коментаря //Add services to the container.. Їх необхідно додати перед викликом методу builder.Build().

Метод builder.Build() генерує WebApplication та налаштовує наступну групу викликів методів для налаштування HTTP-конвеєра. Розділ «Environment» обговорювався раніше. Наступний набір викликів гарантує, що всі запити використовують HTTPS, активує проміжне програмне забезпечення авторизації та зіставляє контролери з їхніми кінцевими точками. Нарешті, метод Run() запускає застосунок і готує все для отримання веб-запитів і відповіді на них.