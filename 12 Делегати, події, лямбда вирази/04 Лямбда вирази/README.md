# Лямбда вирази

Щоб завершити ваш погляд на архітектуру подій .NET, ви вивчите лямбда-вирази C#. Як щойно було пояснено, C# підтримує здатність обробляти події «вбудовано», призначаючи блок операторів коду безпосередньо події за допомогою анонімних методів, а не створення автономного методу, який буде викликатися базовим делегатом.
Лямбда-вирази — це не що інше, як стислий спосіб створення анонімних методів і, зрештою, спрощення роботи з типом делегату .NET.

Щоб створити основу для вивчення лямбда-виразів, створіть новий проект консольної програми під назвою LambdaExpressions. 
Для початку розглянемо метод FindAll() загального класу List<T>. Цей метод може бути викликаний, коли вам потрібно витягти підмножину елементів із колекції, і прототипується таким чином:

```cs
// Method of the System.Collections.Generic.List<T>
public List<T> FindAll(Predicate<T> match)
```
Як бачите, цей метод повертає новий List<T>, який представляє підмножину даних. Також зауважте, що єдиним параметром FindAll() є загальний делегат типу System.Predicate<T>. Цей тип делегату може вказувати на будь-який метод, що повертає bool, і приймає єдиний параметр типу як єдиний вхідний параметр.

```cs
// This delegate is used by FindAll() method
// to extract out the subset.
public delegate bool Predicate<T>(T obj);
```
Коли ви викликаєте FindAll(), кожен елемент у List<T> передається методу, на який вказує об’єкт Predicate<T>. Реалізація зазначеного методу виконає деякі обчислення, щоб побачити, чи відповідають вхідні дані необхідним критеріям, і поверне значення true або false. Якщо цей метод повертає значення true, елемент буде додано до нового списку List<T>, який представляє підмножину.
Перш ніж ви побачите, як лямбда-вирази можуть спростити роботу з FindAll(), давайте розберемо проблему в довгій нотації, безпосередньо використовуючи об’єкти делегатів. Додайте метод під назвою TraditionalDelegateSyntax() у свій файл Program.cs, який взаємодіє з типом System.Predicate<T>, щоб виявити парні числа в List<T> цілих чисел.

```cs
static void TraditionalDelegateSyntax()
{
    List<int> ints = [20, 1, 4, 8, 9, 44];

    // Target for the Predicate<> delegate.
    static bool IsEvenNumber(int i)
    {
        return (i % 2 == 0);
    }

    // Call FindAll() using traditional delegate syntax.
    Predicate<int> callback = IsEvenNumber;

    List<int> evenNumbers = ints.FindAll(callback);

    foreach (var number in evenNumbers)
    {
        Console.Write(number+"\t");
    }

}
TraditionalDelegateSyntax();
```
```
20      4       8       44
```
Тут у вас є метод (IsEvenNumber()), який контролює перевірку вхідного цілочисельного параметра, щоб визначити, чи є він парним чи непарним за допомогою оператора модуля C#, %. Хоча цей традиційний підхід до роботи з делегатами працює належним чином, метод IsEvenNumber() викликається лише в обмежених випадках, зокрема, коли ви викликаєте FindAll(), який залишає вам багаж повного визначення методу. Якщо замість цього використовувати анонімний метод, ваш код значно очиститься. Розглянемо наступний новий метод файлу Program.cs:

```cs
static void AnonymousMethodSyntax()
{
    List<int> ints = [20, 1, 4, 8, 9, 44];

    // Now, use an anonymous method.
    List<int> evenNumbers = ints.FindAll(delegate (int i) { return (i % 2 == 0);});

    foreach (var number in evenNumbers)
    {
        Console.Write(number + "\t");
    }

}
AnonymousMethodSyntax();
```
```
20      4       8       44
```
У цьому випадку замість того, щоб безпосередньо створювати об’єкт делегату Predicate<T> і потім створювати окремий метод, ви можете вбудувати метод анонімно. Незважаючи на те, що це крок у правильному напрямку, ви все одно зобов’язані використовувати ключове слово delegate (або суворо типізований Predicate<T>), і ви повинні переконатися, що список параметрів повністю відповідає.
Лямбда-вирази можна використовувати для ще більшого спрощення виклику FindAll(). Коли ви використовуєте лямбда-синтаксис, немає жодних слідів базового об’єкта делегату. Розглянемо такий новий метод для файлу Program.cs:

```cs
static void LambdaExpressionSyntax()
{
    List<int> ints = [20, 1, 4, 8, 9, 44];

    // Now, use a C# lambda expression.
    List<int> evenNumbers = ints.FindAll( i => (i % 2) == 0 );

    foreach (var number in evenNumbers)
    {
        Console.Write(number + "\t");
    }

}
LambdaExpressionSyntax();
```
У цьому випадку зверніть увагу на досить дивний оператор коду, який передається в метод FindAll(), який насправді є лямбда-виразом. У цій ітерації прикладу немає жодних слідів делегату Predicate<T> (або ключового слова delegate, якщо на те пішло). Все, що ви вказали, це лямбда-вираз.

```cs
i => (i % 2) == 0
```
Перш ніж я розберу цей синтаксис, спочатку зрозумійте, що лямбда-вирази можна використовувати будь-де, де б ви використовували анонімний метод або строго типізований делегат (зазвичай із набагато меншою кількістю натискань клавіш). Під капотом компілятор C# перетворює вираз у стандартний анонімний метод, використовуючи тип делегату Predicate<T> (який можна перевірити за допомогою ildasm.exe або reflector.exe). Зокрема, такий оператор коду:

```cs
// This lambda expression...
List<int> evenNumbers = list.FindAll(i => (i % 2) == 0);
```
компілюється в наступний приблизний код C#:

```cs
// ...becomes this anonymous method.
List<int> evenNumbers = list.FindAll(delegate (int i)
{
  return (i % 2) == 0;
});
```

## Розкладання лямбда-виразу

Лямбда-вираз записується шляхом визначення списку параметрів, а потім маркера =>, а потім набору операторів (або окремого оператора), які оброблятимуть ці аргументи.
З високого рівня лямбда-вираз можна зрозуміти так:

```
ArgumentsToProcess => StatementsToProcessThem
```
У методі LambdaExpressionSyntax() все розбивається так:

```cs
// i is our parameter list.
// (i % 2) == 0 is our statement set to process i.
List<int> evenNumbers = list.FindAll(i => (i % 2) == 0);
```

Параметри лямбда-виразу можуть бути явно або неявно введені. Наразі базовий тип даних, що представляє параметр i (ціле число), визначається неявно. Компілятор може визначити, що i є цілим числом на основі контексту загального лямбда-виразу та основного делегату. Однак можна також явно визначити тип кожного параметра у виразі, загорнувши тип даних і назву змінної в дужки, як показано нижче:

```cs
// Now, explicitly state the parameter type.
List<int> evenNumbers = list.FindAll((int i) => (i % 2) == 0);
```
Як ви бачили, якщо лямбда-вираз має один неявно введений параметр, круглі дужки можна опустити в списку параметрів.Якщо ви хочете бути послідовними щодо використання лямбда-параметрів, ви завжди можете загорнути список параметрів у круглі дужки, залишивши вам такий вираз:

```cs
List<int> evenNumbers = list.FindAll((i) => (i % 2) == 0);
```
Нарешті, зауважте, що наразі вираз не було укладено в дужки (ви, звичайно, загорнули оператор %, щоб переконатися, що він виконується першим перед тестом на рівність). Лямбда-вирази дозволяють обернути оператор таким чином:

```cs
// Now, wrap the expression as well.
List<int> evenNumbers = list.FindAll((i) => ((i % 2) == 0));
```
Тепер, коли ви побачили різні способи побудови лямбда-виразу, як ви можете прочитати цей лямбда-вираз у зручних для людини термінах? Залишаючи позаду сиру математику, наступне пояснення відповідає вимогам:

```cs
// My list of parameters (in this case, a single integer named i)
// will be processed by the expression (i % 2) == 0.
List<int> evenNumbers = list.FindAll((i) => ((i % 2) == 0));
```

## Обробка аргументів у кількох операторах

Перший лямбда-вираз був одним оператором, який в кінцевому підсумку обчислювався як логічне значення. Однак, як ви знаєте, багато цільових делегатів повинні виконувати кілька операторів коду. З цієї причини C# дозволяє створювати лямбда-вирази, що містять кілька операторів, вказуючи блок коду за допомогою стандартних фігурних дужок. Розглянемо такий приклад:

```cs
static void LambdaExpressionSyntaxWithMultipleStatements()
{
    List<int> ints = [20, 1, 4, 8, 9, 44];

    // Now process each argument within a group of
    // code statements.
    List<int> evenNumbers = ints.FindAll(i =>
    {
        bool isEven = (i % 2 == 0);
        Console.WriteLine($"Value i ={i}. Is even?: {isEven}");
        return isEven;
    });
    Console.WriteLine();

    foreach (var number in evenNumbers)
    {
        Console.Write(number + "\t");
    }
}
LambdaExpressionSyntaxWithMultipleStatements();
```
```
Value i =20. Is even?: True
Value i =1. Is even?: False
Value i =4. Is even?: True
Value i =8. Is even?: True
Value i =9. Is even?: False
Value i =44. Is even?: True

20      4       8       44
```
У цьому випадку список параметрів (знову ж таки, одне ціле число з іменем i) обробляється набором операторів коду. Крім викликів Console.WriteLine(), інструкція % була розбита на дві інструкції коду для кращої читабельності.

## Лямбда-вирази з кількома параметрами або без них

Лямбда-вирази, які ви бачили в цьому розділі, обробляли один параметр. Однак це не є вимогою, оскільки лямбда-вираз може обробляти кілька аргументів або жодного. Щоб проілюструвати перший сценарій із кількома аргументами, додайте таке втілення типу SimpleMath:

```cs
namespace LambdaExpressions;

public class SimpleMath
{
    public delegate void MathMessage(string message, int result);
    private MathMessage _mmDelegate;

    public void SetMathHandler(MathMessage target)
    {
        _mmDelegate = target;
    }

    public void Add(int x,int y)
    {
        _mmDelegate?.Invoke("Adding has completed!", x + y);
    }
}
```
Зверніть увагу, що тип делегату MathMessage очікує два параметри. Щоб представити їх як лямбда-вираз, код можна записати так:

```cs
static void LambdaWithMultipleParameters()
{
    SimpleMath simpleMath = new();

    // Register with delegate as a lambda expression.
    simpleMath.SetMathHandler((message, result) => 
    {
        Console.WriteLine($"Message:{message} Result:{result}");
    });

    simpleMath.Add(5, 3);

}
LambdaWithMultipleParameters();
```
```
Message:Adding has completed! Result:8
```

Тут ви використовуєте неявне визначення типу, оскільки два параметри не були строго типізовані для простоти. Однак ви можете викликати SetMathHandler() таким чином:

```cs
    simpleMath.SetMathHandler((string message, int result) => 
    {
        Console.WriteLine($"Message:{message} Result:{result}");
    });
```
Нарешті, якщо ви використовуєте лямбда-вираз для взаємодії з делегатом, який взагалі не приймає параметрів, ви можете зробити це, поставивши пару порожніх дужок як параметр. Таким чином, якщо ви визначили такий тип делегату:

```cs
public delegate string VerySimpleDelegate();
```
Використовуючи синтаксис виразу, ви можете обробити результат виклику наступним чином:

```cs
static void LambdaWithoutParameters()
{
    VerySimpleDelegate simpleDelegate = new(() => "Enjoy your string!");

    // or

    VerySimpleDelegate simpleDelegate1 = () => "Enjoy your string!";

    Console.WriteLine(simpleDelegate());
    Console.WriteLine(simpleDelegate1());

}
LambdaWithoutParameters();
```
```
Enjoy your string!
Enjoy your string!
```

## Використання static з лямбда-виразами

Оскільки лямбда-вирази є скороченням делегатів, зрозуміло, що лямбда також підтримує статичні ключові слова, а також відкидання. Додайте наступне:

```cs
void OtherLambdа()
{
    var outerVariable = 0;

    Func<int, int, bool> DoWork = (_, _) =>
    {
        //Compile error since it’s accessing an outer variable
        outerVariable++;
        return true;
    };

    Console.WriteLine(DoWork(3,3));
    Console.WriteLine($"Outer variable now = {outerVariable}");
}
OtherLambdа();
```
```
True
Outer variable now = 1
```
Це працює як і очікувалось. Якщо ви оновите лямбда-вираз до статичного, ви отримаєте помилку компіляції, оскільки вираз намагається оновити змінну, оголошену у зовнішній області.

```cs
    Func<int, int, bool> DoWork = static (x, y) =>
    {
        //Compile error since it’s accessing an outer variable
        outerVariable++;
        return true;
    };
```
## Відкидання за допомогою лямбда-виразів 

Як і у випадку з делегатами, вхідні змінні лямбда-виразу можна замінити відхиленнями, якщо вхідні змінні не потрібні.

```cs
    Func<int, int, bool> DoWork = (_, _) =>
    {
        //Compile error since it’s accessing an outer variable
        outerVariable++;
        return true;
    };
```

## Модернізація прикладу CarEvents за допомогою лямбда-виразів

Враховуючи, що вся причина лямбда-виразів полягає в тому, щоб забезпечити чіткий, стислий спосіб визначення анонімного методу (і, отже, опосередковано спосіб спростити роботу з делегатами), давайте модернізуємо проект CarEventArgs, створений раніше в цій главі.
Ось спрощена версія  яка використовує синтаксис лямбда-виразу (а не необроблені делегати) для підключення до кожної події, надісланої з об’єкта Car:

```cs
static void UsingLambda()
{
    Car2 car = new("SlugBug", 100, 10);

    car.AboutToBlow += (_,e) => Console.WriteLine(e.message);
    
    car.Exploded += (sender,e)=> 
    Console.WriteLine($"{e.message.ToUpper()}\t{((Car2)sender!)?.CurrentSpeed}");

    Console.WriteLine("***** Speeding up *****");
    for (int i = 0; i < 6; i++)
    {
        car.Accelerate(20);
    }
}
UsingLambda();
```

## Лямбда-вирази та члени класу з тілом виразу

Тепер, коли ви розумієте лямбда-вирази та те, як вони працюють, має бути набагато зрозуміліше, як члени, що містять вирази, працюють під ковдрою. Дозволено використовувати оператор => для спрощення реалізації членів. Зокрема, якщо у вас є метод або властивість (на додаток до спеціального оператора або частини коду перетворення), які складаються лише з одного рядка коду в реалізації, вам не потрібно визначати область за допомогою фігурних дужок. Натомість ви можете використати лямбда-оператор і написати елемент із тілом виразу. Також можете використовувати цей синтаксис для конструкторів класів, фіналізаторів, а також засобів доступу для отримання та встановлення для елементів властивості.

Однак майте на увазі, що цей новий скорочений синтаксис можна використовувати будь-де, навіть якщо ваш код не має нічого спільного з делегатами чи подіями. Отже, наприклад, якщо ви створили тривіальний клас для додавання двох чисел, ви можете написати наступне:

```cs
    public int Add(int x,int y, int z)
    {
        return x+y+z;
    }

    public void PrintSum(int x, int y)
    {

        Console.WriteLine(x+y);
    }
```

Як альтернатива, ви можете використати лямбда вирази.

```cs
    public int AddWithLambda(int x, int y,int z) => x+y+z; 
    public void PrintSumLambda(int x,int y) => Console.WriteLine(x+y); 
```

В ідеалі на цьому етапі ви можете побачити загальну роль лямбда-виразів і зрозуміти, як вони забезпечують «функціональний спосіб» роботи з анонімними методами та типами делегатів. Хоча до лямбда-оператора (=>) може знадобитися деякий час, щоб звикнути, завжди пам’ятайте, що лямбда-вираз можна розкласти до такого простого рівняння:

```
ArgumentsToProcess =>
{
  //StatementsToProcessThem
}
```
Або, якщо використовувати оператор => для реалізації елемента однорядкового типу, це буде так:

```
TypeMember => SingleCodeStatement
```
Варто зазначити, що модель програмування LINQ також значною мірою використовує лямбда-вирази, щоб спростити кодування.

# Підсумки

У цьому розділі ви розглянули кілька способів, за допомогою яких кілька об’єктів можуть брати участь у двонаправленій взаємодії. Спочатку ви розглянули ключове слово C# delegate, яке використовується для опосередкованого створення класу, похідного від System.MulticastDelegate. Як ви бачили, об’єкт делегату зберігає метод для виклику, коли йому наказано це зробити. 
Потім ви розглянули ключове слово C# event, яке, якщо використовувати його разом із типом делегату, може спростити процес надсилання сповіщень про події абонентам, що очікують. Як показано через отриманий CIL, модель події .NET відображає приховані виклики типів System.Delegate/System.MulticastDelegate.У цьому світлі ключове слово C# event є суто необов’язковим, оскільки воно просто економить час на введення.
Крім того, ви бачили, що нульовий умовний оператор C# спрощує спосіб безпечного запуску подій для будь-якої зацікавленої сторони.
У цій главі також досліджено функцію мови C#, яка називається анонімними методами. Використовуючи цю синтаксичну конструкцію, ви можете безпосередньо пов’язати блок операторів коду з певною подією. Як ви бачили, анонімні методи можуть ігнорувати параметри, надіслані подією, і мати доступ до «зовнішніх змінних» визначального методу. Ви також розглянули спрощений спосіб реєстрації подій за допомогою перетворення групи методів.
Нарешті, ви закінчили, подивившись на C# лямбда-оператор, =>. Як показано, цей синтаксис є чудовою скороченою нотацією для створення анонімних методів, де стек аргументів можна передати в групу операторів для обробки. Будь-який метод у платформі .NET, який приймає об’єкт делегату як аргумент, можна замінити пов’язаним лямбда-виразом, що зазвичай значно спрощує вашу кодову базу.